data
align 4
LABELV numBaseParticleSystems
byte 4 0
align 4
LABELV numBaseParticleEjectors
byte 4 0
align 4
LABELV numBaseParticles
byte 4 0
code
proc CG_LerpValues 4 0
file "..\..\..\..\src/cgame/cg_particles.c"
line 49
;1:/*
;2:===========================================================================
;3:Copyright (C) 2000-2006 Tim Angus
;4:
;5:This file is part of Tremulous.
;6:
;7:Tremulous is free software; you can redistribute it
;8:and/or modify it under the terms of the GNU General Public License as
;9:published by the Free Software Foundation; either version 2 of the License,
;10:or (at your option) any later version.
;11:
;12:Tremulous is distributed in the hope that it will be
;13:useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
;14:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;15:GNU General Public License for more details.
;16:
;17:You should have received a copy of the GNU General Public License
;18:along with Tremulous; if not, write to the Free Software
;19:Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
;20:===========================================================================
;21:*/
;22:
;23:// cg_particles.c -- the particle system
;24:
;25:
;26:#include "cg_local.h"
;27:
;28:static baseParticleSystem_t   baseParticleSystems[ MAX_BASEPARTICLE_SYSTEMS ];
;29:static baseParticleEjector_t  baseParticleEjectors[ MAX_BASEPARTICLE_EJECTORS ];
;30:static baseParticle_t         baseParticles[ MAX_BASEPARTICLES ];
;31:static int                    numBaseParticleSystems = 0;
;32:static int                    numBaseParticleEjectors = 0;
;33:static int                    numBaseParticles = 0;
;34:
;35:static particleSystem_t     particleSystems[ MAX_PARTICLE_SYSTEMS ];
;36:static particleEjector_t    particleEjectors[ MAX_PARTICLE_EJECTORS ];
;37:static particle_t           particles[ MAX_PARTICLES ];
;38:static particle_t           *sortedParticles[ MAX_PARTICLES ];
;39:static particle_t           *radixBuffer[ MAX_PARTICLES ];
;40:
;41:/*
;42:===============
;43:CG_LerpValues
;44:
;45:Lerp between two values
;46:===============
;47:*/
;48:static float CG_LerpValues( float a, float b, float f )
;49:{
line 50
;50:  if( b == PARTICLES_SAME_AS_INITIAL )
ADDRFP4 4
INDIRF4
CNSTF4 3221225472
NEF4 $100
line 51
;51:    return a;
ADDRFP4 0
INDIRF4
RETF4
ADDRGP4 $99
JUMPV
LABELV $100
line 53
;52:  else
;53:    return ( (a) + (f) * ( (b) - (a) ) );
ADDRLP4 0
ADDRFP4 0
INDIRF4
ASGNF4
ADDRLP4 0
INDIRF4
ADDRFP4 8
INDIRF4
ADDRFP4 4
INDIRF4
ADDRLP4 0
INDIRF4
SUBF4
MULF4
ADDF4
RETF4
LABELV $99
endproc CG_LerpValues 4 0
proc CG_RandomiseValue 8 0
line 64
;54:}
;55:
;56:/*
;57:===============
;58:CG_RandomiseValue
;59:
;60:Randomise some value by some variance
;61:===============
;62:*/
;63:static float CG_RandomiseValue( float value, float variance )
;64:{
line 65
;65:  if( value != 0.0f )
ADDRFP4 0
INDIRF4
CNSTF4 0
EQF4 $103
line 66
;66:    return value * ( 1.0f + ( random( ) * variance ) );
ADDRLP4 0
ADDRGP4 rand
CALLI4
ASGNI4
ADDRFP4 0
INDIRF4
ADDRLP4 0
INDIRI4
CNSTI4 32767
BANDI4
CVIF4 4
CNSTF4 1191181824
DIVF4
ADDRFP4 4
INDIRF4
MULF4
CNSTF4 1065353216
ADDF4
MULF4
RETF4
ADDRGP4 $102
JUMPV
LABELV $103
line 68
;67:  else
;68:    return random( ) * variance;
ADDRLP4 4
ADDRGP4 rand
CALLI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 32767
BANDI4
CVIF4 4
CNSTF4 1191181824
DIVF4
ADDRFP4 4
INDIRF4
MULF4
RETF4
LABELV $102
endproc CG_RandomiseValue 8 0
proc CG_SpreadVector 52 16
line 79
;69:}
;70:
;71:/*
;72:===============
;73:CG_SpreadVector
;74:
;75:Randomly spread a vector by some amount
;76:===============
;77:*/
;78:static void CG_SpreadVector( vec3_t v, float spread )
;79:{
line 81
;80:  vec3_t  p, r1, r2;
;81:  float   randomSpread = crandom( ) * spread;
ADDRLP4 44
ADDRGP4 rand
CALLI4
ASGNI4
ADDRLP4 36
CNSTF4 1073741824
ADDRLP4 44
INDIRI4
CNSTI4 32767
BANDI4
CVIF4 4
CNSTF4 1191181824
DIVF4
CNSTF4 1056964608
SUBF4
MULF4
ADDRFP4 4
INDIRF4
MULF4
ASGNF4
line 82
;82:  float   randomRotation = random( ) * 360.0f;
ADDRLP4 48
ADDRGP4 rand
CALLI4
ASGNI4
ADDRLP4 40
CNSTF4 1135869952
ADDRLP4 48
INDIRI4
CNSTI4 32767
BANDI4
CVIF4 4
CNSTF4 1191181824
DIVF4
MULF4
ASGNF4
line 84
;83:
;84:  PerpendicularVector( p, v );
ADDRLP4 0
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRGP4 PerpendicularVector
CALLV
pop
line 86
;85:
;86:  RotatePointAroundVector( r1, p, v, randomSpread );
ADDRLP4 12
ARGP4
ADDRLP4 0
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 36
INDIRF4
ARGF4
ADDRGP4 RotatePointAroundVector
CALLV
pop
line 87
;87:  RotatePointAroundVector( r2, v, r1, randomRotation );
ADDRLP4 24
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 12
ARGP4
ADDRLP4 40
INDIRF4
ARGF4
ADDRGP4 RotatePointAroundVector
CALLV
pop
line 89
;88:
;89:  VectorCopy( r2, v );
ADDRFP4 0
INDIRP4
ADDRLP4 24
INDIRB
ASGNB 12
line 90
;90:}
LABELV $105
endproc CG_SpreadVector 52 16
proc CG_DestroyParticle 12 8
line 100
;91:
;92:/*
;93:===============
;94:CG_DestroyParticle
;95:
;96:Destroy an individual particle
;97:===============
;98:*/
;99:static void CG_DestroyParticle( particle_t *p, vec3_t impactNormal )
;100:{
line 102
;101:  //this particle has an onDeath particle system attached
;102:  if( p->class->onDeathSystemName[ 0 ] != '\0' )
ADDRFP4 0
INDIRP4
INDIRP4
CNSTI4 516
ADDP4
INDIRI1
CVII4 1
CNSTI4 0
EQI4 $107
line 103
;103:  {
line 106
;104:    particleSystem_t  *ps;
;105:
;106:    ps = CG_SpawnNewParticleSystem( p->class->onDeathSystemHandle );
ADDRFP4 0
INDIRP4
INDIRP4
CNSTI4 580
ADDP4
INDIRI4
ARGI4
ADDRLP4 4
ADDRGP4 CG_SpawnNewParticleSystem
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 4
INDIRP4
ASGNP4
line 108
;107:
;108:    if( CG_IsParticleSystemValid( &ps ) )
ADDRLP4 0
ARGP4
ADDRLP4 8
ADDRGP4 CG_IsParticleSystemValid
CALLI4
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 0
EQI4 $109
line 109
;109:    {
line 110
;110:      if( impactNormal )
ADDRFP4 4
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $111
line 111
;111:        CG_SetParticleSystemNormal( ps, impactNormal );
ADDRLP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRGP4 CG_SetParticleSystemNormal
CALLV
pop
LABELV $111
line 113
;112:
;113:      CG_SetAttachmentPoint( &ps->attachment, p->origin );
ADDRLP4 0
INDIRP4
CNSTI4 4
ADDP4
ARGP4
ADDRFP4 0
INDIRP4
CNSTI4 32
ADDP4
ARGP4
ADDRGP4 CG_SetAttachmentPoint
CALLV
pop
line 114
;114:      CG_AttachToPoint( &ps->attachment );
ADDRLP4 0
INDIRP4
CNSTI4 4
ADDP4
ARGP4
ADDRGP4 CG_AttachToPoint
CALLV
pop
line 115
;115:    }
LABELV $109
line 116
;116:  }
LABELV $107
line 118
;117:
;118:  p->valid = qfalse;
ADDRFP4 0
INDIRP4
CNSTI4 324
ADDP4
CNSTI4 0
ASGNI4
line 122
;119:
;120:  //this gives other systems a couple of
;121:  //frames to realise the particle is gone
;122:  p->frameWhenInvalidated = cg.clientFrame;
ADDRFP4 0
INDIRP4
CNSTI4 328
ADDP4
ADDRGP4 cg
INDIRI4
ASGNI4
line 123
;123:}
LABELV $106
endproc CG_DestroyParticle 12 8
proc CG_SpawnNewParticle 340 12
line 133
;124:
;125:/*
;126:===============
;127:CG_SpawnNewParticle
;128:
;129:Introduce a new particle into the world
;130:===============
;131:*/
;132:static particle_t *CG_SpawnNewParticle( baseParticle_t *bp, particleEjector_t *parent )
;133:{
line 135
;134:  int                     i, j;
;135:  particle_t              *p = NULL;
ADDRLP4 0
CNSTP4 0
ASGNP4
line 136
;136:  particleEjector_t       *pe = parent;
ADDRLP4 76
ADDRFP4 4
INDIRP4
ASGNP4
line 137
;137:  particleSystem_t        *ps = parent->parent;
ADDRLP4 12
ADDRFP4 4
INDIRP4
CNSTI4 4
ADDP4
INDIRP4
ASGNP4
line 141
;138:  vec3_t                  attachmentPoint, attachmentVelocity;
;139:  vec3_t                  transform[ 3 ];
;140:
;141:  for( i = 0; i < MAX_PARTICLES; i++ )
ADDRLP4 8
CNSTI4 0
ASGNI4
LABELV $114
line 142
;142:  {
line 143
;143:    p = &particles[ i ];
ADDRLP4 0
CNSTI4 336
ADDRLP4 8
INDIRI4
MULI4
ADDRGP4 particles
ADDP4
ASGNP4
line 146
;144:
;145:    //FIXME: the + 1 may be unnecessary
;146:    if( !p->valid && cg.clientFrame > p->frameWhenInvalidated + 1 )
ADDRLP4 0
INDIRP4
CNSTI4 324
ADDP4
INDIRI4
CNSTI4 0
NEI4 $118
ADDRGP4 cg
INDIRI4
ADDRLP4 0
INDIRP4
CNSTI4 328
ADDP4
INDIRI4
CNSTI4 1
ADDI4
LEI4 $118
line 147
;147:    {
line 148
;148:      memset( p, 0, sizeof( particle_t ) );
ADDRLP4 0
INDIRP4
ARGP4
CNSTI4 0
ARGI4
CNSTI4 336
ARGI4
ADDRGP4 memset
CALLP4
pop
line 151
;149:
;150:      //found a free slot
;151:      p->class = bp;
ADDRLP4 0
INDIRP4
ADDRFP4 0
INDIRP4
ASGNP4
line 152
;152:      p->parent = pe;
ADDRLP4 0
INDIRP4
CNSTI4 4
ADDP4
ADDRLP4 76
INDIRP4
ASGNP4
line 154
;153:
;154:      p->birthTime = cg.time;
ADDRLP4 0
INDIRP4
CNSTI4 8
ADDP4
ADDRGP4 cg+107604
INDIRI4
ASGNI4
line 155
;155:      p->lifeTime = (int)CG_RandomiseValue( (float)bp->lifeTime, bp->lifeTimeRandFrac );
ADDRLP4 84
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 84
INDIRP4
CNSTI4 132
ADDP4
INDIRI4
CVIF4 4
ARGF4
ADDRLP4 84
INDIRP4
CNSTI4 136
ADDP4
INDIRF4
ARGF4
ADDRLP4 88
ADDRGP4 CG_RandomiseValue
CALLF4
ASGNF4
ADDRLP4 0
INDIRP4
CNSTI4 12
ADDP4
ADDRLP4 88
INDIRF4
CVFI4 4
ASGNI4
line 157
;156:
;157:      p->radius.delay = (int)CG_RandomiseValue( (float)bp->radius.delay, bp->radius.delayRandFrac );
ADDRLP4 92
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 92
INDIRP4
CNSTI4 312
ADDP4
INDIRI4
CVIF4 4
ARGF4
ADDRLP4 92
INDIRP4
CNSTI4 316
ADDP4
INDIRF4
ARGF4
ADDRLP4 96
ADDRGP4 CG_RandomiseValue
CALLF4
ASGNF4
ADDRLP4 0
INDIRP4
CNSTI4 120
ADDP4
ADDRLP4 96
INDIRF4
CVFI4 4
ASGNI4
line 158
;158:      p->radius.initial = CG_RandomiseValue( bp->radius.initial, bp->radius.initialRandFrac );
ADDRLP4 100
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 100
INDIRP4
CNSTI4 320
ADDP4
INDIRF4
ARGF4
ADDRLP4 100
INDIRP4
CNSTI4 324
ADDP4
INDIRF4
ARGF4
ADDRLP4 104
ADDRGP4 CG_RandomiseValue
CALLF4
ASGNF4
ADDRLP4 0
INDIRP4
CNSTI4 128
ADDP4
ADDRLP4 104
INDIRF4
ASGNF4
line 159
;159:      p->radius.final = CG_RandomiseValue( bp->radius.final, bp->radius.finalRandFrac );
ADDRLP4 108
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 108
INDIRP4
CNSTI4 328
ADDP4
INDIRF4
ARGF4
ADDRLP4 108
INDIRP4
CNSTI4 332
ADDP4
INDIRF4
ARGF4
ADDRLP4 112
ADDRGP4 CG_RandomiseValue
CALLF4
ASGNF4
ADDRLP4 0
INDIRP4
CNSTI4 136
ADDP4
ADDRLP4 112
INDIRF4
ASGNF4
line 161
;160:
;161:      p->alpha.delay = (int)CG_RandomiseValue( (float)bp->alpha.delay, bp->alpha.delayRandFrac );
ADDRLP4 116
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 116
INDIRP4
CNSTI4 340
ADDP4
INDIRI4
CVIF4 4
ARGF4
ADDRLP4 116
INDIRP4
CNSTI4 344
ADDP4
INDIRF4
ARGF4
ADDRLP4 120
ADDRGP4 CG_RandomiseValue
CALLF4
ASGNF4
ADDRLP4 0
INDIRP4
CNSTI4 148
ADDP4
ADDRLP4 120
INDIRF4
CVFI4 4
ASGNI4
line 162
;162:      p->alpha.initial = CG_RandomiseValue( bp->alpha.initial, bp->alpha.initialRandFrac );
ADDRLP4 124
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 124
INDIRP4
CNSTI4 348
ADDP4
INDIRF4
ARGF4
ADDRLP4 124
INDIRP4
CNSTI4 352
ADDP4
INDIRF4
ARGF4
ADDRLP4 128
ADDRGP4 CG_RandomiseValue
CALLF4
ASGNF4
ADDRLP4 0
INDIRP4
CNSTI4 156
ADDP4
ADDRLP4 128
INDIRF4
ASGNF4
line 163
;163:      p->alpha.final = CG_RandomiseValue( bp->alpha.final, bp->alpha.finalRandFrac );
ADDRLP4 132
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 132
INDIRP4
CNSTI4 356
ADDP4
INDIRF4
ARGF4
ADDRLP4 132
INDIRP4
CNSTI4 360
ADDP4
INDIRF4
ARGF4
ADDRLP4 136
ADDRGP4 CG_RandomiseValue
CALLF4
ASGNF4
ADDRLP4 0
INDIRP4
CNSTI4 164
ADDP4
ADDRLP4 136
INDIRF4
ASGNF4
line 165
;164:
;165:      p->rotation.delay = (int)CG_RandomiseValue( (float)bp->rotation.delay, bp->rotation.delayRandFrac );
ADDRLP4 140
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 140
INDIRP4
CNSTI4 368
ADDP4
INDIRI4
CVIF4 4
ARGF4
ADDRLP4 140
INDIRP4
CNSTI4 372
ADDP4
INDIRF4
ARGF4
ADDRLP4 144
ADDRGP4 CG_RandomiseValue
CALLF4
ASGNF4
ADDRLP4 0
INDIRP4
CNSTI4 176
ADDP4
ADDRLP4 144
INDIRF4
CVFI4 4
ASGNI4
line 166
;166:      p->rotation.initial = CG_RandomiseValue( bp->rotation.initial, bp->rotation.initialRandFrac );
ADDRLP4 148
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 148
INDIRP4
CNSTI4 376
ADDP4
INDIRF4
ARGF4
ADDRLP4 148
INDIRP4
CNSTI4 380
ADDP4
INDIRF4
ARGF4
ADDRLP4 152
ADDRGP4 CG_RandomiseValue
CALLF4
ASGNF4
ADDRLP4 0
INDIRP4
CNSTI4 184
ADDP4
ADDRLP4 152
INDIRF4
ASGNF4
line 167
;167:      p->rotation.final = CG_RandomiseValue( bp->rotation.final, bp->rotation.finalRandFrac );
ADDRLP4 156
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 156
INDIRP4
CNSTI4 384
ADDP4
INDIRF4
ARGF4
ADDRLP4 156
INDIRP4
CNSTI4 388
ADDP4
INDIRF4
ARGF4
ADDRLP4 160
ADDRGP4 CG_RandomiseValue
CALLF4
ASGNF4
ADDRLP4 0
INDIRP4
CNSTI4 192
ADDP4
ADDRLP4 160
INDIRF4
ASGNF4
line 169
;168:
;169:      p->dLightRadius.delay =
ADDRLP4 164
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 164
INDIRP4
CNSTI4 400
ADDP4
INDIRI4
CVIF4 4
ARGF4
ADDRLP4 164
INDIRP4
CNSTI4 404
ADDP4
INDIRF4
ARGF4
ADDRLP4 168
ADDRGP4 CG_RandomiseValue
CALLF4
ASGNF4
ADDRLP4 0
INDIRP4
CNSTI4 204
ADDP4
ADDRLP4 168
INDIRF4
CVFI4 4
ASGNI4
line 171
;170:        (int)CG_RandomiseValue( (float)bp->dLightRadius.delay, bp->dLightRadius.delayRandFrac );
;171:      p->dLightRadius.initial =
ADDRLP4 172
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 172
INDIRP4
CNSTI4 408
ADDP4
INDIRF4
ARGF4
ADDRLP4 172
INDIRP4
CNSTI4 412
ADDP4
INDIRF4
ARGF4
ADDRLP4 176
ADDRGP4 CG_RandomiseValue
CALLF4
ASGNF4
ADDRLP4 0
INDIRP4
CNSTI4 212
ADDP4
ADDRLP4 176
INDIRF4
ASGNF4
line 173
;172:        CG_RandomiseValue( bp->dLightRadius.initial, bp->dLightRadius.initialRandFrac );
;173:      p->dLightRadius.final =
ADDRLP4 180
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 180
INDIRP4
CNSTI4 416
ADDP4
INDIRF4
ARGF4
ADDRLP4 180
INDIRP4
CNSTI4 420
ADDP4
INDIRF4
ARGF4
ADDRLP4 184
ADDRGP4 CG_RandomiseValue
CALLF4
ASGNF4
ADDRLP4 0
INDIRP4
CNSTI4 220
ADDP4
ADDRLP4 184
INDIRF4
ASGNF4
line 176
;174:        CG_RandomiseValue( bp->dLightRadius.final, bp->dLightRadius.finalRandFrac );
;175:
;176:      p->colorDelay = CG_RandomiseValue( bp->colorDelay, bp->colorDelayRandFrac );
ADDRLP4 188
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 188
INDIRP4
CNSTI4 432
ADDP4
INDIRI4
CVIF4 4
ARGF4
ADDRLP4 188
INDIRP4
CNSTI4 436
ADDP4
INDIRF4
ARGF4
ADDRLP4 192
ADDRGP4 CG_RandomiseValue
CALLF4
ASGNF4
ADDRLP4 0
INDIRP4
CNSTI4 232
ADDP4
ADDRLP4 192
INDIRF4
CVFI4 4
ASGNI4
line 178
;177:
;178:      p->bounceMarkRadius = CG_RandomiseValue( bp->bounceMarkRadius, bp->bounceMarkRadiusRandFrac );
ADDRLP4 196
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 196
INDIRP4
CNSTI4 220
ADDP4
INDIRF4
ARGF4
ADDRLP4 196
INDIRP4
CNSTI4 224
ADDP4
INDIRF4
ARGF4
ADDRLP4 200
ADDRGP4 CG_RandomiseValue
CALLF4
ASGNF4
ADDRLP4 0
INDIRP4
CNSTI4 16
ADDP4
ADDRLP4 200
INDIRF4
ASGNF4
line 179
;179:      p->bounceMarkCount =
ADDRLP4 204
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 204
INDIRP4
CNSTI4 228
ADDP4
INDIRF4
ARGF4
ADDRLP4 204
INDIRP4
CNSTI4 232
ADDP4
INDIRF4
ARGF4
ADDRLP4 208
ADDRGP4 CG_RandomiseValue
CALLF4
ASGNF4
ADDRLP4 208
INDIRF4
ARGF4
ADDRLP4 212
ADDRGP4 rint
CALLF4
ASGNF4
ADDRLP4 0
INDIRP4
CNSTI4 20
ADDP4
ADDRLP4 212
INDIRF4
CVFI4 4
ASGNI4
line 181
;180:        rint( CG_RandomiseValue( (float)bp->bounceMarkCount, bp->bounceMarkCountRandFrac ) );
;181:      p->bounceSoundCount =
ADDRLP4 216
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 216
INDIRP4
CNSTI4 304
ADDP4
INDIRF4
ARGF4
ADDRLP4 216
INDIRP4
CNSTI4 308
ADDP4
INDIRF4
ARGF4
ADDRLP4 220
ADDRGP4 CG_RandomiseValue
CALLF4
ASGNF4
ADDRLP4 220
INDIRF4
ARGF4
ADDRLP4 224
ADDRGP4 rint
CALLF4
ASGNF4
ADDRLP4 0
INDIRP4
CNSTI4 24
ADDP4
ADDRLP4 224
INDIRF4
CVFI4 4
ASGNI4
line 184
;182:        rint( CG_RandomiseValue( (float)bp->bounceSoundCount, bp->bounceSoundCountRandFrac ) );
;183:
;184:      if( bp->numModels )
ADDRFP4 0
INDIRP4
CNSTI4 3380
ADDP4
INDIRI4
CNSTI4 0
EQI4 $121
line 185
;185:      {
line 186
;186:        p->model = bp->models[ rand( ) % bp->numModels ];
ADDRLP4 228
ADDRGP4 rand
CALLI4
ASGNI4
ADDRLP4 232
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 0
INDIRP4
CNSTI4 236
ADDP4
ADDRLP4 228
INDIRI4
ADDRLP4 232
INDIRP4
CNSTI4 3380
ADDP4
INDIRI4
MODI4
CNSTI4 2
LSHI4
ADDRLP4 232
INDIRP4
CNSTI4 3348
ADDP4
ADDP4
INDIRI4
ASGNI4
line 188
;187:
;188:        if( bp->modelAnimation.frameLerp < 0 )
ADDRFP4 0
INDIRP4
CNSTI4 3396
ADDP4
INDIRI4
CNSTI4 0
GEI4 $123
line 189
;189:        {
line 190
;190:          bp->modelAnimation.frameLerp = p->lifeTime / bp->modelAnimation.numFrames;
ADDRLP4 236
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 236
INDIRP4
CNSTI4 3396
ADDP4
ADDRLP4 0
INDIRP4
CNSTI4 12
ADDP4
INDIRI4
ADDRLP4 236
INDIRP4
CNSTI4 3388
ADDP4
INDIRI4
DIVI4
ASGNI4
line 191
;191:          bp->modelAnimation.initialLerp = p->lifeTime / bp->modelAnimation.numFrames;
ADDRLP4 240
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 240
INDIRP4
CNSTI4 3400
ADDP4
ADDRLP4 0
INDIRP4
CNSTI4 12
ADDP4
INDIRI4
ADDRLP4 240
INDIRP4
CNSTI4 3388
ADDP4
INDIRI4
DIVI4
ASGNI4
line 192
;192:        }
LABELV $123
line 193
;193:      }
LABELV $121
line 195
;194:
;195:      if( !CG_AttachmentPoint( &ps->attachment, attachmentPoint ) )
ADDRLP4 12
INDIRP4
CNSTI4 4
ADDP4
ARGP4
ADDRLP4 28
ARGP4
ADDRLP4 228
ADDRGP4 CG_AttachmentPoint
CALLI4
ASGNI4
ADDRLP4 228
INDIRI4
CNSTI4 0
NEI4 $125
line 196
;196:        return NULL;
CNSTP4 0
RETP4
ADDRGP4 $113
JUMPV
LABELV $125
line 198
;197:
;198:      VectorCopy( attachmentPoint, p->origin );
ADDRLP4 0
INDIRP4
CNSTI4 32
ADDP4
ADDRLP4 28
INDIRB
ASGNB 12
line 200
;199:
;200:      if( CG_AttachmentAxis( &ps->attachment, transform ) )
ADDRLP4 12
INDIRP4
CNSTI4 4
ADDP4
ARGP4
ADDRLP4 40
ARGP4
ADDRLP4 232
ADDRGP4 CG_AttachmentAxis
CALLI4
ASGNI4
ADDRLP4 232
INDIRI4
CNSTI4 0
EQI4 $127
line 201
;201:      {
line 204
;202:        vec3_t  transDisplacement;
;203:
;204:        VectorMatrixMultiply( bp->displacement, transform, transDisplacement );
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 40
ARGP4
ADDRLP4 236
ARGP4
ADDRGP4 VectorMatrixMultiply
CALLV
pop
line 205
;205:        VectorAdd( p->origin, transDisplacement, p->origin );
ADDRLP4 248
ADDRLP4 0
INDIRP4
CNSTI4 32
ADDP4
ASGNP4
ADDRLP4 248
INDIRP4
ADDRLP4 248
INDIRP4
INDIRF4
ADDRLP4 236
INDIRF4
ADDF4
ASGNF4
ADDRLP4 252
ADDRLP4 0
INDIRP4
CNSTI4 36
ADDP4
ASGNP4
ADDRLP4 252
INDIRP4
ADDRLP4 252
INDIRP4
INDIRF4
ADDRLP4 236+4
INDIRF4
ADDF4
ASGNF4
ADDRLP4 256
ADDRLP4 0
INDIRP4
CNSTI4 40
ADDP4
ASGNP4
ADDRLP4 256
INDIRP4
ADDRLP4 256
INDIRP4
INDIRF4
ADDRLP4 236+8
INDIRF4
ADDF4
ASGNF4
line 206
;206:      }
ADDRGP4 $128
JUMPV
LABELV $127
line 208
;207:      else
;208:        VectorAdd( p->origin, bp->displacement, p->origin );
ADDRLP4 236
ADDRLP4 0
INDIRP4
CNSTI4 32
ADDP4
ASGNP4
ADDRLP4 236
INDIRP4
ADDRLP4 236
INDIRP4
INDIRF4
ADDRFP4 0
INDIRP4
INDIRF4
ADDF4
ASGNF4
ADDRLP4 240
ADDRLP4 0
INDIRP4
CNSTI4 36
ADDP4
ASGNP4
ADDRLP4 240
INDIRP4
ADDRLP4 240
INDIRP4
INDIRF4
ADDRFP4 0
INDIRP4
CNSTI4 4
ADDP4
INDIRF4
ADDF4
ASGNF4
ADDRLP4 244
ADDRLP4 0
INDIRP4
CNSTI4 40
ADDP4
ASGNP4
ADDRLP4 244
INDIRP4
ADDRLP4 244
INDIRP4
INDIRF4
ADDRFP4 0
INDIRP4
CNSTI4 8
ADDP4
INDIRF4
ADDF4
ASGNF4
LABELV $128
line 210
;209:
;210:      for( j = 0; j <= 2; j++ )
ADDRLP4 4
CNSTI4 0
ASGNI4
LABELV $131
line 211
;211:        p->origin[ j ] += ( crandom( ) * bp->randDisplacement );
ADDRLP4 248
ADDRGP4 rand
CALLI4
ASGNI4
ADDRLP4 252
ADDRLP4 4
INDIRI4
CNSTI4 2
LSHI4
ADDRLP4 0
INDIRP4
CNSTI4 32
ADDP4
ADDP4
ASGNP4
ADDRLP4 252
INDIRP4
ADDRLP4 252
INDIRP4
INDIRF4
CNSTF4 1073741824
ADDRLP4 248
INDIRI4
CNSTI4 32767
BANDI4
CVIF4 4
CNSTF4 1191181824
DIVF4
CNSTF4 1056964608
SUBF4
MULF4
ADDRFP4 0
INDIRP4
CNSTI4 12
ADDP4
INDIRF4
MULF4
ADDF4
ASGNF4
LABELV $132
line 210
ADDRLP4 4
ADDRLP4 4
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 2
LEI4 $131
line 213
;212:
;213:      switch( bp->velMoveType )
ADDRLP4 256
ADDRFP4 0
INDIRP4
CNSTI4 20
ADDP4
INDIRI4
ASGNI4
ADDRLP4 256
INDIRI4
CNSTI4 0
LTI4 $135
ADDRLP4 256
INDIRI4
CNSTI4 4
GTI4 $135
ADDRLP4 256
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 $165
ADDP4
INDIRP4
JUMPV
lit
align 4
LABELV $165
address $138
address $143
address $152
address $152
address $161
code
line 214
;214:      {
LABELV $138
line 216
;215:        case PMT_STATIC:
;216:          if( bp->velMoveValues.dirType == PMD_POINT )
ADDRFP4 0
INDIRP4
CNSTI4 24
ADDP4
INDIRI4
CNSTI4 1
NEI4 $139
line 217
;217:            VectorSubtract( bp->velMoveValues.point, p->origin, p->velocity );
ADDRLP4 268
CNSTI4 44
ASGNI4
ADDRLP4 0
INDIRP4
ADDRLP4 268
INDIRI4
ADDP4
ADDRFP4 0
INDIRP4
ADDRLP4 268
INDIRI4
ADDP4
INDIRF4
ADDRLP4 0
INDIRP4
CNSTI4 32
ADDP4
INDIRF4
SUBF4
ASGNF4
ADDRLP4 276
CNSTI4 48
ASGNI4
ADDRLP4 0
INDIRP4
ADDRLP4 276
INDIRI4
ADDP4
ADDRFP4 0
INDIRP4
ADDRLP4 276
INDIRI4
ADDP4
INDIRF4
ADDRLP4 0
INDIRP4
CNSTI4 36
ADDP4
INDIRF4
SUBF4
ASGNF4
ADDRLP4 284
CNSTI4 52
ASGNI4
ADDRLP4 0
INDIRP4
ADDRLP4 284
INDIRI4
ADDP4
ADDRFP4 0
INDIRP4
ADDRLP4 284
INDIRI4
ADDP4
INDIRF4
ADDRLP4 0
INDIRP4
CNSTI4 40
ADDP4
INDIRF4
SUBF4
ASGNF4
ADDRGP4 $136
JUMPV
LABELV $139
line 218
;218:          else if( bp->velMoveValues.dirType == PMD_LINEAR )
ADDRFP4 0
INDIRP4
CNSTI4 24
ADDP4
INDIRI4
CNSTI4 0
NEI4 $136
line 219
;219:            VectorCopy( bp->velMoveValues.dir, p->velocity );
ADDRLP4 0
INDIRP4
CNSTI4 44
ADDP4
ADDRFP4 0
INDIRP4
CNSTI4 28
ADDP4
INDIRB
ASGNB 12
line 220
;220:          break;
ADDRGP4 $136
JUMPV
LABELV $143
line 223
;221:
;222:        case PMT_STATIC_TRANSFORM:
;223:          if( !CG_AttachmentAxis( &ps->attachment, transform ) )
ADDRLP4 12
INDIRP4
CNSTI4 4
ADDP4
ARGP4
ADDRLP4 40
ARGP4
ADDRLP4 288
ADDRGP4 CG_AttachmentAxis
CALLI4
ASGNI4
ADDRLP4 288
INDIRI4
CNSTI4 0
NEI4 $144
line 224
;224:            return NULL;
CNSTP4 0
RETP4
ADDRGP4 $113
JUMPV
LABELV $144
line 226
;225:
;226:          if( bp->velMoveValues.dirType == PMD_POINT )
ADDRFP4 0
INDIRP4
CNSTI4 24
ADDP4
INDIRI4
CNSTI4 1
NEI4 $146
line 227
;227:          {
line 230
;228:            vec3_t transPoint;
;229:
;230:            VectorMatrixMultiply( bp->velMoveValues.point, transform, transPoint );
ADDRFP4 0
INDIRP4
CNSTI4 44
ADDP4
ARGP4
ADDRLP4 40
ARGP4
ADDRLP4 292
ARGP4
ADDRGP4 VectorMatrixMultiply
CALLV
pop
line 231
;231:            VectorSubtract( transPoint, p->origin, p->velocity );
ADDRLP4 0
INDIRP4
CNSTI4 44
ADDP4
ADDRLP4 292
INDIRF4
ADDRLP4 0
INDIRP4
CNSTI4 32
ADDP4
INDIRF4
SUBF4
ASGNF4
ADDRLP4 0
INDIRP4
CNSTI4 48
ADDP4
ADDRLP4 292+4
INDIRF4
ADDRLP4 0
INDIRP4
CNSTI4 36
ADDP4
INDIRF4
SUBF4
ASGNF4
ADDRLP4 0
INDIRP4
CNSTI4 52
ADDP4
ADDRLP4 292+8
INDIRF4
ADDRLP4 0
INDIRP4
CNSTI4 40
ADDP4
INDIRF4
SUBF4
ASGNF4
line 232
;232:          }
ADDRGP4 $136
JUMPV
LABELV $146
line 233
;233:          else if( bp->velMoveValues.dirType == PMD_LINEAR )
ADDRFP4 0
INDIRP4
CNSTI4 24
ADDP4
INDIRI4
CNSTI4 0
NEI4 $136
line 234
;234:            VectorMatrixMultiply( bp->velMoveValues.dir, transform, p->velocity );
ADDRFP4 0
INDIRP4
CNSTI4 28
ADDP4
ARGP4
ADDRLP4 40
ARGP4
ADDRLP4 0
INDIRP4
CNSTI4 44
ADDP4
ARGP4
ADDRGP4 VectorMatrixMultiply
CALLV
pop
line 235
;235:          break;
ADDRGP4 $136
JUMPV
LABELV $152
line 239
;236:
;237:        case PMT_TAG:
;238:        case PMT_CENT_ANGLES:
;239:          if( bp->velMoveValues.dirType == PMD_POINT )
ADDRFP4 0
INDIRP4
CNSTI4 24
ADDP4
INDIRI4
CNSTI4 1
NEI4 $153
line 240
;240:            VectorSubtract( attachmentPoint, p->origin, p->velocity );
ADDRLP4 0
INDIRP4
CNSTI4 44
ADDP4
ADDRLP4 28
INDIRF4
ADDRLP4 0
INDIRP4
CNSTI4 32
ADDP4
INDIRF4
SUBF4
ASGNF4
ADDRLP4 0
INDIRP4
CNSTI4 48
ADDP4
ADDRLP4 28+4
INDIRF4
ADDRLP4 0
INDIRP4
CNSTI4 36
ADDP4
INDIRF4
SUBF4
ASGNF4
ADDRLP4 0
INDIRP4
CNSTI4 52
ADDP4
ADDRLP4 28+8
INDIRF4
ADDRLP4 0
INDIRP4
CNSTI4 40
ADDP4
INDIRF4
SUBF4
ASGNF4
ADDRGP4 $136
JUMPV
LABELV $153
line 241
;241:          else if( bp->velMoveValues.dirType == PMD_LINEAR )
ADDRFP4 0
INDIRP4
CNSTI4 24
ADDP4
INDIRI4
CNSTI4 0
NEI4 $136
line 242
;242:          {
line 243
;243:            if( !CG_AttachmentDir( &ps->attachment, p->velocity ) )
ADDRLP4 12
INDIRP4
CNSTI4 4
ADDP4
ARGP4
ADDRLP4 0
INDIRP4
CNSTI4 44
ADDP4
ARGP4
ADDRLP4 304
ADDRGP4 CG_AttachmentDir
CALLI4
ASGNI4
ADDRLP4 304
INDIRI4
CNSTI4 0
NEI4 $136
line 244
;244:              return NULL;
CNSTP4 0
RETP4
ADDRGP4 $113
JUMPV
line 245
;245:          }
line 246
;246:          break;
LABELV $161
line 249
;247:
;248:        case PMT_NORMAL:
;249:          if( !ps->normalValid )
ADDRLP4 12
INDIRP4
CNSTI4 1392
ADDP4
INDIRI4
CNSTI4 0
NEI4 $162
line 250
;250:          {
line 251
;251:            CG_Printf( S_COLOR_RED "ERROR: a particle with velocityType "
ADDRGP4 $164
ARGP4
ADDRGP4 CG_Printf
CALLV
pop
line 253
;252:                "normal has no normal\n" );
;253:            return NULL;
CNSTP4 0
RETP4
ADDRGP4 $113
JUMPV
LABELV $162
line 256
;254:          }
;255:
;256:          VectorCopy( ps->normal, p->velocity );
ADDRLP4 0
INDIRP4
CNSTI4 44
ADDP4
ADDRLP4 12
INDIRP4
CNSTI4 1396
ADDP4
INDIRB
ASGNB 12
line 259
;257:
;258:          //normal displacement
;259:          VectorNormalize( p->velocity );
ADDRLP4 0
INDIRP4
CNSTI4 44
ADDP4
ARGP4
ADDRGP4 VectorNormalize
CALLF4
pop
line 260
;260:          VectorMA( p->origin, bp->normalDisplacement, p->velocity, p->origin );
ADDRLP4 308
ADDRLP4 0
INDIRP4
CNSTI4 32
ADDP4
ASGNP4
ADDRLP4 308
INDIRP4
ADDRLP4 308
INDIRP4
INDIRF4
ADDRLP4 0
INDIRP4
CNSTI4 44
ADDP4
INDIRF4
ADDRFP4 0
INDIRP4
CNSTI4 16
ADDP4
INDIRF4
MULF4
ADDF4
ASGNF4
ADDRLP4 316
ADDRLP4 0
INDIRP4
CNSTI4 36
ADDP4
ASGNP4
ADDRLP4 316
INDIRP4
ADDRLP4 316
INDIRP4
INDIRF4
ADDRLP4 0
INDIRP4
CNSTI4 48
ADDP4
INDIRF4
ADDRFP4 0
INDIRP4
CNSTI4 16
ADDP4
INDIRF4
MULF4
ADDF4
ASGNF4
ADDRLP4 324
ADDRLP4 0
INDIRP4
CNSTI4 40
ADDP4
ASGNP4
ADDRLP4 324
INDIRP4
ADDRLP4 324
INDIRP4
INDIRF4
ADDRLP4 0
INDIRP4
CNSTI4 52
ADDP4
INDIRF4
ADDRFP4 0
INDIRP4
CNSTI4 16
ADDP4
INDIRF4
MULF4
ADDF4
ASGNF4
line 261
;261:          break;
LABELV $135
LABELV $136
line 264
;262:      }
;263:
;264:      VectorNormalize( p->velocity );
ADDRLP4 0
INDIRP4
CNSTI4 44
ADDP4
ARGP4
ADDRGP4 VectorNormalize
CALLF4
pop
line 265
;265:      CG_SpreadVector( p->velocity, bp->velMoveValues.dirRandAngle );
ADDRLP4 0
INDIRP4
CNSTI4 44
ADDP4
ARGP4
ADDRFP4 0
INDIRP4
CNSTI4 40
ADDP4
INDIRF4
ARGF4
ADDRGP4 CG_SpreadVector
CALLV
pop
line 266
;266:      VectorScale( p->velocity,
ADDRLP4 264
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 264
INDIRP4
CNSTI4 60
ADDP4
INDIRF4
ARGF4
ADDRLP4 264
INDIRP4
CNSTI4 64
ADDP4
INDIRF4
ARGF4
ADDRLP4 268
ADDRGP4 CG_RandomiseValue
CALLF4
ASGNF4
ADDRLP4 272
ADDRLP4 0
INDIRP4
CNSTI4 44
ADDP4
ASGNP4
ADDRLP4 272
INDIRP4
ADDRLP4 272
INDIRP4
INDIRF4
ADDRLP4 268
INDIRF4
MULF4
ASGNF4
ADDRLP4 276
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 276
INDIRP4
CNSTI4 60
ADDP4
INDIRF4
ARGF4
ADDRLP4 276
INDIRP4
CNSTI4 64
ADDP4
INDIRF4
ARGF4
ADDRLP4 280
ADDRGP4 CG_RandomiseValue
CALLF4
ASGNF4
ADDRLP4 284
ADDRLP4 0
INDIRP4
CNSTI4 48
ADDP4
ASGNP4
ADDRLP4 284
INDIRP4
ADDRLP4 284
INDIRP4
INDIRF4
ADDRLP4 280
INDIRF4
MULF4
ASGNF4
ADDRLP4 288
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 288
INDIRP4
CNSTI4 60
ADDP4
INDIRF4
ARGF4
ADDRLP4 288
INDIRP4
CNSTI4 64
ADDP4
INDIRF4
ARGF4
ADDRLP4 292
ADDRGP4 CG_RandomiseValue
CALLF4
ASGNF4
ADDRLP4 296
ADDRLP4 0
INDIRP4
CNSTI4 52
ADDP4
ASGNP4
ADDRLP4 296
INDIRP4
ADDRLP4 296
INDIRP4
INDIRF4
ADDRLP4 292
INDIRF4
MULF4
ASGNF4
line 270
;267:                   CG_RandomiseValue( bp->velMoveValues.mag, bp->velMoveValues.magRandFrac ),
;268:                   p->velocity );
;269:
;270:      if( CG_AttachmentVelocity( &ps->attachment, attachmentVelocity ) )
ADDRLP4 12
INDIRP4
CNSTI4 4
ADDP4
ARGP4
ADDRLP4 16
ARGP4
ADDRLP4 300
ADDRGP4 CG_AttachmentVelocity
CALLI4
ASGNI4
ADDRLP4 300
INDIRI4
CNSTI4 0
EQI4 $166
line 271
;271:      {
line 272
;272:        VectorMA( p->velocity,
ADDRLP4 304
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 304
INDIRP4
CNSTI4 68
ADDP4
INDIRF4
ARGF4
ADDRLP4 304
INDIRP4
CNSTI4 72
ADDP4
INDIRF4
ARGF4
ADDRLP4 308
ADDRGP4 CG_RandomiseValue
CALLF4
ASGNF4
ADDRLP4 312
ADDRLP4 0
INDIRP4
CNSTI4 44
ADDP4
ASGNP4
ADDRLP4 312
INDIRP4
ADDRLP4 312
INDIRP4
INDIRF4
ADDRLP4 16
INDIRF4
ADDRLP4 308
INDIRF4
MULF4
ADDF4
ASGNF4
ADDRLP4 316
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 316
INDIRP4
CNSTI4 68
ADDP4
INDIRF4
ARGF4
ADDRLP4 316
INDIRP4
CNSTI4 72
ADDP4
INDIRF4
ARGF4
ADDRLP4 320
ADDRGP4 CG_RandomiseValue
CALLF4
ASGNF4
ADDRLP4 324
ADDRLP4 0
INDIRP4
CNSTI4 48
ADDP4
ASGNP4
ADDRLP4 324
INDIRP4
ADDRLP4 324
INDIRP4
INDIRF4
ADDRLP4 16+4
INDIRF4
ADDRLP4 320
INDIRF4
MULF4
ADDF4
ASGNF4
ADDRLP4 328
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 328
INDIRP4
CNSTI4 68
ADDP4
INDIRF4
ARGF4
ADDRLP4 328
INDIRP4
CNSTI4 72
ADDP4
INDIRF4
ARGF4
ADDRLP4 332
ADDRGP4 CG_RandomiseValue
CALLF4
ASGNF4
ADDRLP4 336
ADDRLP4 0
INDIRP4
CNSTI4 52
ADDP4
ASGNP4
ADDRLP4 336
INDIRP4
ADDRLP4 336
INDIRP4
INDIRF4
ADDRLP4 16+8
INDIRF4
ADDRLP4 332
INDIRF4
MULF4
ADDF4
ASGNF4
line 275
;273:            CG_RandomiseValue( bp->velMoveValues.parentVelFrac,
;274:              bp->velMoveValues.parentVelFracRandFrac ), attachmentVelocity, p->velocity );
;275:      }
LABELV $166
line 277
;276:
;277:      p->lastEvalTime = cg.time;
ADDRLP4 0
INDIRP4
CNSTI4 112
ADDP4
ADDRGP4 cg+107604
INDIRI4
ASGNI4
line 279
;278:
;279:      p->valid = qtrue;
ADDRLP4 0
INDIRP4
CNSTI4 324
ADDP4
CNSTI4 1
ASGNI4
line 282
;280:
;281:      //this particle has a child particle system attached
;282:      if( bp->childSystemName[ 0 ] != '\0' )
ADDRFP4 0
INDIRP4
CNSTI4 446
ADDP4
INDIRI1
CVII4 1
CNSTI4 0
EQI4 $171
line 283
;283:      {
line 284
;284:        particleSystem_t  *ps = CG_SpawnNewParticleSystem( bp->childSystemHandle );
ADDRFP4 0
INDIRP4
CNSTI4 512
ADDP4
INDIRI4
ARGI4
ADDRLP4 308
ADDRGP4 CG_SpawnNewParticleSystem
CALLP4
ASGNP4
ADDRLP4 304
ADDRLP4 308
INDIRP4
ASGNP4
line 286
;285:
;286:        if( CG_IsParticleSystemValid( &ps ) )
ADDRLP4 304
ARGP4
ADDRLP4 312
ADDRGP4 CG_IsParticleSystemValid
CALLI4
ASGNI4
ADDRLP4 312
INDIRI4
CNSTI4 0
EQI4 $173
line 287
;287:        {
line 288
;288:          CG_SetAttachmentParticle( &ps->attachment, p );
ADDRLP4 304
INDIRP4
CNSTI4 4
ADDP4
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 CG_SetAttachmentParticle
CALLV
pop
line 289
;289:          CG_AttachToParticle( &ps->attachment );
ADDRLP4 304
INDIRP4
CNSTI4 4
ADDP4
ARGP4
ADDRGP4 CG_AttachToParticle
CALLV
pop
line 290
;290:        }
LABELV $173
line 291
;291:      }
LABELV $171
line 294
;292:
;293:      //this particle has a child trail system attached
;294:      if( bp->childTrailSystemName[ 0 ] != '\0' )
ADDRFP4 0
INDIRP4
CNSTI4 584
ADDP4
INDIRI1
CVII4 1
CNSTI4 0
EQI4 $116
line 295
;295:      {
line 296
;296:        trailSystem_t *ts = CG_SpawnNewTrailSystem( bp->childTrailSystemHandle );
ADDRFP4 0
INDIRP4
CNSTI4 648
ADDP4
INDIRI4
ARGI4
ADDRLP4 308
ADDRGP4 CG_SpawnNewTrailSystem
CALLP4
ASGNP4
ADDRLP4 304
ADDRLP4 308
INDIRP4
ASGNP4
line 298
;297:
;298:        if( CG_IsTrailSystemValid( &ts ) )
ADDRLP4 304
ARGP4
ADDRLP4 312
ADDRGP4 CG_IsTrailSystemValid
CALLI4
ASGNI4
ADDRLP4 312
INDIRI4
CNSTI4 0
EQI4 $116
line 299
;299:        {
line 300
;300:          CG_SetAttachmentParticle( &ts->frontAttachment, p );
ADDRLP4 304
INDIRP4
CNSTI4 4
ADDP4
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 CG_SetAttachmentParticle
CALLV
pop
line 301
;301:          CG_AttachToParticle( &ts->frontAttachment );
ADDRLP4 304
INDIRP4
CNSTI4 4
ADDP4
ARGP4
ADDRGP4 CG_AttachToParticle
CALLV
pop
line 302
;302:        }
line 303
;303:      }
line 305
;304:
;305:      break;
ADDRGP4 $116
JUMPV
LABELV $118
line 307
;306:    }
;307:  }
LABELV $115
line 141
ADDRLP4 8
ADDRLP4 8
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 960
LTI4 $114
LABELV $116
line 309
;308:
;309:  return p;
ADDRLP4 0
INDIRP4
RETP4
LABELV $113
endproc CG_SpawnNewParticle 340 12
proc CG_SpawnNewParticles 56 12
line 322
;310:}
;311:
;312:
;313:/*
;314:===============
;315:CG_SpawnNewParticles
;316:
;317:Check if there are any ejectors that should be
;318:introducing new particles
;319:===============
;320:*/
;321:static void CG_SpawnNewParticles( void )
;322:{
line 331
;323:  int                   i, j;
;324:  particle_t            *p;
;325:  particleSystem_t      *ps;
;326:  particleEjector_t     *pe;
;327:  baseParticleEjector_t *bpe;
;328:  float                 lerpFrac;
;329:  int                   count;
;330:
;331:  for( i = 0; i < MAX_PARTICLE_EJECTORS; i++ )
ADDRLP4 20
CNSTI4 0
ASGNI4
LABELV $180
line 332
;332:  {
line 333
;333:    pe = &particleEjectors[ i ];
ADDRLP4 4
CNSTI4 52
ADDRLP4 20
INDIRI4
MULI4
ADDRGP4 particleEjectors
ADDP4
ASGNP4
line 334
;334:    ps = pe->parent;
ADDRLP4 24
ADDRLP4 4
INDIRP4
CNSTI4 4
ADDP4
INDIRP4
ASGNP4
line 336
;335:
;336:    if( pe->valid )
ADDRLP4 4
INDIRP4
CNSTI4 48
ADDP4
INDIRI4
CNSTI4 0
EQI4 $184
line 337
;337:    {
line 339
;338:      //a non attached particle system can't make particles
;339:      if( !CG_Attached( &ps->attachment ) )
ADDRLP4 24
INDIRP4
CNSTI4 4
ADDP4
ARGP4
ADDRLP4 32
ADDRGP4 CG_Attached
CALLI4
ASGNI4
ADDRLP4 32
INDIRI4
CNSTI4 0
NEI4 $186
line 340
;340:        continue;
ADDRGP4 $181
JUMPV
LABELV $186
line 342
;341:
;342:      bpe = particleEjectors[ i ].class;
ADDRLP4 8
CNSTI4 52
ADDRLP4 20
INDIRI4
MULI4
ADDRGP4 particleEjectors
ADDP4
INDIRP4
ASGNP4
line 345
;343:
;344:      //if this system is scheduled for removal don't make any new particles
;345:      if( !ps->lazyRemove )
ADDRLP4 24
INDIRP4
CNSTI4 1388
ADDP4
INDIRI4
CNSTI4 0
NEI4 $188
line 346
;346:      {
ADDRGP4 $191
JUMPV
LABELV $190
line 349
;347:        while( pe->nextEjectionTime <= cg.time &&
;348:               ( pe->count > 0 || pe->totalParticles == PARTICLES_INFINITE ) )
;349:        {
line 350
;350:          for( j = 0; j < bpe->numParticles; j++ )
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $197
JUMPV
LABELV $194
line 351
;351:            CG_SpawnNewParticle( bpe->particles[ j ], pe );
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRLP4 8
INDIRP4
ADDP4
INDIRP4
ARGP4
ADDRLP4 4
INDIRP4
ARGP4
ADDRGP4 CG_SpawnNewParticle
CALLP4
pop
LABELV $195
line 350
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $197
ADDRLP4 0
INDIRI4
ADDRLP4 8
INDIRP4
CNSTI4 16
ADDP4
INDIRI4
LTI4 $194
line 353
;352:
;353:          if( pe->count > 0 )
ADDRLP4 4
INDIRP4
CNSTI4 36
ADDP4
INDIRI4
CNSTI4 0
LEI4 $198
line 354
;354:            pe->count--;
ADDRLP4 36
ADDRLP4 4
INDIRP4
CNSTI4 36
ADDP4
ASGNP4
ADDRLP4 36
INDIRP4
ADDRLP4 36
INDIRP4
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
LABELV $198
line 357
;355:
;356:          //calculate next ejection time
;357:          lerpFrac = 1.0 - ( (float)pe->count / (float)pe->totalParticles );
ADDRLP4 16
CNSTF4 1065353216
ADDRLP4 4
INDIRP4
CNSTI4 36
ADDP4
INDIRI4
CVIF4 4
ADDRLP4 4
INDIRP4
CNSTI4 40
ADDP4
INDIRI4
CVIF4 4
DIVF4
SUBF4
ASGNF4
line 358
;358:          pe->nextEjectionTime = cg.time + (int)CG_RandomiseValue(
ADDRLP4 4
INDIRP4
CNSTI4 16
ADDP4
INDIRF4
ARGF4
ADDRLP4 4
INDIRP4
CNSTI4 24
ADDP4
INDIRF4
ARGF4
ADDRLP4 16
INDIRF4
ARGF4
ADDRLP4 48
ADDRGP4 CG_LerpValues
CALLF4
ASGNF4
ADDRLP4 48
INDIRF4
ARGF4
ADDRLP4 4
INDIRP4
CNSTI4 32
ADDP4
INDIRF4
ARGF4
ADDRLP4 52
ADDRGP4 CG_RandomiseValue
CALLF4
ASGNF4
ADDRLP4 4
INDIRP4
CNSTI4 44
ADDP4
ADDRGP4 cg+107604
INDIRI4
ADDRLP4 52
INDIRF4
CVFI4 4
ADDI4
ASGNI4
line 363
;359:              CG_LerpValues( pe->ejectPeriod.initial,
;360:                             pe->ejectPeriod.final,
;361:                             lerpFrac ),
;362:              pe->ejectPeriod.randFrac );
;363:        }
LABELV $191
line 347
ADDRLP4 4
INDIRP4
CNSTI4 44
ADDP4
INDIRI4
ADDRGP4 cg+107604
INDIRI4
GTI4 $201
ADDRLP4 4
INDIRP4
CNSTI4 36
ADDP4
INDIRI4
CNSTI4 0
GTI4 $190
ADDRLP4 4
INDIRP4
CNSTI4 40
ADDP4
INDIRI4
CNSTI4 -1
EQI4 $190
LABELV $201
line 364
;364:      }
LABELV $188
line 366
;365:
;366:      if( pe->count == 0 || ps->lazyRemove )
ADDRLP4 36
CNSTI4 0
ASGNI4
ADDRLP4 4
INDIRP4
CNSTI4 36
ADDP4
INDIRI4
ADDRLP4 36
INDIRI4
EQI4 $204
ADDRLP4 24
INDIRP4
CNSTI4 1388
ADDP4
INDIRI4
ADDRLP4 36
INDIRI4
EQI4 $202
LABELV $204
line 367
;367:      {
line 368
;368:        count = 0;
ADDRLP4 28
CNSTI4 0
ASGNI4
line 371
;369:
;370:        //wait for child particles to die before declaring this pe invalid
;371:        for( j = 0; j < MAX_PARTICLES; j++ )
ADDRLP4 0
CNSTI4 0
ASGNI4
LABELV $205
line 372
;372:        {
line 373
;373:          p = &particles[ j ];
ADDRLP4 12
CNSTI4 336
ADDRLP4 0
INDIRI4
MULI4
ADDRGP4 particles
ADDP4
ASGNP4
line 375
;374:
;375:          if( p->valid && p->parent == pe )
ADDRLP4 12
INDIRP4
CNSTI4 324
ADDP4
INDIRI4
CNSTI4 0
EQI4 $209
ADDRLP4 12
INDIRP4
CNSTI4 4
ADDP4
INDIRP4
CVPU4 4
ADDRLP4 4
INDIRP4
CVPU4 4
NEU4 $209
line 376
;376:            count++;
ADDRLP4 28
ADDRLP4 28
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $209
line 377
;377:        }
LABELV $206
line 371
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 960
LTI4 $205
line 379
;378:
;379:        if( !count )
ADDRLP4 28
INDIRI4
CNSTI4 0
NEI4 $211
line 380
;380:          pe->valid = qfalse;
ADDRLP4 4
INDIRP4
CNSTI4 48
ADDP4
CNSTI4 0
ASGNI4
LABELV $211
line 381
;381:      }
LABELV $202
line 382
;382:    }
LABELV $184
line 383
;383:  }
LABELV $181
line 331
ADDRLP4 20
ADDRLP4 20
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 20
INDIRI4
CNSTI4 192
LTI4 $180
line 384
;384:}
LABELV $179
endproc CG_SpawnNewParticles 56 12
proc CG_SpawnNewParticleEjector 40 12
line 396
;385:
;386:
;387:/*
;388:===============
;389:CG_SpawnNewParticleEjector
;390:
;391:Allocate a new particle ejector
;392:===============
;393:*/
;394:static particleEjector_t *CG_SpawnNewParticleEjector( baseParticleEjector_t *bpe,
;395:                                                      particleSystem_t *parent )
;396:{
line 398
;397:  int                     i;
;398:  particleEjector_t       *pe = NULL;
ADDRLP4 0
CNSTP4 0
ASGNP4
line 399
;399:  particleSystem_t        *ps = parent;
ADDRLP4 8
ADDRFP4 4
INDIRP4
ASGNP4
line 401
;400:
;401:  for( i = 0; i < MAX_PARTICLE_EJECTORS; i++ )
ADDRLP4 4
CNSTI4 0
ASGNI4
LABELV $214
line 402
;402:  {
line 403
;403:    pe = &particleEjectors[ i ];
ADDRLP4 0
CNSTI4 52
ADDRLP4 4
INDIRI4
MULI4
ADDRGP4 particleEjectors
ADDP4
ASGNP4
line 405
;404:
;405:    if( !pe->valid )
ADDRLP4 0
INDIRP4
CNSTI4 48
ADDP4
INDIRI4
CNSTI4 0
NEI4 $218
line 406
;406:    {
line 407
;407:      memset( pe, 0, sizeof( particleEjector_t ) );
ADDRLP4 0
INDIRP4
ARGP4
CNSTI4 0
ARGI4
CNSTI4 52
ARGI4
ADDRGP4 memset
CALLP4
pop
line 410
;408:
;409:      //found a free slot
;410:      pe->class = bpe;
ADDRLP4 0
INDIRP4
ADDRFP4 0
INDIRP4
ASGNP4
line 411
;411:      pe->parent = ps;
ADDRLP4 0
INDIRP4
CNSTI4 4
ADDP4
ADDRLP4 8
INDIRP4
ASGNP4
line 413
;412:
;413:      pe->ejectPeriod.initial = bpe->eject.initial;
ADDRLP4 0
INDIRP4
CNSTI4 16
ADDP4
ADDRFP4 0
INDIRP4
CNSTI4 28
ADDP4
INDIRF4
ASGNF4
line 414
;414:      pe->ejectPeriod.final = bpe->eject.final;
ADDRLP4 0
INDIRP4
CNSTI4 24
ADDP4
ADDRFP4 0
INDIRP4
CNSTI4 36
ADDP4
INDIRF4
ASGNF4
line 415
;415:      pe->ejectPeriod.randFrac = bpe->eject.randFrac;
ADDRLP4 0
INDIRP4
CNSTI4 32
ADDP4
ADDRFP4 0
INDIRP4
CNSTI4 44
ADDP4
INDIRF4
ASGNF4
line 417
;416:
;417:      pe->nextEjectionTime = cg.time +
ADDRLP4 12
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 12
INDIRP4
CNSTI4 20
ADDP4
INDIRI4
CVIF4 4
ARGF4
ADDRLP4 12
INDIRP4
CNSTI4 24
ADDP4
INDIRF4
ARGF4
ADDRLP4 16
ADDRGP4 CG_RandomiseValue
CALLF4
ASGNF4
ADDRLP4 0
INDIRP4
CNSTI4 44
ADDP4
ADDRGP4 cg+107604
INDIRI4
ADDRLP4 16
INDIRF4
CVFI4 4
ADDI4
ASGNI4
line 419
;418:        (int)CG_RandomiseValue( (float)bpe->eject.delay, bpe->eject.delayRandFrac );
;419:      pe->count = pe->totalParticles =
ADDRLP4 20
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 20
INDIRP4
CNSTI4 48
ADDP4
INDIRI4
CVIF4 4
ARGF4
ADDRLP4 20
INDIRP4
CNSTI4 52
ADDP4
INDIRF4
ARGF4
ADDRLP4 24
ADDRGP4 CG_RandomiseValue
CALLF4
ASGNF4
ADDRLP4 24
INDIRF4
ARGF4
ADDRLP4 28
ADDRGP4 rint
CALLF4
ASGNF4
ADDRLP4 36
ADDRLP4 28
INDIRF4
CVFI4 4
ASGNI4
ADDRLP4 0
INDIRP4
CNSTI4 40
ADDP4
ADDRLP4 36
INDIRI4
ASGNI4
ADDRLP4 0
INDIRP4
CNSTI4 36
ADDP4
ADDRLP4 36
INDIRI4
ASGNI4
line 422
;420:        (int)rint( CG_RandomiseValue( (float)bpe->totalParticles, bpe->totalParticlesRandFrac ) );
;421:
;422:      pe->valid = qtrue;
ADDRLP4 0
INDIRP4
CNSTI4 48
ADDP4
CNSTI4 1
ASGNI4
line 424
;423:
;424:      if( cg_debugParticles.integer >= 1 )
ADDRGP4 cg_debugParticles+12
INDIRI4
CNSTI4 1
LTI4 $216
line 425
;425:        CG_Printf( "PE %s created\n", ps->class->name );
ADDRGP4 $224
ARGP4
ADDRLP4 8
INDIRP4
INDIRP4
ARGP4
ADDRGP4 CG_Printf
CALLV
pop
line 427
;426:
;427:      break;
ADDRGP4 $216
JUMPV
LABELV $218
line 429
;428:    }
;429:  }
LABELV $215
line 401
ADDRLP4 4
ADDRLP4 4
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 192
LTI4 $214
LABELV $216
line 431
;430:
;431:  return pe;
ADDRLP4 0
INDIRP4
RETP4
LABELV $213
endproc CG_SpawnNewParticleEjector 40 12
export CG_SpawnNewParticleSystem
proc CG_SpawnNewParticleSystem 16 12
line 443
;432:}
;433:
;434:
;435:/*
;436:===============
;437:CG_SpawnNewParticleSystem
;438:
;439:Allocate a new particle system
;440:===============
;441:*/
;442:particleSystem_t *CG_SpawnNewParticleSystem( qhandle_t psHandle )
;443:{
line 445
;444:  int                   i, j;
;445:  particleSystem_t      *ps = NULL;
ADDRLP4 8
CNSTP4 0
ASGNP4
line 446
;446:  baseParticleSystem_t  *bps = &baseParticleSystems[ psHandle - 1 ];
ADDRLP4 4
CNSTI4 92
ADDRFP4 0
INDIRI4
MULI4
ADDRGP4 baseParticleSystems-92
ADDP4
ASGNP4
line 448
;447:
;448:  if( !bps->registered )
ADDRLP4 4
INDIRP4
CNSTI4 88
ADDP4
INDIRI4
CNSTI4 0
NEI4 $227
line 449
;449:  {
line 450
;450:    CG_Printf( S_COLOR_RED "ERROR: a particle system has not been registered yet\n" );
ADDRGP4 $229
ARGP4
ADDRGP4 CG_Printf
CALLV
pop
line 451
;451:    return NULL;
CNSTP4 0
RETP4
ADDRGP4 $225
JUMPV
LABELV $227
line 454
;452:  }
;453:
;454:  for( i = 0; i < MAX_PARTICLE_SYSTEMS; i++ )
ADDRLP4 12
CNSTI4 0
ASGNI4
LABELV $230
line 455
;455:  {
line 456
;456:    ps = &particleSystems[ i ];
ADDRLP4 8
CNSTI4 1408
ADDRLP4 12
INDIRI4
MULI4
ADDRGP4 particleSystems
ADDP4
ASGNP4
line 458
;457:
;458:    if( !ps->valid )
ADDRLP4 8
INDIRP4
CNSTI4 1384
ADDP4
INDIRI4
CNSTI4 0
NEI4 $234
line 459
;459:    {
line 460
;460:      memset( ps, 0, sizeof( particleSystem_t ) );
ADDRLP4 8
INDIRP4
ARGP4
CNSTI4 0
ARGI4
CNSTI4 1408
ARGI4
ADDRGP4 memset
CALLP4
pop
line 463
;461:
;462:      //found a free slot
;463:      ps->class = bps;
ADDRLP4 8
INDIRP4
ADDRLP4 4
INDIRP4
ASGNP4
line 465
;464:
;465:      ps->valid = qtrue;
ADDRLP4 8
INDIRP4
CNSTI4 1384
ADDP4
CNSTI4 1
ASGNI4
line 466
;466:      ps->lazyRemove = qfalse;
ADDRLP4 8
INDIRP4
CNSTI4 1388
ADDP4
CNSTI4 0
ASGNI4
line 468
;467:
;468:      for( j = 0; j < bps->numEjectors; j++ )
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $239
JUMPV
LABELV $236
line 469
;469:        CG_SpawnNewParticleEjector( bps->ejectors[ j ], ps );
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRLP4 4
INDIRP4
CNSTI4 64
ADDP4
ADDP4
INDIRP4
ARGP4
ADDRLP4 8
INDIRP4
ARGP4
ADDRGP4 CG_SpawnNewParticleEjector
CALLP4
pop
LABELV $237
line 468
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $239
ADDRLP4 0
INDIRI4
ADDRLP4 4
INDIRP4
CNSTI4 80
ADDP4
INDIRI4
LTI4 $236
line 471
;470:
;471:      if( cg_debugParticles.integer >= 1 )
ADDRGP4 cg_debugParticles+12
INDIRI4
CNSTI4 1
LTI4 $232
line 472
;472:        CG_Printf( "PS %s created\n", bps->name );
ADDRGP4 $243
ARGP4
ADDRLP4 4
INDIRP4
ARGP4
ADDRGP4 CG_Printf
CALLV
pop
line 474
;473:
;474:      break;
ADDRGP4 $232
JUMPV
LABELV $234
line 476
;475:    }
;476:  }
LABELV $231
line 454
ADDRLP4 12
ADDRLP4 12
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 48
LTI4 $230
LABELV $232
line 478
;477:
;478:  return ps;
ADDRLP4 8
INDIRP4
RETP4
LABELV $225
endproc CG_SpawnNewParticleSystem 16 12
export CG_RegisterParticleSystem
proc CG_RegisterParticleSystem 80 12
line 489
;479:}
;480:
;481:/*
;482:===============
;483:CG_RegisterParticleSystem
;484:
;485:Load the shaders required for a particle system
;486:===============
;487:*/
;488:qhandle_t CG_RegisterParticleSystem( char *name )
;489:{
line 495
;490:  int                   i, j, k, l;
;491:  baseParticleSystem_t  *bps;
;492:  baseParticleEjector_t *bpe;
;493:  baseParticle_t        *bp;
;494:
;495:  for( i = 0; i < MAX_BASEPARTICLE_SYSTEMS; i++ )
ADDRLP4 24
CNSTI4 0
ASGNI4
LABELV $245
line 496
;496:  {
line 497
;497:    bps = &baseParticleSystems[ i ];
ADDRLP4 20
CNSTI4 92
ADDRLP4 24
INDIRI4
MULI4
ADDRGP4 baseParticleSystems
ADDP4
ASGNP4
line 499
;498:
;499:    if( !Q_stricmpn( bps->name, name, MAX_QPATH ) )
ADDRLP4 20
INDIRP4
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
CNSTI4 64
ARGI4
ADDRLP4 28
ADDRGP4 Q_stricmpn
CALLI4
ASGNI4
ADDRLP4 28
INDIRI4
CNSTI4 0
NEI4 $249
line 500
;500:    {
line 502
;501:      //already registered
;502:      if( bps->registered )
ADDRLP4 20
INDIRP4
CNSTI4 88
ADDP4
INDIRI4
CNSTI4 0
EQI4 $251
line 503
;503:        return i + 1;
ADDRLP4 24
INDIRI4
CNSTI4 1
ADDI4
RETI4
ADDRGP4 $244
JUMPV
LABELV $251
line 505
;504:
;505:      for( j = 0; j < bps->numEjectors; j++ )
ADDRLP4 16
CNSTI4 0
ASGNI4
ADDRGP4 $256
JUMPV
LABELV $253
line 506
;506:      {
line 507
;507:        bpe = bps->ejectors[ j ];
ADDRLP4 12
ADDRLP4 16
INDIRI4
CNSTI4 2
LSHI4
ADDRLP4 20
INDIRP4
CNSTI4 64
ADDP4
ADDP4
INDIRP4
ASGNP4
line 509
;508:
;509:        for( l = 0; l < bpe->numParticles; l++ )
ADDRLP4 8
CNSTI4 0
ASGNI4
ADDRGP4 $260
JUMPV
LABELV $257
line 510
;510:        {
line 511
;511:          bp = bpe->particles[ l ];
ADDRLP4 4
ADDRLP4 8
INDIRI4
CNSTI4 2
LSHI4
ADDRLP4 12
INDIRP4
ADDP4
INDIRP4
ASGNP4
line 513
;512:
;513:          for( k = 0; k < bp->numFrames; k++ )
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $264
JUMPV
LABELV $261
line 514
;514:            bp->shaders[ k ] = trap_R_RegisterShader( bp->shaderNames[ k ] );
ADDRLP4 0
INDIRI4
CNSTI4 6
LSHI4
ADDRLP4 4
INDIRP4
CNSTI4 652
ADDP4
ADDP4
ARGP4
ADDRLP4 40
ADDRGP4 trap_R_RegisterShader
CALLI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRLP4 4
INDIRP4
CNSTI4 2700
ADDP4
ADDP4
ADDRLP4 40
INDIRI4
ASGNI4
LABELV $262
line 513
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $264
ADDRLP4 0
INDIRI4
ADDRLP4 4
INDIRP4
CNSTI4 2828
ADDP4
INDIRI4
LTI4 $261
line 516
;515:
;516:          for( k = 0; k < bp->numModels; k++ )
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $268
JUMPV
LABELV $265
line 517
;517:            bp->models[ k ] = trap_R_RegisterModel( bp->modelNames[ k ] );
ADDRLP4 0
INDIRI4
CNSTI4 6
LSHI4
ADDRLP4 4
INDIRP4
CNSTI4 2836
ADDP4
ADDP4
ARGP4
ADDRLP4 52
ADDRGP4 trap_R_RegisterModel
CALLI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRLP4 4
INDIRP4
CNSTI4 3348
ADDP4
ADDP4
ADDRLP4 52
INDIRI4
ASGNI4
LABELV $266
line 516
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $268
ADDRLP4 0
INDIRI4
ADDRLP4 4
INDIRP4
CNSTI4 3380
ADDP4
INDIRI4
LTI4 $265
line 519
;518:
;519:          if( bp->bounceMarkName[ 0 ] != '\0' )
ADDRLP4 4
INDIRP4
CNSTI4 152
ADDP4
INDIRI1
CVII4 1
CNSTI4 0
EQI4 $269
line 520
;520:            bp->bounceMark = trap_R_RegisterShader( bp->bounceMarkName );
ADDRLP4 4
INDIRP4
CNSTI4 152
ADDP4
ARGP4
ADDRLP4 60
ADDRGP4 trap_R_RegisterShader
CALLI4
ASGNI4
ADDRLP4 4
INDIRP4
CNSTI4 216
ADDP4
ADDRLP4 60
INDIRI4
ASGNI4
LABELV $269
line 522
;521:
;522:          if( bp->bounceSoundName[ 0 ] != '\0' )
ADDRLP4 4
INDIRP4
CNSTI4 236
ADDP4
INDIRI1
CVII4 1
CNSTI4 0
EQI4 $271
line 523
;523:            bp->bounceSound = trap_S_RegisterSound( bp->bounceSoundName, qfalse );
ADDRLP4 4
INDIRP4
CNSTI4 236
ADDP4
ARGP4
CNSTI4 0
ARGI4
ADDRLP4 68
ADDRGP4 trap_S_RegisterSound
CALLI4
ASGNI4
ADDRLP4 4
INDIRP4
CNSTI4 300
ADDP4
ADDRLP4 68
INDIRI4
ASGNI4
LABELV $271
line 526
;524:
;525:          //recursively register any children
;526:          if( bp->childSystemName[ 0 ] != '\0' )
ADDRLP4 4
INDIRP4
CNSTI4 446
ADDP4
INDIRI1
CVII4 1
CNSTI4 0
EQI4 $273
line 527
;527:          {
line 530
;528:            //don't care about a handle for children since
;529:            //the system deals with it
;530:            CG_RegisterParticleSystem( bp->childSystemName );
ADDRLP4 4
INDIRP4
CNSTI4 446
ADDP4
ARGP4
ADDRGP4 CG_RegisterParticleSystem
CALLI4
pop
line 531
;531:          }
LABELV $273
line 533
;532:
;533:          if( bp->onDeathSystemName[ 0 ] != '\0' )
ADDRLP4 4
INDIRP4
CNSTI4 516
ADDP4
INDIRI1
CVII4 1
CNSTI4 0
EQI4 $275
line 534
;534:          {
line 537
;535:            //don't care about a handle for children since
;536:            //the system deals with it
;537:            CG_RegisterParticleSystem( bp->onDeathSystemName );
ADDRLP4 4
INDIRP4
CNSTI4 516
ADDP4
ARGP4
ADDRGP4 CG_RegisterParticleSystem
CALLI4
pop
line 538
;538:          }
LABELV $275
line 540
;539:
;540:          if( bp->childTrailSystemName[ 0 ] != '\0' )
ADDRLP4 4
INDIRP4
CNSTI4 584
ADDP4
INDIRI1
CVII4 1
CNSTI4 0
EQI4 $277
line 541
;541:            bp->childTrailSystemHandle = CG_RegisterTrailSystem( bp->childTrailSystemName );
ADDRLP4 4
INDIRP4
CNSTI4 584
ADDP4
ARGP4
ADDRLP4 76
ADDRGP4 CG_RegisterTrailSystem
CALLI4
ASGNI4
ADDRLP4 4
INDIRP4
CNSTI4 648
ADDP4
ADDRLP4 76
INDIRI4
ASGNI4
LABELV $277
line 542
;542:        }
LABELV $258
line 509
ADDRLP4 8
ADDRLP4 8
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $260
ADDRLP4 8
INDIRI4
ADDRLP4 12
INDIRP4
CNSTI4 16
ADDP4
INDIRI4
LTI4 $257
line 543
;543:      }
LABELV $254
line 505
ADDRLP4 16
ADDRLP4 16
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $256
ADDRLP4 16
INDIRI4
ADDRLP4 20
INDIRP4
CNSTI4 80
ADDP4
INDIRI4
LTI4 $253
line 545
;544:
;545:      if( cg_debugParticles.integer >= 1 )
ADDRGP4 cg_debugParticles+12
INDIRI4
CNSTI4 1
LTI4 $279
line 546
;546:        CG_Printf( "Registered particle system %s\n", name );
ADDRGP4 $282
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRGP4 CG_Printf
CALLV
pop
LABELV $279
line 548
;547:
;548:      bps->registered = qtrue;
ADDRLP4 20
INDIRP4
CNSTI4 88
ADDP4
CNSTI4 1
ASGNI4
line 551
;549:
;550:      //avoid returning 0
;551:      return i + 1;
ADDRLP4 24
INDIRI4
CNSTI4 1
ADDI4
RETI4
ADDRGP4 $244
JUMPV
LABELV $249
line 553
;552:    }
;553:  }
LABELV $246
line 495
ADDRLP4 24
ADDRLP4 24
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 24
INDIRI4
CNSTI4 192
LTI4 $245
line 555
;554:
;555:  CG_Printf( S_COLOR_RED "ERROR: failed to register particle system %s\n", name );
ADDRGP4 $283
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRGP4 CG_Printf
CALLV
pop
line 556
;556:  return 0;
CNSTI4 0
RETI4
LABELV $244
endproc CG_RegisterParticleSystem 80 12
proc CG_ParseValueAndVariance 68 12
line 568
;557:}
;558:
;559:
;560:/*
;561:===============
;562:CG_ParseValueAndVariance
;563:
;564:Parse a value and its random variance
;565:===============
;566:*/
;567:static void CG_ParseValueAndVariance( char *token, float *value, float *variance, qboolean allowNegative )
;568:{
line 571
;569:  char  valueBuffer[ 16 ];
;570:  char  varianceBuffer[ 16 ];
;571:  char  *variancePtr = NULL, *varEndPointer = NULL;
ADDRLP4 0
CNSTP4 0
ASGNP4
ADDRLP4 24
CNSTP4 0
ASGNP4
line 572
;572:  float localValue = 0.0f;
ADDRLP4 20
CNSTF4 0
ASGNF4
line 573
;573:  float localVariance = 0.0f;
ADDRLP4 44
CNSTF4 0
ASGNF4
line 575
;574:
;575:  Q_strncpyz( valueBuffer, token, sizeof( valueBuffer ) );
ADDRLP4 4
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
CNSTI4 16
ARGI4
ADDRGP4 Q_strncpyz
CALLV
pop
line 576
;576:  Q_strncpyz( varianceBuffer, token, sizeof( varianceBuffer ) );
ADDRLP4 28
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
CNSTI4 16
ARGI4
ADDRGP4 Q_strncpyz
CALLV
pop
line 578
;577:
;578:  variancePtr = strchr( valueBuffer, '~' );
ADDRLP4 4
ARGP4
CNSTI4 126
ARGI4
ADDRLP4 48
ADDRGP4 strchr
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 48
INDIRP4
ASGNP4
line 581
;579:
;580:  //variance included
;581:  if( variancePtr )
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $285
line 582
;582:  {
line 583
;583:    variancePtr[ 0 ] = '\0';
ADDRLP4 0
INDIRP4
CNSTI1 0
ASGNI1
line 584
;584:    variancePtr++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 586
;585:
;586:    localValue = atof_neg( valueBuffer, allowNegative );
ADDRLP4 4
ARGP4
ADDRFP4 12
INDIRI4
ARGI4
ADDRLP4 52
ADDRGP4 atof_neg
CALLF4
ASGNF4
ADDRLP4 20
ADDRLP4 52
INDIRF4
ASGNF4
line 588
;587:
;588:    varEndPointer = strchr( variancePtr, '%' );
ADDRLP4 0
INDIRP4
ARGP4
CNSTI4 37
ARGI4
ADDRLP4 56
ADDRGP4 strchr
CALLP4
ASGNP4
ADDRLP4 24
ADDRLP4 56
INDIRP4
ASGNP4
line 590
;589:
;590:    if( varEndPointer )
ADDRLP4 24
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $287
line 591
;591:    {
line 592
;592:      varEndPointer[ 0 ] = '\0';
ADDRLP4 24
INDIRP4
CNSTI1 0
ASGNI1
line 593
;593:      localVariance = atof_neg( variancePtr, qfalse ) / 100.0f;
ADDRLP4 0
INDIRP4
ARGP4
CNSTI4 0
ARGI4
ADDRLP4 60
ADDRGP4 atof_neg
CALLF4
ASGNF4
ADDRLP4 44
ADDRLP4 60
INDIRF4
CNSTF4 1120403456
DIVF4
ASGNF4
line 594
;594:    }
ADDRGP4 $286
JUMPV
LABELV $287
line 596
;595:    else
;596:    {
line 597
;597:      if( localValue != 0.0f )
ADDRLP4 20
INDIRF4
CNSTF4 0
EQF4 $289
line 598
;598:        localVariance = atof_neg( variancePtr, qfalse ) / localValue;
ADDRLP4 0
INDIRP4
ARGP4
CNSTI4 0
ARGI4
ADDRLP4 60
ADDRGP4 atof_neg
CALLF4
ASGNF4
ADDRLP4 44
ADDRLP4 60
INDIRF4
ADDRLP4 20
INDIRF4
DIVF4
ASGNF4
ADDRGP4 $286
JUMPV
LABELV $289
line 600
;599:      else
;600:        localVariance = atof_neg( variancePtr, qfalse );
ADDRLP4 0
INDIRP4
ARGP4
CNSTI4 0
ARGI4
ADDRLP4 64
ADDRGP4 atof_neg
CALLF4
ASGNF4
ADDRLP4 44
ADDRLP4 64
INDIRF4
ASGNF4
line 601
;601:    }
line 602
;602:  }
ADDRGP4 $286
JUMPV
LABELV $285
line 604
;603:  else
;604:    localValue = atof_neg( valueBuffer, allowNegative );
ADDRLP4 4
ARGP4
ADDRFP4 12
INDIRI4
ARGI4
ADDRLP4 52
ADDRGP4 atof_neg
CALLF4
ASGNF4
ADDRLP4 20
ADDRLP4 52
INDIRF4
ASGNF4
LABELV $286
line 606
;605:
;606:  if( value != NULL )
ADDRFP4 4
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $291
line 607
;607:    *value = localValue;
ADDRFP4 4
INDIRP4
ADDRLP4 20
INDIRF4
ASGNF4
LABELV $291
line 609
;608:
;609:  if( variance != NULL )
ADDRFP4 8
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $293
line 610
;610:    *variance = localVariance;
ADDRFP4 8
INDIRP4
ADDRLP4 44
INDIRF4
ASGNF4
LABELV $293
line 611
;611:}
LABELV $284
endproc CG_ParseValueAndVariance 68 12
proc CG_ParseColor 20 8
line 619
;612:
;613:/*
;614:===============
;615:CG_ParseColor
;616:===============
;617:*/
;618:static qboolean CG_ParseColor( byte *c, char **text_p )
;619:{
line 623
;620:  char  *token;
;621:  int   i;
;622:
;623:  for( i = 0; i <= 2; i++ )
ADDRLP4 0
CNSTI4 0
ASGNI4
LABELV $296
line 624
;624:  {
line 625
;625:    token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 8
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 4
ADDRLP4 8
INDIRP4
ASGNP4
line 627
;626:
;627:    if( !Q_stricmp( token, "" ) )
ADDRLP4 4
INDIRP4
ARGP4
ADDRGP4 $302
ARGP4
ADDRLP4 12
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 0
NEI4 $300
line 628
;628:      return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $295
JUMPV
LABELV $300
line 630
;629:
;630:    c[ i ] = (int)( (float)0xFF * atof_neg( token, qfalse ) );
ADDRLP4 4
INDIRP4
ARGP4
CNSTI4 0
ARGI4
ADDRLP4 16
ADDRGP4 atof_neg
CALLF4
ASGNF4
ADDRLP4 0
INDIRI4
ADDRFP4 0
INDIRP4
ADDP4
CNSTF4 1132396544
ADDRLP4 16
INDIRF4
MULF4
CVFI4 4
CVIU4 4
CVUU1 4
ASGNU1
line 631
;631:  }
LABELV $297
line 623
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 2
LEI4 $296
line 633
;632:
;633:  return qtrue;
CNSTI4 1
RETI4
LABELV $295
endproc CG_ParseColor 20 8
proc CG_ParseParticle 176 16
line 644
;634:}
;635:
;636:/*
;637:===============
;638:CG_ParseParticle
;639:
;640:Parse a particle section
;641:===============
;642:*/
;643:static qboolean CG_ParseParticle( baseParticle_t *bp, char **text_p )
;644:{
ADDRGP4 $305
JUMPV
LABELV $304
line 651
;645:  char  *token;
;646:  float number, randFrac;
;647:  int   i;
;648:
;649:  // read optional parameters
;650:  while( 1 )
;651:  {
line 652
;652:    token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 16
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 16
INDIRP4
ASGNP4
line 654
;653:
;654:    if( !token )
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $307
line 655
;655:      break;
ADDRGP4 $306
JUMPV
LABELV $307
line 657
;656:
;657:    if( !Q_stricmp( token, "" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $302
ARGP4
ADDRLP4 20
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 20
INDIRI4
CNSTI4 0
NEI4 $309
line 658
;658:      return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $303
JUMPV
LABELV $309
line 660
;659:
;660:    if( !Q_stricmp( token, "bounce" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $313
ARGP4
ADDRLP4 24
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 24
INDIRI4
CNSTI4 0
NEI4 $311
line 661
;661:    {
line 662
;662:      token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 28
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 28
INDIRP4
ASGNP4
line 663
;663:      if( !token )
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $314
line 664
;664:        break;
ADDRGP4 $306
JUMPV
LABELV $314
line 666
;665:
;666:      if( !Q_stricmp( token, "cull" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $318
ARGP4
ADDRLP4 32
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 32
INDIRI4
CNSTI4 0
NEI4 $316
line 667
;667:      {
line 668
;668:        bp->bounceCull = qtrue;
ADDRFP4 0
INDIRP4
CNSTI4 148
ADDP4
CNSTI4 1
ASGNI4
line 670
;669:
;670:        bp->bounceFrac = -1.0f;
ADDRFP4 0
INDIRP4
CNSTI4 140
ADDP4
CNSTF4 3212836864
ASGNF4
line 671
;671:        bp->bounceFracRandFrac = 0.0f;
ADDRFP4 0
INDIRP4
CNSTI4 144
ADDP4
CNSTF4 0
ASGNF4
line 672
;672:      }
ADDRGP4 $305
JUMPV
LABELV $316
line 674
;673:      else
;674:      {
line 675
;675:        CG_ParseValueAndVariance( token, &number, &randFrac, qfalse );
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 8
ARGP4
ADDRLP4 4
ARGP4
CNSTI4 0
ARGI4
ADDRGP4 CG_ParseValueAndVariance
CALLV
pop
line 677
;676:
;677:        bp->bounceFrac = number;
ADDRFP4 0
INDIRP4
CNSTI4 140
ADDP4
ADDRLP4 8
INDIRF4
ASGNF4
line 678
;678:        bp->bounceFracRandFrac = randFrac;
ADDRFP4 0
INDIRP4
CNSTI4 144
ADDP4
ADDRLP4 4
INDIRF4
ASGNF4
line 679
;679:      }
line 681
;680:
;681:      continue;
ADDRGP4 $305
JUMPV
LABELV $311
line 683
;682:    }
;683:    else if( !Q_stricmp( token, "bounceMark" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $321
ARGP4
ADDRLP4 28
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 28
INDIRI4
CNSTI4 0
NEI4 $319
line 684
;684:    {
line 685
;685:      token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 32
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 32
INDIRP4
ASGNP4
line 686
;686:      if( !*token )
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $322
line 687
;687:        break;
ADDRGP4 $306
JUMPV
LABELV $322
line 689
;688:
;689:      CG_ParseValueAndVariance( token, &number, &randFrac, qfalse );
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 8
ARGP4
ADDRLP4 4
ARGP4
CNSTI4 0
ARGI4
ADDRGP4 CG_ParseValueAndVariance
CALLV
pop
line 691
;690:
;691:      bp->bounceMarkCount = number;
ADDRFP4 0
INDIRP4
CNSTI4 228
ADDP4
ADDRLP4 8
INDIRF4
ASGNF4
line 692
;692:      bp->bounceMarkCountRandFrac = randFrac;
ADDRFP4 0
INDIRP4
CNSTI4 232
ADDP4
ADDRLP4 4
INDIRF4
ASGNF4
line 694
;693:
;694:      token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 36
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 36
INDIRP4
ASGNP4
line 695
;695:      if( !*token )
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $324
line 696
;696:        break;
ADDRGP4 $306
JUMPV
LABELV $324
line 698
;697:
;698:      CG_ParseValueAndVariance( token, &number, &randFrac, qfalse );
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 8
ARGP4
ADDRLP4 4
ARGP4
CNSTI4 0
ARGI4
ADDRGP4 CG_ParseValueAndVariance
CALLV
pop
line 700
;699:
;700:      bp->bounceMarkRadius = number;
ADDRFP4 0
INDIRP4
CNSTI4 220
ADDP4
ADDRLP4 8
INDIRF4
ASGNF4
line 701
;701:      bp->bounceMarkRadiusRandFrac = randFrac;
ADDRFP4 0
INDIRP4
CNSTI4 224
ADDP4
ADDRLP4 4
INDIRF4
ASGNF4
line 703
;702:
;703:      token = COM_ParseExt( text_p, qfalse );
ADDRFP4 4
INDIRP4
ARGP4
CNSTI4 0
ARGI4
ADDRLP4 40
ADDRGP4 COM_ParseExt
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 40
INDIRP4
ASGNP4
line 704
;704:      if( !*token )
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $326
line 705
;705:        break;
ADDRGP4 $306
JUMPV
LABELV $326
line 707
;706:
;707:      Q_strncpyz( bp->bounceMarkName, token, MAX_QPATH );
ADDRFP4 0
INDIRP4
CNSTI4 152
ADDP4
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
CNSTI4 64
ARGI4
ADDRGP4 Q_strncpyz
CALLV
pop
line 709
;708:
;709:      continue;
ADDRGP4 $305
JUMPV
LABELV $319
line 711
;710:    }
;711:    else if( !Q_stricmp( token, "bounceSound" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $330
ARGP4
ADDRLP4 32
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 32
INDIRI4
CNSTI4 0
NEI4 $328
line 712
;712:    {
line 713
;713:      token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 36
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 36
INDIRP4
ASGNP4
line 714
;714:      if( !*token )
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $331
line 715
;715:        break;
ADDRGP4 $306
JUMPV
LABELV $331
line 717
;716:
;717:      CG_ParseValueAndVariance( token, &number, &randFrac, qfalse );
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 8
ARGP4
ADDRLP4 4
ARGP4
CNSTI4 0
ARGI4
ADDRGP4 CG_ParseValueAndVariance
CALLV
pop
line 719
;718:
;719:      bp->bounceSoundCount = number;
ADDRFP4 0
INDIRP4
CNSTI4 304
ADDP4
ADDRLP4 8
INDIRF4
ASGNF4
line 720
;720:      bp->bounceSoundCountRandFrac = randFrac;
ADDRFP4 0
INDIRP4
CNSTI4 308
ADDP4
ADDRLP4 4
INDIRF4
ASGNF4
line 722
;721:
;722:      token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 40
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 40
INDIRP4
ASGNP4
line 723
;723:      if( !*token )
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $333
line 724
;724:        break;
ADDRGP4 $306
JUMPV
LABELV $333
line 726
;725:
;726:      Q_strncpyz( bp->bounceSoundName, token, MAX_QPATH );
ADDRFP4 0
INDIRP4
CNSTI4 236
ADDP4
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
CNSTI4 64
ARGI4
ADDRGP4 Q_strncpyz
CALLV
pop
line 728
;727:
;728:      continue;
ADDRGP4 $305
JUMPV
LABELV $328
line 730
;729:    }
;730:    else if( !Q_stricmp( token, "shader" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $337
ARGP4
ADDRLP4 36
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 36
INDIRI4
CNSTI4 0
NEI4 $335
line 731
;731:    {
line 732
;732:      if( bp->numModels > 0 )
ADDRFP4 0
INDIRP4
CNSTI4 3380
ADDP4
INDIRI4
CNSTI4 0
LEI4 $338
line 733
;733:      {
line 734
;734:        CG_Printf( S_COLOR_RED "ERROR: 'shader' not allowed in "
ADDRGP4 $340
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 CG_Printf
CALLV
pop
line 736
;735:            "conjunction with 'model'\n", token );
;736:        break;
ADDRGP4 $306
JUMPV
LABELV $338
line 739
;737:      }
;738:
;739:      token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 40
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 40
INDIRP4
ASGNP4
line 740
;740:      if( !token )
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $341
line 741
;741:        break;
ADDRGP4 $306
JUMPV
LABELV $341
line 743
;742:
;743:      if( !Q_stricmp( token, "sync" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $345
ARGP4
ADDRLP4 44
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 44
INDIRI4
CNSTI4 0
NEI4 $343
line 744
;744:        bp->framerate = 0.0f;
ADDRFP4 0
INDIRP4
CNSTI4 2832
ADDP4
CNSTF4 0
ASGNF4
ADDRGP4 $344
JUMPV
LABELV $343
line 746
;745:      else
;746:        bp->framerate = atof_neg( token, qfalse );
ADDRLP4 0
INDIRP4
ARGP4
CNSTI4 0
ARGI4
ADDRLP4 48
ADDRGP4 atof_neg
CALLF4
ASGNF4
ADDRFP4 0
INDIRP4
CNSTI4 2832
ADDP4
ADDRLP4 48
INDIRF4
ASGNF4
LABELV $344
line 748
;747:
;748:      token = COM_ParseExt( text_p, qfalse );
ADDRFP4 4
INDIRP4
ARGP4
CNSTI4 0
ARGI4
ADDRLP4 52
ADDRGP4 COM_ParseExt
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 52
INDIRP4
ASGNP4
line 749
;749:      if( !*token )
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $349
line 750
;750:        break;
ADDRGP4 $306
JUMPV
LABELV $348
line 753
;751:
;752:      while( *token && bp->numFrames < MAX_PS_SHADER_FRAMES )
;753:      {
line 754
;754:        Q_strncpyz( bp->shaderNames[ bp->numFrames++ ], token, MAX_QPATH );
ADDRLP4 60
ADDRFP4 0
INDIRP4
CNSTI4 2828
ADDP4
ASGNP4
ADDRLP4 56
ADDRLP4 60
INDIRP4
INDIRI4
ASGNI4
ADDRLP4 60
INDIRP4
ADDRLP4 56
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 56
INDIRI4
CNSTI4 6
LSHI4
ADDRFP4 0
INDIRP4
CNSTI4 652
ADDP4
ADDP4
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
CNSTI4 64
ARGI4
ADDRGP4 Q_strncpyz
CALLV
pop
line 755
;755:        token = COM_ParseExt( text_p, qfalse );
ADDRFP4 4
INDIRP4
ARGP4
CNSTI4 0
ARGI4
ADDRLP4 64
ADDRGP4 COM_ParseExt
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 64
INDIRP4
ASGNP4
line 756
;756:      }
LABELV $349
line 752
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
EQI4 $351
ADDRFP4 0
INDIRP4
CNSTI4 2828
ADDP4
INDIRI4
CNSTI4 32
LTI4 $348
LABELV $351
line 758
;757:
;758:      continue;
ADDRGP4 $305
JUMPV
LABELV $335
line 760
;759:    }
;760:    else if( !Q_stricmp( token, "model" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $354
ARGP4
ADDRLP4 40
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 40
INDIRI4
CNSTI4 0
NEI4 $352
line 761
;761:    {
line 762
;762:      if( bp->numFrames > 0 )
ADDRFP4 0
INDIRP4
CNSTI4 2828
ADDP4
INDIRI4
CNSTI4 0
LEI4 $355
line 763
;763:      {
line 764
;764:        CG_Printf( S_COLOR_RED "ERROR: 'model' not allowed in "
ADDRGP4 $357
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 CG_Printf
CALLV
pop
line 766
;765:            "conjunction with 'shader'\n", token );
;766:        break;
ADDRGP4 $306
JUMPV
LABELV $355
line 769
;767:      }
;768:
;769:      token = COM_ParseExt( text_p, qfalse );
ADDRFP4 4
INDIRP4
ARGP4
CNSTI4 0
ARGI4
ADDRLP4 44
ADDRGP4 COM_ParseExt
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 44
INDIRP4
ASGNP4
line 770
;770:      if( !*token )
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $361
line 771
;771:        break;
ADDRGP4 $306
JUMPV
LABELV $360
line 774
;772:
;773:      while( *token && bp->numModels < MAX_PS_MODELS )
;774:      {
line 775
;775:        Q_strncpyz( bp->modelNames[ bp->numModels++ ], token, MAX_QPATH );
ADDRLP4 52
ADDRFP4 0
INDIRP4
CNSTI4 3380
ADDP4
ASGNP4
ADDRLP4 48
ADDRLP4 52
INDIRP4
INDIRI4
ASGNI4
ADDRLP4 52
INDIRP4
ADDRLP4 48
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 48
INDIRI4
CNSTI4 6
LSHI4
ADDRFP4 0
INDIRP4
CNSTI4 2836
ADDP4
ADDP4
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
CNSTI4 64
ARGI4
ADDRGP4 Q_strncpyz
CALLV
pop
line 776
;776:        token = COM_ParseExt( text_p, qfalse );
ADDRFP4 4
INDIRP4
ARGP4
CNSTI4 0
ARGI4
ADDRLP4 56
ADDRGP4 COM_ParseExt
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 56
INDIRP4
ASGNP4
line 777
;777:      }
LABELV $361
line 773
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
EQI4 $363
ADDRFP4 0
INDIRP4
CNSTI4 3380
ADDP4
INDIRI4
CNSTI4 8
LTI4 $360
LABELV $363
line 779
;778:
;779:      continue;
ADDRGP4 $305
JUMPV
LABELV $352
line 781
;780:    }
;781:    else if( !Q_stricmp( token, "modelAnimation" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $366
ARGP4
ADDRLP4 44
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 44
INDIRI4
CNSTI4 0
NEI4 $364
line 782
;782:    {
line 783
;783:      token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 48
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 48
INDIRP4
ASGNP4
line 784
;784:      if( !*token )
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $367
line 785
;785:        break;
ADDRGP4 $306
JUMPV
LABELV $367
line 787
;786:
;787:      bp->modelAnimation.firstFrame = atoi_neg( token, qfalse );
ADDRLP4 0
INDIRP4
ARGP4
CNSTI4 0
ARGI4
ADDRLP4 52
ADDRGP4 atoi_neg
CALLI4
ASGNI4
ADDRFP4 0
INDIRP4
CNSTI4 3384
ADDP4
ADDRLP4 52
INDIRI4
ASGNI4
line 789
;788:
;789:      token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 56
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 56
INDIRP4
ASGNP4
line 790
;790:      if( !*token )
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $369
line 791
;791:        break;
ADDRGP4 $306
JUMPV
LABELV $369
line 793
;792:
;793:      bp->modelAnimation.numFrames = atoi( token );
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 60
ADDRGP4 atoi
CALLI4
ASGNI4
ADDRFP4 0
INDIRP4
CNSTI4 3388
ADDP4
ADDRLP4 60
INDIRI4
ASGNI4
line 794
;794:      bp->modelAnimation.reversed = qfalse;
ADDRFP4 0
INDIRP4
CNSTI4 3404
ADDP4
CNSTI4 0
ASGNI4
line 795
;795:      bp->modelAnimation.flipflop = qfalse;
ADDRFP4 0
INDIRP4
CNSTI4 3408
ADDP4
CNSTI4 0
ASGNI4
line 798
;796:
;797:      // if numFrames is negative the animation is reversed
;798:      if( bp->modelAnimation.numFrames < 0 )
ADDRFP4 0
INDIRP4
CNSTI4 3388
ADDP4
INDIRI4
CNSTI4 0
GEI4 $371
line 799
;799:      {
line 800
;800:        bp->modelAnimation.numFrames = -bp->modelAnimation.numFrames;
ADDRLP4 64
ADDRFP4 0
INDIRP4
CNSTI4 3388
ADDP4
ASGNP4
ADDRLP4 64
INDIRP4
ADDRLP4 64
INDIRP4
INDIRI4
NEGI4
ASGNI4
line 801
;801:        bp->modelAnimation.reversed = qtrue;
ADDRFP4 0
INDIRP4
CNSTI4 3404
ADDP4
CNSTI4 1
ASGNI4
line 802
;802:      }
LABELV $371
line 804
;803:
;804:      token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 64
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 64
INDIRP4
ASGNP4
line 805
;805:      if( !*token )
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $373
line 806
;806:        break;
ADDRGP4 $306
JUMPV
LABELV $373
line 808
;807:
;808:      bp->modelAnimation.loopFrames = atoi( token );
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 68
ADDRGP4 atoi
CALLI4
ASGNI4
ADDRFP4 0
INDIRP4
CNSTI4 3392
ADDP4
ADDRLP4 68
INDIRI4
ASGNI4
line 810
;809:
;810:      token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 72
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 72
INDIRP4
ASGNP4
line 811
;811:      if( !*token )
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $375
line 812
;812:        break;
ADDRGP4 $306
JUMPV
LABELV $375
line 814
;813:
;814:      if( !Q_stricmp( token, "sync" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $345
ARGP4
ADDRLP4 76
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 76
INDIRI4
CNSTI4 0
NEI4 $377
line 815
;815:      {
line 816
;816:        bp->modelAnimation.frameLerp = -1;
ADDRFP4 0
INDIRP4
CNSTI4 3396
ADDP4
CNSTI4 -1
ASGNI4
line 817
;817:        bp->modelAnimation.initialLerp = -1;
ADDRFP4 0
INDIRP4
CNSTI4 3400
ADDP4
CNSTI4 -1
ASGNI4
line 818
;818:      }
ADDRGP4 $305
JUMPV
LABELV $377
line 820
;819:      else
;820:      {
line 821
;821:        float fps = atof_neg( token, qfalse );
ADDRLP4 0
INDIRP4
ARGP4
CNSTI4 0
ARGI4
ADDRLP4 84
ADDRGP4 atof_neg
CALLF4
ASGNF4
ADDRLP4 80
ADDRLP4 84
INDIRF4
ASGNF4
line 823
;822:
;823:        if( fps == 0.0f )
ADDRLP4 80
INDIRF4
CNSTF4 0
NEF4 $379
line 824
;824:          fps = 1.0f;
ADDRLP4 80
CNSTF4 1065353216
ASGNF4
LABELV $379
line 826
;825:
;826:        bp->modelAnimation.frameLerp = 1000 / fps;
ADDRFP4 0
INDIRP4
CNSTI4 3396
ADDP4
CNSTF4 1148846080
ADDRLP4 80
INDIRF4
DIVF4
CVFI4 4
ASGNI4
line 827
;827:        bp->modelAnimation.initialLerp = 1000 / fps;
ADDRFP4 0
INDIRP4
CNSTI4 3400
ADDP4
CNSTF4 1148846080
ADDRLP4 80
INDIRF4
DIVF4
CVFI4 4
ASGNI4
line 828
;828:      }
line 830
;829:
;830:      continue;
ADDRGP4 $305
JUMPV
LABELV $364
line 833
;831:    }
;832:    ///
;833:    else if( !Q_stricmp( token, "velocityType" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $383
ARGP4
ADDRLP4 48
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 48
INDIRI4
CNSTI4 0
NEI4 $381
line 834
;834:    {
line 835
;835:      token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 52
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 52
INDIRP4
ASGNP4
line 836
;836:      if( !token )
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $384
line 837
;837:        break;
ADDRGP4 $306
JUMPV
LABELV $384
line 839
;838:
;839:      if( !Q_stricmp( token, "static" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $388
ARGP4
ADDRLP4 56
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 56
INDIRI4
CNSTI4 0
NEI4 $386
line 840
;840:        bp->velMoveType = PMT_STATIC;
ADDRFP4 0
INDIRP4
CNSTI4 20
ADDP4
CNSTI4 0
ASGNI4
ADDRGP4 $305
JUMPV
LABELV $386
line 841
;841:      else if( !Q_stricmp( token, "static_transform" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $391
ARGP4
ADDRLP4 60
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 60
INDIRI4
CNSTI4 0
NEI4 $389
line 842
;842:        bp->velMoveType = PMT_STATIC_TRANSFORM;
ADDRFP4 0
INDIRP4
CNSTI4 20
ADDP4
CNSTI4 1
ASGNI4
ADDRGP4 $305
JUMPV
LABELV $389
line 843
;843:      else if( !Q_stricmp( token, "tag" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $394
ARGP4
ADDRLP4 64
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 64
INDIRI4
CNSTI4 0
NEI4 $392
line 844
;844:        bp->velMoveType = PMT_TAG;
ADDRFP4 0
INDIRP4
CNSTI4 20
ADDP4
CNSTI4 2
ASGNI4
ADDRGP4 $305
JUMPV
LABELV $392
line 845
;845:      else if( !Q_stricmp( token, "cent" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $397
ARGP4
ADDRLP4 68
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 68
INDIRI4
CNSTI4 0
NEI4 $395
line 846
;846:        bp->velMoveType = PMT_CENT_ANGLES;
ADDRFP4 0
INDIRP4
CNSTI4 20
ADDP4
CNSTI4 3
ASGNI4
ADDRGP4 $305
JUMPV
LABELV $395
line 847
;847:      else if( !Q_stricmp( token, "normal" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $400
ARGP4
ADDRLP4 72
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 72
INDIRI4
CNSTI4 0
NEI4 $305
line 848
;848:        bp->velMoveType = PMT_NORMAL;
ADDRFP4 0
INDIRP4
CNSTI4 20
ADDP4
CNSTI4 4
ASGNI4
line 850
;849:
;850:      continue;
ADDRGP4 $305
JUMPV
LABELV $381
line 852
;851:    }
;852:    else if( !Q_stricmp( token, "velocityDir" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $403
ARGP4
ADDRLP4 52
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 52
INDIRI4
CNSTI4 0
NEI4 $401
line 853
;853:    {
line 854
;854:      token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 56
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 56
INDIRP4
ASGNP4
line 855
;855:      if( !token )
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $404
line 856
;856:        break;
ADDRGP4 $306
JUMPV
LABELV $404
line 858
;857:
;858:      if( !Q_stricmp( token, "linear" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $408
ARGP4
ADDRLP4 60
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 60
INDIRI4
CNSTI4 0
NEI4 $406
line 859
;859:        bp->velMoveValues.dirType = PMD_LINEAR;
ADDRFP4 0
INDIRP4
CNSTI4 24
ADDP4
CNSTI4 0
ASGNI4
ADDRGP4 $305
JUMPV
LABELV $406
line 860
;860:      else if( !Q_stricmp( token, "point" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $411
ARGP4
ADDRLP4 64
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 64
INDIRI4
CNSTI4 0
NEI4 $305
line 861
;861:        bp->velMoveValues.dirType = PMD_POINT;
ADDRFP4 0
INDIRP4
CNSTI4 24
ADDP4
CNSTI4 1
ASGNI4
line 863
;862:
;863:      continue;
ADDRGP4 $305
JUMPV
LABELV $401
line 865
;864:    }
;865:    else if( !Q_stricmp( token, "velocityMagnitude" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $414
ARGP4
ADDRLP4 56
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 56
INDIRI4
CNSTI4 0
NEI4 $412
line 866
;866:    {
line 867
;867:      token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 60
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 60
INDIRP4
ASGNP4
line 868
;868:      if( !token )
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $415
line 869
;869:        break;
ADDRGP4 $306
JUMPV
LABELV $415
line 871
;870:
;871:      CG_ParseValueAndVariance( token, &number, &randFrac, qfalse );
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 8
ARGP4
ADDRLP4 4
ARGP4
CNSTI4 0
ARGI4
ADDRGP4 CG_ParseValueAndVariance
CALLV
pop
line 873
;872:
;873:      bp->velMoveValues.mag = number;
ADDRFP4 0
INDIRP4
CNSTI4 60
ADDP4
ADDRLP4 8
INDIRF4
ASGNF4
line 874
;874:      bp->velMoveValues.magRandFrac = randFrac;
ADDRFP4 0
INDIRP4
CNSTI4 64
ADDP4
ADDRLP4 4
INDIRF4
ASGNF4
line 876
;875:
;876:      continue;
ADDRGP4 $305
JUMPV
LABELV $412
line 878
;877:    }
;878:    else if( !Q_stricmp( token, "parentVelocityFraction" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $419
ARGP4
ADDRLP4 60
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 60
INDIRI4
CNSTI4 0
NEI4 $417
line 879
;879:    {
line 880
;880:      token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 64
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 64
INDIRP4
ASGNP4
line 881
;881:      if( !token )
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $420
line 882
;882:        break;
ADDRGP4 $306
JUMPV
LABELV $420
line 884
;883:
;884:      CG_ParseValueAndVariance( token, &number, &randFrac, qfalse );
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 8
ARGP4
ADDRLP4 4
ARGP4
CNSTI4 0
ARGI4
ADDRGP4 CG_ParseValueAndVariance
CALLV
pop
line 886
;885:
;886:      bp->velMoveValues.parentVelFrac = number;
ADDRFP4 0
INDIRP4
CNSTI4 68
ADDP4
ADDRLP4 8
INDIRF4
ASGNF4
line 887
;887:      bp->velMoveValues.parentVelFracRandFrac = randFrac;
ADDRFP4 0
INDIRP4
CNSTI4 72
ADDP4
ADDRLP4 4
INDIRF4
ASGNF4
line 889
;888:
;889:      continue;
ADDRGP4 $305
JUMPV
LABELV $417
line 891
;890:    }
;891:    else if( !Q_stricmp( token, "velocity" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $424
ARGP4
ADDRLP4 64
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 64
INDIRI4
CNSTI4 0
NEI4 $422
line 892
;892:    {
line 893
;893:      for( i = 0; i <= 2; i++ )
ADDRLP4 12
CNSTI4 0
ASGNI4
LABELV $425
line 894
;894:      {
line 895
;895:        token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 68
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 68
INDIRP4
ASGNP4
line 896
;896:        if( !token )
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $429
line 897
;897:          break;
ADDRGP4 $427
JUMPV
LABELV $429
line 899
;898:
;899:        bp->velMoveValues.dir[ i ] = atof_neg( token, qtrue );
ADDRLP4 0
INDIRP4
ARGP4
CNSTI4 1
ARGI4
ADDRLP4 72
ADDRGP4 atof_neg
CALLF4
ASGNF4
ADDRLP4 12
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
CNSTI4 28
ADDP4
ADDP4
ADDRLP4 72
INDIRF4
ASGNF4
line 900
;900:      }
LABELV $426
line 893
ADDRLP4 12
ADDRLP4 12
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 2
LEI4 $425
LABELV $427
line 902
;901:
;902:      token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 68
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 68
INDIRP4
ASGNP4
line 903
;903:      if( !token )
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $431
line 904
;904:        break;
ADDRGP4 $306
JUMPV
LABELV $431
line 906
;905:
;906:      CG_ParseValueAndVariance( token, NULL, &randFrac, qfalse );
ADDRLP4 0
INDIRP4
ARGP4
CNSTP4 0
ARGP4
ADDRLP4 4
ARGP4
CNSTI4 0
ARGI4
ADDRGP4 CG_ParseValueAndVariance
CALLV
pop
line 908
;907:
;908:      bp->velMoveValues.dirRandAngle = randFrac;
ADDRFP4 0
INDIRP4
CNSTI4 40
ADDP4
ADDRLP4 4
INDIRF4
ASGNF4
line 910
;909:
;910:      continue;
ADDRGP4 $305
JUMPV
LABELV $422
line 912
;911:    }
;912:    else if( !Q_stricmp( token, "velocityPoint" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $435
ARGP4
ADDRLP4 68
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 68
INDIRI4
CNSTI4 0
NEI4 $433
line 913
;913:    {
line 914
;914:      for( i = 0; i <= 2; i++ )
ADDRLP4 12
CNSTI4 0
ASGNI4
LABELV $436
line 915
;915:      {
line 916
;916:        token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 72
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 72
INDIRP4
ASGNP4
line 917
;917:        if( !token )
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $440
line 918
;918:          break;
ADDRGP4 $438
JUMPV
LABELV $440
line 920
;919:
;920:        bp->velMoveValues.point[ i ] = atof_neg( token, qtrue );
ADDRLP4 0
INDIRP4
ARGP4
CNSTI4 1
ARGI4
ADDRLP4 76
ADDRGP4 atof_neg
CALLF4
ASGNF4
ADDRLP4 12
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
CNSTI4 44
ADDP4
ADDP4
ADDRLP4 76
INDIRF4
ASGNF4
line 921
;921:      }
LABELV $437
line 914
ADDRLP4 12
ADDRLP4 12
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 2
LEI4 $436
LABELV $438
line 923
;922:
;923:      token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 72
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 72
INDIRP4
ASGNP4
line 924
;924:      if( !token )
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $442
line 925
;925:        break;
ADDRGP4 $306
JUMPV
LABELV $442
line 927
;926:
;927:      CG_ParseValueAndVariance( token, NULL, &randFrac, qfalse );
ADDRLP4 0
INDIRP4
ARGP4
CNSTP4 0
ARGP4
ADDRLP4 4
ARGP4
CNSTI4 0
ARGI4
ADDRGP4 CG_ParseValueAndVariance
CALLV
pop
line 929
;928:
;929:      bp->velMoveValues.pointRandAngle = randFrac;
ADDRFP4 0
INDIRP4
CNSTI4 56
ADDP4
ADDRLP4 4
INDIRF4
ASGNF4
line 931
;930:
;931:      continue;
ADDRGP4 $305
JUMPV
LABELV $433
line 934
;932:    }
;933:    ///
;934:    else if( !Q_stricmp( token, "accelerationType" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $446
ARGP4
ADDRLP4 72
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 72
INDIRI4
CNSTI4 0
NEI4 $444
line 935
;935:    {
line 936
;936:      token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 76
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 76
INDIRP4
ASGNP4
line 937
;937:      if( !token )
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $447
line 938
;938:        break;
ADDRGP4 $306
JUMPV
LABELV $447
line 940
;939:
;940:      if( !Q_stricmp( token, "static" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $388
ARGP4
ADDRLP4 80
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 80
INDIRI4
CNSTI4 0
NEI4 $449
line 941
;941:        bp->accMoveType = PMT_STATIC;
ADDRFP4 0
INDIRP4
CNSTI4 76
ADDP4
CNSTI4 0
ASGNI4
ADDRGP4 $305
JUMPV
LABELV $449
line 942
;942:      else if( !Q_stricmp( token, "static_transform" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $391
ARGP4
ADDRLP4 84
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 84
INDIRI4
CNSTI4 0
NEI4 $451
line 943
;943:        bp->accMoveType = PMT_STATIC_TRANSFORM;
ADDRFP4 0
INDIRP4
CNSTI4 76
ADDP4
CNSTI4 1
ASGNI4
ADDRGP4 $305
JUMPV
LABELV $451
line 944
;944:      else if( !Q_stricmp( token, "tag" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $394
ARGP4
ADDRLP4 88
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 88
INDIRI4
CNSTI4 0
NEI4 $453
line 945
;945:        bp->accMoveType = PMT_TAG;
ADDRFP4 0
INDIRP4
CNSTI4 76
ADDP4
CNSTI4 2
ASGNI4
ADDRGP4 $305
JUMPV
LABELV $453
line 946
;946:      else if( !Q_stricmp( token, "cent" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $397
ARGP4
ADDRLP4 92
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 92
INDIRI4
CNSTI4 0
NEI4 $455
line 947
;947:        bp->accMoveType = PMT_CENT_ANGLES;
ADDRFP4 0
INDIRP4
CNSTI4 76
ADDP4
CNSTI4 3
ASGNI4
ADDRGP4 $305
JUMPV
LABELV $455
line 948
;948:      else if( !Q_stricmp( token, "normal" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $400
ARGP4
ADDRLP4 96
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 96
INDIRI4
CNSTI4 0
NEI4 $305
line 949
;949:        bp->accMoveType = PMT_NORMAL;
ADDRFP4 0
INDIRP4
CNSTI4 76
ADDP4
CNSTI4 4
ASGNI4
line 951
;950:
;951:      continue;
ADDRGP4 $305
JUMPV
LABELV $444
line 953
;952:    }
;953:    else if( !Q_stricmp( token, "accelerationDir" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $461
ARGP4
ADDRLP4 76
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 76
INDIRI4
CNSTI4 0
NEI4 $459
line 954
;954:    {
line 955
;955:      token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 80
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 80
INDIRP4
ASGNP4
line 956
;956:      if( !token )
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $462
line 957
;957:        break;
ADDRGP4 $306
JUMPV
LABELV $462
line 959
;958:
;959:      if( !Q_stricmp( token, "linear" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $408
ARGP4
ADDRLP4 84
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 84
INDIRI4
CNSTI4 0
NEI4 $464
line 960
;960:        bp->accMoveValues.dirType = PMD_LINEAR;
ADDRFP4 0
INDIRP4
CNSTI4 80
ADDP4
CNSTI4 0
ASGNI4
ADDRGP4 $305
JUMPV
LABELV $464
line 961
;961:      else if( !Q_stricmp( token, "point" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $411
ARGP4
ADDRLP4 88
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 88
INDIRI4
CNSTI4 0
NEI4 $305
line 962
;962:        bp->accMoveValues.dirType = PMD_POINT;
ADDRFP4 0
INDIRP4
CNSTI4 80
ADDP4
CNSTI4 1
ASGNI4
line 964
;963:
;964:      continue;
ADDRGP4 $305
JUMPV
LABELV $459
line 966
;965:    }
;966:    else if( !Q_stricmp( token, "accelerationMagnitude" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $470
ARGP4
ADDRLP4 80
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 80
INDIRI4
CNSTI4 0
NEI4 $468
line 967
;967:    {
line 968
;968:      token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 84
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 84
INDIRP4
ASGNP4
line 969
;969:      if( !token )
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $471
line 970
;970:        break;
ADDRGP4 $306
JUMPV
LABELV $471
line 972
;971:
;972:      CG_ParseValueAndVariance( token, &number, &randFrac, qfalse );
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 8
ARGP4
ADDRLP4 4
ARGP4
CNSTI4 0
ARGI4
ADDRGP4 CG_ParseValueAndVariance
CALLV
pop
line 974
;973:
;974:      bp->accMoveValues.mag = number;
ADDRFP4 0
INDIRP4
CNSTI4 116
ADDP4
ADDRLP4 8
INDIRF4
ASGNF4
line 975
;975:      bp->accMoveValues.magRandFrac = randFrac;
ADDRFP4 0
INDIRP4
CNSTI4 120
ADDP4
ADDRLP4 4
INDIRF4
ASGNF4
line 977
;976:
;977:      continue;
ADDRGP4 $305
JUMPV
LABELV $468
line 979
;978:    }
;979:    else if( !Q_stricmp( token, "acceleration" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $475
ARGP4
ADDRLP4 84
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 84
INDIRI4
CNSTI4 0
NEI4 $473
line 980
;980:    {
line 981
;981:      for( i = 0; i <= 2; i++ )
ADDRLP4 12
CNSTI4 0
ASGNI4
LABELV $476
line 982
;982:      {
line 983
;983:        token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 88
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 88
INDIRP4
ASGNP4
line 984
;984:        if( !token )
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $480
line 985
;985:          break;
ADDRGP4 $478
JUMPV
LABELV $480
line 987
;986:
;987:        bp->accMoveValues.dir[ i ] = atof_neg( token, qtrue );
ADDRLP4 0
INDIRP4
ARGP4
CNSTI4 1
ARGI4
ADDRLP4 92
ADDRGP4 atof_neg
CALLF4
ASGNF4
ADDRLP4 12
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
CNSTI4 84
ADDP4
ADDP4
ADDRLP4 92
INDIRF4
ASGNF4
line 988
;988:      }
LABELV $477
line 981
ADDRLP4 12
ADDRLP4 12
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 2
LEI4 $476
LABELV $478
line 990
;989:
;990:      token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 88
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 88
INDIRP4
ASGNP4
line 991
;991:      if( !token )
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $482
line 992
;992:        break;
ADDRGP4 $306
JUMPV
LABELV $482
line 994
;993:
;994:      CG_ParseValueAndVariance( token, NULL, &randFrac, qfalse );
ADDRLP4 0
INDIRP4
ARGP4
CNSTP4 0
ARGP4
ADDRLP4 4
ARGP4
CNSTI4 0
ARGI4
ADDRGP4 CG_ParseValueAndVariance
CALLV
pop
line 996
;995:
;996:      bp->accMoveValues.dirRandAngle = randFrac;
ADDRFP4 0
INDIRP4
CNSTI4 96
ADDP4
ADDRLP4 4
INDIRF4
ASGNF4
line 998
;997:
;998:      continue;
ADDRGP4 $305
JUMPV
LABELV $473
line 1000
;999:    }
;1000:    else if( !Q_stricmp( token, "accelerationPoint" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $486
ARGP4
ADDRLP4 88
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 88
INDIRI4
CNSTI4 0
NEI4 $484
line 1001
;1001:    {
line 1002
;1002:      for( i = 0; i <= 2; i++ )
ADDRLP4 12
CNSTI4 0
ASGNI4
LABELV $487
line 1003
;1003:      {
line 1004
;1004:        token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 92
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 92
INDIRP4
ASGNP4
line 1005
;1005:        if( !token )
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $491
line 1006
;1006:          break;
ADDRGP4 $489
JUMPV
LABELV $491
line 1008
;1007:
;1008:        bp->accMoveValues.point[ i ] = atof_neg( token, qtrue );
ADDRLP4 0
INDIRP4
ARGP4
CNSTI4 1
ARGI4
ADDRLP4 96
ADDRGP4 atof_neg
CALLF4
ASGNF4
ADDRLP4 12
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
CNSTI4 100
ADDP4
ADDP4
ADDRLP4 96
INDIRF4
ASGNF4
line 1009
;1009:      }
LABELV $488
line 1002
ADDRLP4 12
ADDRLP4 12
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 2
LEI4 $487
LABELV $489
line 1011
;1010:
;1011:      token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 92
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 92
INDIRP4
ASGNP4
line 1012
;1012:      if( !token )
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $493
line 1013
;1013:        break;
ADDRGP4 $306
JUMPV
LABELV $493
line 1015
;1014:
;1015:      CG_ParseValueAndVariance( token, NULL, &randFrac, qfalse );
ADDRLP4 0
INDIRP4
ARGP4
CNSTP4 0
ARGP4
ADDRLP4 4
ARGP4
CNSTI4 0
ARGI4
ADDRGP4 CG_ParseValueAndVariance
CALLV
pop
line 1017
;1016:
;1017:      bp->accMoveValues.pointRandAngle = randFrac;
ADDRFP4 0
INDIRP4
CNSTI4 112
ADDP4
ADDRLP4 4
INDIRF4
ASGNF4
line 1019
;1018:
;1019:      continue;
ADDRGP4 $305
JUMPV
LABELV $484
line 1022
;1020:    }
;1021:    ///
;1022:    else if( !Q_stricmp( token, "displacement" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $497
ARGP4
ADDRLP4 92
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 92
INDIRI4
CNSTI4 0
NEI4 $495
line 1023
;1023:    {
line 1024
;1024:      for( i = 0; i <= 2; i++ )
ADDRLP4 12
CNSTI4 0
ASGNI4
LABELV $498
line 1025
;1025:      {
line 1026
;1026:        token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 96
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 96
INDIRP4
ASGNP4
line 1027
;1027:        if( !token )
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $502
line 1028
;1028:          break;
ADDRGP4 $500
JUMPV
LABELV $502
line 1030
;1029:
;1030:        bp->displacement[ i ] = atof_neg( token, qtrue );
ADDRLP4 0
INDIRP4
ARGP4
CNSTI4 1
ARGI4
ADDRLP4 100
ADDRGP4 atof_neg
CALLF4
ASGNF4
ADDRLP4 12
INDIRI4
CNSTI4 2
LSHI4
ADDRFP4 0
INDIRP4
ADDP4
ADDRLP4 100
INDIRF4
ASGNF4
line 1031
;1031:      }
LABELV $499
line 1024
ADDRLP4 12
ADDRLP4 12
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 2
LEI4 $498
LABELV $500
line 1033
;1032:
;1033:      token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 96
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 96
INDIRP4
ASGNP4
line 1034
;1034:      if( !token )
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $504
line 1035
;1035:        break;
ADDRGP4 $306
JUMPV
LABELV $504
line 1037
;1036:
;1037:      CG_ParseValueAndVariance( token, NULL, &randFrac, qfalse );
ADDRLP4 0
INDIRP4
ARGP4
CNSTP4 0
ARGP4
ADDRLP4 4
ARGP4
CNSTI4 0
ARGI4
ADDRGP4 CG_ParseValueAndVariance
CALLV
pop
line 1039
;1038:
;1039:      bp->randDisplacement = randFrac;
ADDRFP4 0
INDIRP4
CNSTI4 12
ADDP4
ADDRLP4 4
INDIRF4
ASGNF4
line 1041
;1040:
;1041:      continue;
ADDRGP4 $305
JUMPV
LABELV $495
line 1043
;1042:    }
;1043:    else if( !Q_stricmp( token, "normalDisplacement" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $508
ARGP4
ADDRLP4 96
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 96
INDIRI4
CNSTI4 0
NEI4 $506
line 1044
;1044:    {
line 1045
;1045:      token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 100
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 100
INDIRP4
ASGNP4
line 1046
;1046:      if( !token )
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $509
line 1047
;1047:        break;
ADDRGP4 $306
JUMPV
LABELV $509
line 1049
;1048:
;1049:      bp->normalDisplacement = atof_neg( token, qtrue );
ADDRLP4 0
INDIRP4
ARGP4
CNSTI4 1
ARGI4
ADDRLP4 104
ADDRGP4 atof_neg
CALLF4
ASGNF4
ADDRFP4 0
INDIRP4
CNSTI4 16
ADDP4
ADDRLP4 104
INDIRF4
ASGNF4
line 1051
;1050:
;1051:      continue;
ADDRGP4 $305
JUMPV
LABELV $506
line 1053
;1052:    }
;1053:    else if( !Q_stricmp( token, "overdrawProtection" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $513
ARGP4
ADDRLP4 100
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 100
INDIRI4
CNSTI4 0
NEI4 $511
line 1054
;1054:    {
line 1055
;1055:      bp->overdrawProtection = qtrue;
ADDRFP4 0
INDIRP4
CNSTI4 3412
ADDP4
CNSTI4 1
ASGNI4
line 1057
;1056:
;1057:      continue;
ADDRGP4 $305
JUMPV
LABELV $511
line 1059
;1058:    }
;1059:    else if( !Q_stricmp( token, "realLight" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $516
ARGP4
ADDRLP4 104
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 104
INDIRI4
CNSTI4 0
NEI4 $514
line 1060
;1060:    {
line 1061
;1061:      bp->realLight = qtrue;
ADDRFP4 0
INDIRP4
CNSTI4 3416
ADDP4
CNSTI4 1
ASGNI4
line 1063
;1062:
;1063:      continue;
ADDRGP4 $305
JUMPV
LABELV $514
line 1065
;1064:    }
;1065:    else if( !Q_stricmp( token, "dynamicLight" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $519
ARGP4
ADDRLP4 108
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 108
INDIRI4
CNSTI4 0
NEI4 $517
line 1066
;1066:    {
line 1067
;1067:      bp->dynamicLight = qtrue;
ADDRFP4 0
INDIRP4
CNSTI4 396
ADDP4
CNSTI4 1
ASGNI4
line 1069
;1068:
;1069:      token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 112
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 112
INDIRP4
ASGNP4
line 1070
;1070:      if( !*token )
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $520
line 1071
;1071:        break;
ADDRGP4 $306
JUMPV
LABELV $520
line 1073
;1072:
;1073:      CG_ParseValueAndVariance( token, &number, &randFrac, qfalse );
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 8
ARGP4
ADDRLP4 4
ARGP4
CNSTI4 0
ARGI4
ADDRGP4 CG_ParseValueAndVariance
CALLV
pop
line 1075
;1074:
;1075:      bp->dLightRadius.delay = (int)number;
ADDRFP4 0
INDIRP4
CNSTI4 400
ADDP4
ADDRLP4 8
INDIRF4
CVFI4 4
ASGNI4
line 1076
;1076:      bp->dLightRadius.delayRandFrac = randFrac;
ADDRFP4 0
INDIRP4
CNSTI4 404
ADDP4
ADDRLP4 4
INDIRF4
ASGNF4
line 1078
;1077:
;1078:      token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 116
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 116
INDIRP4
ASGNP4
line 1079
;1079:      if( !*token )
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $522
line 1080
;1080:        break;
ADDRGP4 $306
JUMPV
LABELV $522
line 1082
;1081:
;1082:      CG_ParseValueAndVariance( token, &number, &randFrac, qfalse );
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 8
ARGP4
ADDRLP4 4
ARGP4
CNSTI4 0
ARGI4
ADDRGP4 CG_ParseValueAndVariance
CALLV
pop
line 1084
;1083:
;1084:      bp->dLightRadius.initial = number;
ADDRFP4 0
INDIRP4
CNSTI4 408
ADDP4
ADDRLP4 8
INDIRF4
ASGNF4
line 1085
;1085:      bp->dLightRadius.initialRandFrac = randFrac;
ADDRFP4 0
INDIRP4
CNSTI4 412
ADDP4
ADDRLP4 4
INDIRF4
ASGNF4
line 1087
;1086:
;1087:      token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 120
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 120
INDIRP4
ASGNP4
line 1088
;1088:      if( !*token )
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $524
line 1089
;1089:        break;
ADDRGP4 $306
JUMPV
LABELV $524
line 1091
;1090:
;1091:      if( !Q_stricmp( token, "-" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $528
ARGP4
ADDRLP4 124
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 124
INDIRI4
CNSTI4 0
NEI4 $526
line 1092
;1092:      {
line 1093
;1093:        bp->dLightRadius.final = PARTICLES_SAME_AS_INITIAL;
ADDRFP4 0
INDIRP4
CNSTI4 416
ADDP4
CNSTF4 3221225472
ASGNF4
line 1094
;1094:        bp->dLightRadius.finalRandFrac = 0.0f;
ADDRFP4 0
INDIRP4
CNSTI4 420
ADDP4
CNSTF4 0
ASGNF4
line 1095
;1095:      }
ADDRGP4 $527
JUMPV
LABELV $526
line 1097
;1096:      else
;1097:      {
line 1098
;1098:        CG_ParseValueAndVariance( token, &number, &randFrac, qfalse );
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 8
ARGP4
ADDRLP4 4
ARGP4
CNSTI4 0
ARGI4
ADDRGP4 CG_ParseValueAndVariance
CALLV
pop
line 1100
;1099:
;1100:        bp->dLightRadius.final = number;
ADDRFP4 0
INDIRP4
CNSTI4 416
ADDP4
ADDRLP4 8
INDIRF4
ASGNF4
line 1101
;1101:        bp->dLightRadius.finalRandFrac = randFrac;
ADDRFP4 0
INDIRP4
CNSTI4 420
ADDP4
ADDRLP4 4
INDIRF4
ASGNF4
line 1102
;1102:      }
LABELV $527
line 1104
;1103:
;1104:      token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 128
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 128
INDIRP4
ASGNP4
line 1105
;1105:      if( !*token )
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $529
line 1106
;1106:        break;
ADDRGP4 $306
JUMPV
LABELV $529
line 1108
;1107:
;1108:      if( !Q_stricmp( token, "{" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $533
ARGP4
ADDRLP4 132
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 132
INDIRI4
CNSTI4 0
NEI4 $305
line 1109
;1109:      {
line 1110
;1110:        if( !CG_ParseColor( bp->dLightColor, text_p ) )
ADDRFP4 0
INDIRP4
CNSTI4 428
ADDP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 136
ADDRGP4 CG_ParseColor
CALLI4
ASGNI4
ADDRLP4 136
INDIRI4
CNSTI4 0
NEI4 $534
line 1111
;1111:          break;
ADDRGP4 $306
JUMPV
LABELV $534
line 1113
;1112:
;1113:        token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 140
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 140
INDIRP4
ASGNP4
line 1114
;1114:        if( Q_stricmp( token, "}" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $538
ARGP4
ADDRLP4 144
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 144
INDIRI4
CNSTI4 0
EQI4 $305
line 1115
;1115:        {
line 1116
;1116:          CG_Printf( S_COLOR_RED "ERROR: missing '}'\n" );
ADDRGP4 $539
ARGP4
ADDRGP4 CG_Printf
CALLV
pop
line 1117
;1117:          break;
ADDRGP4 $306
JUMPV
line 1119
;1118:        }
;1119:      }
line 1121
;1120:
;1121:      continue;
LABELV $517
line 1123
;1122:    }
;1123:    else if( !Q_stricmp( token, "cullOnStartSolid" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $542
ARGP4
ADDRLP4 112
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 112
INDIRI4
CNSTI4 0
NEI4 $540
line 1124
;1124:    {
line 1125
;1125:      bp->cullOnStartSolid = qtrue;
ADDRFP4 0
INDIRP4
CNSTI4 3420
ADDP4
CNSTI4 1
ASGNI4
line 1127
;1126:
;1127:      continue;
ADDRGP4 $305
JUMPV
LABELV $540
line 1129
;1128:    }
;1129:    else if( !Q_stricmp( token, "radius" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $545
ARGP4
ADDRLP4 116
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 116
INDIRI4
CNSTI4 0
NEI4 $543
line 1130
;1130:    {
line 1131
;1131:      token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 120
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 120
INDIRP4
ASGNP4
line 1132
;1132:      if( !token )
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $546
line 1133
;1133:        break;
ADDRGP4 $306
JUMPV
LABELV $546
line 1135
;1134:
;1135:      CG_ParseValueAndVariance( token, &number, &randFrac, qfalse );
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 8
ARGP4
ADDRLP4 4
ARGP4
CNSTI4 0
ARGI4
ADDRGP4 CG_ParseValueAndVariance
CALLV
pop
line 1137
;1136:
;1137:      bp->radius.delay = (int)number;
ADDRFP4 0
INDIRP4
CNSTI4 312
ADDP4
ADDRLP4 8
INDIRF4
CVFI4 4
ASGNI4
line 1138
;1138:      bp->radius.delayRandFrac = randFrac;
ADDRFP4 0
INDIRP4
CNSTI4 316
ADDP4
ADDRLP4 4
INDIRF4
ASGNF4
line 1140
;1139:
;1140:      token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 124
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 124
INDIRP4
ASGNP4
line 1141
;1141:      if( !token )
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $548
line 1142
;1142:        break;
ADDRGP4 $306
JUMPV
LABELV $548
line 1144
;1143:
;1144:      CG_ParseValueAndVariance( token, &number, &randFrac, qfalse );
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 8
ARGP4
ADDRLP4 4
ARGP4
CNSTI4 0
ARGI4
ADDRGP4 CG_ParseValueAndVariance
CALLV
pop
line 1146
;1145:
;1146:      bp->radius.initial = number;
ADDRFP4 0
INDIRP4
CNSTI4 320
ADDP4
ADDRLP4 8
INDIRF4
ASGNF4
line 1147
;1147:      bp->radius.initialRandFrac = randFrac;
ADDRFP4 0
INDIRP4
CNSTI4 324
ADDP4
ADDRLP4 4
INDIRF4
ASGNF4
line 1149
;1148:
;1149:      token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 128
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 128
INDIRP4
ASGNP4
line 1150
;1150:      if( !token )
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $550
line 1151
;1151:        break;
ADDRGP4 $306
JUMPV
LABELV $550
line 1153
;1152:
;1153:      if( !Q_stricmp( token, "-" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $528
ARGP4
ADDRLP4 132
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 132
INDIRI4
CNSTI4 0
NEI4 $552
line 1154
;1154:      {
line 1155
;1155:        bp->radius.final = PARTICLES_SAME_AS_INITIAL;
ADDRFP4 0
INDIRP4
CNSTI4 328
ADDP4
CNSTF4 3221225472
ASGNF4
line 1156
;1156:        bp->radius.finalRandFrac = 0.0f;
ADDRFP4 0
INDIRP4
CNSTI4 332
ADDP4
CNSTF4 0
ASGNF4
line 1157
;1157:      }
ADDRGP4 $305
JUMPV
LABELV $552
line 1159
;1158:      else
;1159:      {
line 1160
;1160:        CG_ParseValueAndVariance( token, &number, &randFrac, qfalse );
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 8
ARGP4
ADDRLP4 4
ARGP4
CNSTI4 0
ARGI4
ADDRGP4 CG_ParseValueAndVariance
CALLV
pop
line 1162
;1161:
;1162:        bp->radius.final = number;
ADDRFP4 0
INDIRP4
CNSTI4 328
ADDP4
ADDRLP4 8
INDIRF4
ASGNF4
line 1163
;1163:        bp->radius.finalRandFrac = randFrac;
ADDRFP4 0
INDIRP4
CNSTI4 332
ADDP4
ADDRLP4 4
INDIRF4
ASGNF4
line 1164
;1164:      }
line 1166
;1165:
;1166:      continue;
ADDRGP4 $305
JUMPV
LABELV $543
line 1168
;1167:    }
;1168:    else if( !Q_stricmp( token, "alpha" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $556
ARGP4
ADDRLP4 120
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 120
INDIRI4
CNSTI4 0
NEI4 $554
line 1169
;1169:    {
line 1170
;1170:      token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 124
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 124
INDIRP4
ASGNP4
line 1171
;1171:      if( !token )
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $557
line 1172
;1172:        break;
ADDRGP4 $306
JUMPV
LABELV $557
line 1174
;1173:
;1174:      CG_ParseValueAndVariance( token, &number, &randFrac, qfalse );
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 8
ARGP4
ADDRLP4 4
ARGP4
CNSTI4 0
ARGI4
ADDRGP4 CG_ParseValueAndVariance
CALLV
pop
line 1176
;1175:
;1176:      bp->alpha.delay = (int)number;
ADDRFP4 0
INDIRP4
CNSTI4 340
ADDP4
ADDRLP4 8
INDIRF4
CVFI4 4
ASGNI4
line 1177
;1177:      bp->alpha.delayRandFrac = randFrac;
ADDRFP4 0
INDIRP4
CNSTI4 344
ADDP4
ADDRLP4 4
INDIRF4
ASGNF4
line 1179
;1178:
;1179:      token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 128
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 128
INDIRP4
ASGNP4
line 1180
;1180:      if( !token )
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $559
line 1181
;1181:        break;
ADDRGP4 $306
JUMPV
LABELV $559
line 1183
;1182:
;1183:      CG_ParseValueAndVariance( token, &number, &randFrac, qfalse );
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 8
ARGP4
ADDRLP4 4
ARGP4
CNSTI4 0
ARGI4
ADDRGP4 CG_ParseValueAndVariance
CALLV
pop
line 1185
;1184:
;1185:      bp->alpha.initial = number;
ADDRFP4 0
INDIRP4
CNSTI4 348
ADDP4
ADDRLP4 8
INDIRF4
ASGNF4
line 1186
;1186:      bp->alpha.initialRandFrac = randFrac;
ADDRFP4 0
INDIRP4
CNSTI4 352
ADDP4
ADDRLP4 4
INDIRF4
ASGNF4
line 1188
;1187:
;1188:      token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 132
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 132
INDIRP4
ASGNP4
line 1189
;1189:      if( !token )
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $561
line 1190
;1190:        break;
ADDRGP4 $306
JUMPV
LABELV $561
line 1192
;1191:
;1192:      if( !Q_stricmp( token, "-" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $528
ARGP4
ADDRLP4 136
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 136
INDIRI4
CNSTI4 0
NEI4 $563
line 1193
;1193:      {
line 1194
;1194:        bp->alpha.final = PARTICLES_SAME_AS_INITIAL;
ADDRFP4 0
INDIRP4
CNSTI4 356
ADDP4
CNSTF4 3221225472
ASGNF4
line 1195
;1195:        bp->alpha.finalRandFrac = 0.0f;
ADDRFP4 0
INDIRP4
CNSTI4 360
ADDP4
CNSTF4 0
ASGNF4
line 1196
;1196:      }
ADDRGP4 $305
JUMPV
LABELV $563
line 1198
;1197:      else
;1198:      {
line 1199
;1199:        CG_ParseValueAndVariance( token, &number, &randFrac, qfalse );
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 8
ARGP4
ADDRLP4 4
ARGP4
CNSTI4 0
ARGI4
ADDRGP4 CG_ParseValueAndVariance
CALLV
pop
line 1201
;1200:
;1201:        bp->alpha.final = number;
ADDRFP4 0
INDIRP4
CNSTI4 356
ADDP4
ADDRLP4 8
INDIRF4
ASGNF4
line 1202
;1202:        bp->alpha.finalRandFrac = randFrac;
ADDRFP4 0
INDIRP4
CNSTI4 360
ADDP4
ADDRLP4 4
INDIRF4
ASGNF4
line 1203
;1203:      }
line 1205
;1204:
;1205:      continue;
ADDRGP4 $305
JUMPV
LABELV $554
line 1207
;1206:    }
;1207:    else if( !Q_stricmp( token, "color" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $567
ARGP4
ADDRLP4 124
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 124
INDIRI4
CNSTI4 0
NEI4 $565
line 1208
;1208:    {
line 1209
;1209:      token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 128
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 128
INDIRP4
ASGNP4
line 1210
;1210:      if( !*token )
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $568
line 1211
;1211:        break;
ADDRGP4 $306
JUMPV
LABELV $568
line 1213
;1212:
;1213:      CG_ParseValueAndVariance( token, &number, &randFrac, qfalse );
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 8
ARGP4
ADDRLP4 4
ARGP4
CNSTI4 0
ARGI4
ADDRGP4 CG_ParseValueAndVariance
CALLV
pop
line 1215
;1214:
;1215:      bp->colorDelay = (int)number;
ADDRFP4 0
INDIRP4
CNSTI4 432
ADDP4
ADDRLP4 8
INDIRF4
CVFI4 4
ASGNI4
line 1216
;1216:      bp->colorDelayRandFrac = randFrac;
ADDRFP4 0
INDIRP4
CNSTI4 436
ADDP4
ADDRLP4 4
INDIRF4
ASGNF4
line 1218
;1217:
;1218:      token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 132
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 132
INDIRP4
ASGNP4
line 1219
;1219:      if( !*token )
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $570
line 1220
;1220:        break;
ADDRGP4 $306
JUMPV
LABELV $570
line 1222
;1221:
;1222:      if( !Q_stricmp( token, "{" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $533
ARGP4
ADDRLP4 136
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 136
INDIRI4
CNSTI4 0
NEI4 $572
line 1223
;1223:      {
line 1224
;1224:        if( !CG_ParseColor( bp->initialColor, text_p ) )
ADDRFP4 0
INDIRP4
CNSTI4 440
ADDP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 140
ADDRGP4 CG_ParseColor
CALLI4
ASGNI4
ADDRLP4 140
INDIRI4
CNSTI4 0
NEI4 $574
line 1225
;1225:          break;
ADDRGP4 $306
JUMPV
LABELV $574
line 1227
;1226:
;1227:        token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 144
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 144
INDIRP4
ASGNP4
line 1228
;1228:        if( Q_stricmp( token, "}" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $538
ARGP4
ADDRLP4 148
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 148
INDIRI4
CNSTI4 0
EQI4 $576
line 1229
;1229:        {
line 1230
;1230:          CG_Printf( S_COLOR_RED "ERROR: missing '}'\n" );
ADDRGP4 $539
ARGP4
ADDRGP4 CG_Printf
CALLV
pop
line 1231
;1231:          break;
ADDRGP4 $306
JUMPV
LABELV $576
line 1234
;1232:        }
;1233:
;1234:        token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 152
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 152
INDIRP4
ASGNP4
line 1235
;1235:        if( !*token )
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $578
line 1236
;1236:          break;
ADDRGP4 $306
JUMPV
LABELV $578
line 1238
;1237:
;1238:        if( !Q_stricmp( token, "-" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $528
ARGP4
ADDRLP4 156
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 156
INDIRI4
CNSTI4 0
NEI4 $580
line 1239
;1239:        {
line 1240
;1240:          bp->finalColor[ 0 ] = bp->initialColor[ 0 ];
ADDRLP4 160
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 160
INDIRP4
CNSTI4 443
ADDP4
ADDRLP4 160
INDIRP4
CNSTI4 440
ADDP4
INDIRU1
ASGNU1
line 1241
;1241:          bp->finalColor[ 1 ] = bp->initialColor[ 1 ];
ADDRLP4 164
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 164
INDIRP4
CNSTI4 444
ADDP4
ADDRLP4 164
INDIRP4
CNSTI4 441
ADDP4
INDIRU1
ASGNU1
line 1242
;1242:          bp->finalColor[ 2 ] = bp->initialColor[ 2 ];
ADDRLP4 168
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 168
INDIRP4
CNSTI4 445
ADDP4
ADDRLP4 168
INDIRP4
CNSTI4 442
ADDP4
INDIRU1
ASGNU1
line 1243
;1243:        }
ADDRGP4 $305
JUMPV
LABELV $580
line 1244
;1244:        else if( !Q_stricmp( token, "{" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $533
ARGP4
ADDRLP4 160
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 160
INDIRI4
CNSTI4 0
NEI4 $582
line 1245
;1245:        {
line 1246
;1246:          if( !CG_ParseColor( bp->finalColor, text_p ) )
ADDRFP4 0
INDIRP4
CNSTI4 443
ADDP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 164
ADDRGP4 CG_ParseColor
CALLI4
ASGNI4
ADDRLP4 164
INDIRI4
CNSTI4 0
NEI4 $584
line 1247
;1247:            break;
ADDRGP4 $306
JUMPV
LABELV $584
line 1249
;1248:
;1249:          token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 168
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 168
INDIRP4
ASGNP4
line 1250
;1250:          if( Q_stricmp( token, "}" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $538
ARGP4
ADDRLP4 172
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 172
INDIRI4
CNSTI4 0
EQI4 $305
line 1251
;1251:          {
line 1252
;1252:            CG_Printf( S_COLOR_RED "ERROR: missing '}'\n" );
ADDRGP4 $539
ARGP4
ADDRGP4 CG_Printf
CALLV
pop
line 1253
;1253:            break;
ADDRGP4 $306
JUMPV
line 1255
;1254:          }
;1255:        }
LABELV $582
line 1257
;1256:        else
;1257:        {
line 1258
;1258:          CG_Printf( S_COLOR_RED "ERROR: missing '{'\n" );
ADDRGP4 $588
ARGP4
ADDRGP4 CG_Printf
CALLV
pop
line 1259
;1259:          break;
ADDRGP4 $306
JUMPV
line 1261
;1260:        }
;1261:      }
LABELV $572
line 1263
;1262:      else
;1263:      {
line 1264
;1264:        CG_Printf( S_COLOR_RED "ERROR: missing '{'\n" );
ADDRGP4 $588
ARGP4
ADDRGP4 CG_Printf
CALLV
pop
line 1265
;1265:        break;
ADDRGP4 $306
JUMPV
line 1268
;1266:      }
;1267:
;1268:      continue;
LABELV $565
line 1270
;1269:    }
;1270:    else if( !Q_stricmp( token, "rotation" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $591
ARGP4
ADDRLP4 128
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 128
INDIRI4
CNSTI4 0
NEI4 $589
line 1271
;1271:    {
line 1272
;1272:      token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 132
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 132
INDIRP4
ASGNP4
line 1273
;1273:      if( !token )
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $592
line 1274
;1274:        break;
ADDRGP4 $306
JUMPV
LABELV $592
line 1276
;1275:
;1276:      CG_ParseValueAndVariance( token, &number, &randFrac, qfalse );
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 8
ARGP4
ADDRLP4 4
ARGP4
CNSTI4 0
ARGI4
ADDRGP4 CG_ParseValueAndVariance
CALLV
pop
line 1278
;1277:
;1278:      bp->rotation.delay = (int)number;
ADDRFP4 0
INDIRP4
CNSTI4 368
ADDP4
ADDRLP4 8
INDIRF4
CVFI4 4
ASGNI4
line 1279
;1279:      bp->rotation.delayRandFrac = randFrac;
ADDRFP4 0
INDIRP4
CNSTI4 372
ADDP4
ADDRLP4 4
INDIRF4
ASGNF4
line 1281
;1280:
;1281:      token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 136
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 136
INDIRP4
ASGNP4
line 1282
;1282:      if( !token )
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $594
line 1283
;1283:        break;
ADDRGP4 $306
JUMPV
LABELV $594
line 1285
;1284:
;1285:      CG_ParseValueAndVariance( token, &number, &randFrac, qtrue );
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 8
ARGP4
ADDRLP4 4
ARGP4
CNSTI4 1
ARGI4
ADDRGP4 CG_ParseValueAndVariance
CALLV
pop
line 1287
;1286:
;1287:      bp->rotation.initial = number;
ADDRFP4 0
INDIRP4
CNSTI4 376
ADDP4
ADDRLP4 8
INDIRF4
ASGNF4
line 1288
;1288:      bp->rotation.initialRandFrac = randFrac;
ADDRFP4 0
INDIRP4
CNSTI4 380
ADDP4
ADDRLP4 4
INDIRF4
ASGNF4
line 1290
;1289:
;1290:      token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 140
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 140
INDIRP4
ASGNP4
line 1291
;1291:      if( !token )
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $596
line 1292
;1292:        break;
ADDRGP4 $306
JUMPV
LABELV $596
line 1294
;1293:
;1294:      if( !Q_stricmp( token, "-" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $528
ARGP4
ADDRLP4 144
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 144
INDIRI4
CNSTI4 0
NEI4 $598
line 1295
;1295:      {
line 1296
;1296:        bp->rotation.final = PARTICLES_SAME_AS_INITIAL;
ADDRFP4 0
INDIRP4
CNSTI4 384
ADDP4
CNSTF4 3221225472
ASGNF4
line 1297
;1297:        bp->rotation.finalRandFrac = 0.0f;
ADDRFP4 0
INDIRP4
CNSTI4 388
ADDP4
CNSTF4 0
ASGNF4
line 1298
;1298:      }
ADDRGP4 $305
JUMPV
LABELV $598
line 1300
;1299:      else
;1300:      {
line 1301
;1301:        CG_ParseValueAndVariance( token, &number, &randFrac, qtrue );
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 8
ARGP4
ADDRLP4 4
ARGP4
CNSTI4 1
ARGI4
ADDRGP4 CG_ParseValueAndVariance
CALLV
pop
line 1303
;1302:
;1303:        bp->rotation.final = number;
ADDRFP4 0
INDIRP4
CNSTI4 384
ADDP4
ADDRLP4 8
INDIRF4
ASGNF4
line 1304
;1304:        bp->rotation.finalRandFrac = randFrac;
ADDRFP4 0
INDIRP4
CNSTI4 388
ADDP4
ADDRLP4 4
INDIRF4
ASGNF4
line 1305
;1305:      }
line 1307
;1306:
;1307:      continue;
ADDRGP4 $305
JUMPV
LABELV $589
line 1309
;1308:    }
;1309:    else if( !Q_stricmp( token, "lifeTime" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $602
ARGP4
ADDRLP4 132
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 132
INDIRI4
CNSTI4 0
NEI4 $600
line 1310
;1310:    {
line 1311
;1311:      token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 136
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 136
INDIRP4
ASGNP4
line 1312
;1312:      if( !token )
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $603
line 1313
;1313:        break;
ADDRGP4 $306
JUMPV
LABELV $603
line 1315
;1314:
;1315:      CG_ParseValueAndVariance( token, &number, &randFrac, qfalse );
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 8
ARGP4
ADDRLP4 4
ARGP4
CNSTI4 0
ARGI4
ADDRGP4 CG_ParseValueAndVariance
CALLV
pop
line 1317
;1316:
;1317:      bp->lifeTime = (int)number;
ADDRFP4 0
INDIRP4
CNSTI4 132
ADDP4
ADDRLP4 8
INDIRF4
CVFI4 4
ASGNI4
line 1318
;1318:      bp->lifeTimeRandFrac = randFrac;
ADDRFP4 0
INDIRP4
CNSTI4 136
ADDP4
ADDRLP4 4
INDIRF4
ASGNF4
line 1320
;1319:
;1320:      continue;
ADDRGP4 $305
JUMPV
LABELV $600
line 1322
;1321:    }
;1322:    else if( !Q_stricmp( token, "childSystem" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $607
ARGP4
ADDRLP4 136
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 136
INDIRI4
CNSTI4 0
NEI4 $605
line 1323
;1323:    {
line 1324
;1324:      token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 140
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 140
INDIRP4
ASGNP4
line 1325
;1325:      if( !token )
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $608
line 1326
;1326:        break;
ADDRGP4 $306
JUMPV
LABELV $608
line 1328
;1327:
;1328:      Q_strncpyz( bp->childSystemName, token, MAX_QPATH );
ADDRFP4 0
INDIRP4
CNSTI4 446
ADDP4
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
CNSTI4 64
ARGI4
ADDRGP4 Q_strncpyz
CALLV
pop
line 1330
;1329:
;1330:      continue;
ADDRGP4 $305
JUMPV
LABELV $605
line 1332
;1331:    }
;1332:    else if( !Q_stricmp( token, "onDeathSystem" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $612
ARGP4
ADDRLP4 140
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 140
INDIRI4
CNSTI4 0
NEI4 $610
line 1333
;1333:    {
line 1334
;1334:      token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 144
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 144
INDIRP4
ASGNP4
line 1335
;1335:      if( !token )
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $613
line 1336
;1336:        break;
ADDRGP4 $306
JUMPV
LABELV $613
line 1338
;1337:
;1338:      Q_strncpyz( bp->onDeathSystemName, token, MAX_QPATH );
ADDRFP4 0
INDIRP4
CNSTI4 516
ADDP4
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
CNSTI4 64
ARGI4
ADDRGP4 Q_strncpyz
CALLV
pop
line 1340
;1339:
;1340:      continue;
ADDRGP4 $305
JUMPV
LABELV $610
line 1342
;1341:    }
;1342:    else if( !Q_stricmp( token, "childTrailSystem" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $617
ARGP4
ADDRLP4 144
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 144
INDIRI4
CNSTI4 0
NEI4 $615
line 1343
;1343:    {
line 1344
;1344:      token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 148
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 148
INDIRP4
ASGNP4
line 1345
;1345:      if( !token )
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $618
line 1346
;1346:        break;
ADDRGP4 $306
JUMPV
LABELV $618
line 1348
;1347:
;1348:      Q_strncpyz( bp->childTrailSystemName, token, MAX_QPATH );
ADDRFP4 0
INDIRP4
CNSTI4 584
ADDP4
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
CNSTI4 64
ARGI4
ADDRGP4 Q_strncpyz
CALLV
pop
line 1350
;1349:
;1350:      continue;
ADDRGP4 $305
JUMPV
LABELV $615
line 1352
;1351:    }
;1352:    else if( !Q_stricmp( token, "}" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $538
ARGP4
ADDRLP4 148
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 148
INDIRI4
CNSTI4 0
NEI4 $620
line 1353
;1353:      return qtrue; //reached the end of this particle
CNSTI4 1
RETI4
ADDRGP4 $303
JUMPV
LABELV $620
line 1355
;1354:    else
;1355:    {
line 1356
;1356:      CG_Printf( S_COLOR_RED "ERROR: unknown token '%s' in particle\n", token );
ADDRGP4 $622
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 CG_Printf
CALLV
pop
line 1357
;1357:      return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $303
JUMPV
LABELV $305
line 650
ADDRGP4 $304
JUMPV
LABELV $306
line 1361
;1358:    }
;1359:  }
;1360:
;1361:  return qfalse;
CNSTI4 0
RETI4
LABELV $303
endproc CG_ParseParticle 176 16
proc CG_InitialiseBaseParticle 0 12
line 1370
;1362:}
;1363:
;1364:/*
;1365:===============
;1366:CG_InitialiseBaseParticle
;1367:===============
;1368:*/
;1369:static void CG_InitialiseBaseParticle( baseParticle_t *bp )
;1370:{
line 1371
;1371:  memset( bp, 0, sizeof( baseParticle_t ) );
ADDRFP4 0
INDIRP4
ARGP4
CNSTI4 0
ARGI4
CNSTI4 3424
ARGI4
ADDRGP4 memset
CALLP4
pop
line 1373
;1372:
;1373:  memset( bp->initialColor, 0xFF, sizeof( bp->initialColor ) );
ADDRFP4 0
INDIRP4
CNSTI4 440
ADDP4
ARGP4
CNSTI4 255
ARGI4
CNSTI4 3
ARGI4
ADDRGP4 memset
CALLP4
pop
line 1374
;1374:  memset( bp->finalColor, 0xFF, sizeof( bp->finalColor ) );
ADDRFP4 0
INDIRP4
CNSTI4 443
ADDP4
ARGP4
CNSTI4 255
ARGI4
CNSTI4 3
ARGI4
ADDRGP4 memset
CALLP4
pop
line 1375
;1375:}
LABELV $623
endproc CG_InitialiseBaseParticle 0 12
proc CG_ParseParticleEjector 56 16
line 1385
;1376:
;1377:/*
;1378:===============
;1379:CG_ParseParticleEjector
;1380:
;1381:Parse a particle ejector section
;1382:===============
;1383:*/
;1384:static qboolean CG_ParseParticleEjector( baseParticleEjector_t *bpe, char **text_p )
;1385:{
ADDRGP4 $626
JUMPV
LABELV $625
line 1391
;1386:  char  *token;
;1387:  float number, randFrac;
;1388:
;1389:  // read optional parameters
;1390:  while( 1 )
;1391:  {
line 1392
;1392:    token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 12
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 12
INDIRP4
ASGNP4
line 1394
;1393:
;1394:    if( !token )
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $628
line 1395
;1395:      break;
ADDRGP4 $627
JUMPV
LABELV $628
line 1397
;1396:
;1397:    if( !Q_stricmp( token, "" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $302
ARGP4
ADDRLP4 16
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 16
INDIRI4
CNSTI4 0
NEI4 $630
line 1398
;1398:      return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $624
JUMPV
LABELV $630
line 1400
;1399:
;1400:    if( !Q_stricmp( token, "{" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $533
ARGP4
ADDRLP4 20
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 20
INDIRI4
CNSTI4 0
NEI4 $632
line 1401
;1401:    {
line 1402
;1402:      CG_InitialiseBaseParticle( &baseParticles[ numBaseParticles ] );
CNSTI4 3424
ADDRGP4 numBaseParticles
INDIRI4
MULI4
ADDRGP4 baseParticles
ADDP4
ARGP4
ADDRGP4 CG_InitialiseBaseParticle
CALLV
pop
line 1404
;1403:
;1404:      if( !CG_ParseParticle( &baseParticles[ numBaseParticles ], text_p ) )
CNSTI4 3424
ADDRGP4 numBaseParticles
INDIRI4
MULI4
ADDRGP4 baseParticles
ADDP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 24
ADDRGP4 CG_ParseParticle
CALLI4
ASGNI4
ADDRLP4 24
INDIRI4
CNSTI4 0
NEI4 $634
line 1405
;1405:      {
line 1406
;1406:        CG_Printf( S_COLOR_RED "ERROR: failed to parse particle\n" );
ADDRGP4 $636
ARGP4
ADDRGP4 CG_Printf
CALLV
pop
line 1407
;1407:        return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $624
JUMPV
LABELV $634
line 1410
;1408:      }
;1409:
;1410:      if( bpe->numParticles == MAX_PARTICLES_PER_EJECTOR )
ADDRFP4 0
INDIRP4
CNSTI4 16
ADDP4
INDIRI4
CNSTI4 4
NEI4 $637
line 1411
;1411:      {
line 1412
;1412:        CG_Printf( S_COLOR_RED "ERROR: ejector has > %d particles\n", MAX_PARTICLES_PER_EJECTOR );
ADDRGP4 $639
ARGP4
CNSTI4 4
ARGI4
ADDRGP4 CG_Printf
CALLV
pop
line 1413
;1413:        return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $624
JUMPV
LABELV $637
line 1415
;1414:      }
;1415:      else if( numBaseParticles == MAX_BASEPARTICLES )
ADDRGP4 numBaseParticles
INDIRI4
CNSTI4 3072
NEI4 $640
line 1416
;1416:      {
line 1417
;1417:        CG_Printf( S_COLOR_RED "ERROR: maximum number of particles (%d) reached\n", MAX_BASEPARTICLES );
ADDRGP4 $642
ARGP4
CNSTI4 3072
ARGI4
ADDRGP4 CG_Printf
CALLV
pop
line 1418
;1418:        return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $624
JUMPV
LABELV $640
line 1421
;1419:      }
;1420:      else
;1421:      {
line 1423
;1422:        //start parsing particles again
;1423:        bpe->particles[ bpe->numParticles ] = &baseParticles[ numBaseParticles ];
ADDRLP4 28
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 28
INDIRP4
CNSTI4 16
ADDP4
INDIRI4
CNSTI4 2
LSHI4
ADDRLP4 28
INDIRP4
ADDP4
CNSTI4 3424
ADDRGP4 numBaseParticles
INDIRI4
MULI4
ADDRGP4 baseParticles
ADDP4
ASGNP4
line 1424
;1424:        bpe->numParticles++;
ADDRLP4 32
ADDRFP4 0
INDIRP4
CNSTI4 16
ADDP4
ASGNP4
ADDRLP4 32
INDIRP4
ADDRLP4 32
INDIRP4
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 1425
;1425:        numBaseParticles++;
ADDRLP4 36
ADDRGP4 numBaseParticles
ASGNP4
ADDRLP4 36
INDIRP4
ADDRLP4 36
INDIRP4
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 1426
;1426:      }
line 1427
;1427:      continue;
ADDRGP4 $626
JUMPV
LABELV $632
line 1429
;1428:    }
;1429:    else if( !Q_stricmp( token, "delay" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $645
ARGP4
ADDRLP4 24
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 24
INDIRI4
CNSTI4 0
NEI4 $643
line 1430
;1430:    {
line 1431
;1431:      token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 28
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 28
INDIRP4
ASGNP4
line 1432
;1432:      if( !token )
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $646
line 1433
;1433:        break;
ADDRGP4 $627
JUMPV
LABELV $646
line 1435
;1434:
;1435:      CG_ParseValueAndVariance( token, &number, &randFrac, qfalse );
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 4
ARGP4
ADDRLP4 8
ARGP4
CNSTI4 0
ARGI4
ADDRGP4 CG_ParseValueAndVariance
CALLV
pop
line 1437
;1436:
;1437:      bpe->eject.delay = (int)number;
ADDRFP4 0
INDIRP4
CNSTI4 20
ADDP4
ADDRLP4 4
INDIRF4
CVFI4 4
ASGNI4
line 1438
;1438:      bpe->eject.delayRandFrac = randFrac;
ADDRFP4 0
INDIRP4
CNSTI4 24
ADDP4
ADDRLP4 8
INDIRF4
ASGNF4
line 1440
;1439:
;1440:      continue;
ADDRGP4 $626
JUMPV
LABELV $643
line 1442
;1441:    }
;1442:    else if( !Q_stricmp( token, "period" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $650
ARGP4
ADDRLP4 28
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 28
INDIRI4
CNSTI4 0
NEI4 $648
line 1443
;1443:    {
line 1444
;1444:      token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 32
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 32
INDIRP4
ASGNP4
line 1445
;1445:      if( !token )
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $651
line 1446
;1446:        break;
ADDRGP4 $627
JUMPV
LABELV $651
line 1448
;1447:
;1448:      bpe->eject.initial = atoi_neg( token, qfalse );
ADDRLP4 0
INDIRP4
ARGP4
CNSTI4 0
ARGI4
ADDRLP4 36
ADDRGP4 atoi_neg
CALLI4
ASGNI4
ADDRFP4 0
INDIRP4
CNSTI4 28
ADDP4
ADDRLP4 36
INDIRI4
CVIF4 4
ASGNF4
line 1450
;1449:
;1450:      token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 40
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 40
INDIRP4
ASGNP4
line 1451
;1451:      if( !token )
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $653
line 1452
;1452:        break;
ADDRGP4 $627
JUMPV
LABELV $653
line 1454
;1453:
;1454:      if( !Q_stricmp( token, "-" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $528
ARGP4
ADDRLP4 44
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 44
INDIRI4
CNSTI4 0
NEI4 $655
line 1455
;1455:        bpe->eject.final = PARTICLES_SAME_AS_INITIAL;
ADDRFP4 0
INDIRP4
CNSTI4 36
ADDP4
CNSTF4 3221225472
ASGNF4
ADDRGP4 $656
JUMPV
LABELV $655
line 1457
;1456:      else
;1457:        bpe->eject.final = atoi_neg( token, qfalse );
ADDRLP4 0
INDIRP4
ARGP4
CNSTI4 0
ARGI4
ADDRLP4 48
ADDRGP4 atoi_neg
CALLI4
ASGNI4
ADDRFP4 0
INDIRP4
CNSTI4 36
ADDP4
ADDRLP4 48
INDIRI4
CVIF4 4
ASGNF4
LABELV $656
line 1459
;1458:
;1459:      token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 52
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 52
INDIRP4
ASGNP4
line 1460
;1460:      if( !token )
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $657
line 1461
;1461:        break;
ADDRGP4 $627
JUMPV
LABELV $657
line 1463
;1462:
;1463:      CG_ParseValueAndVariance( token, NULL, &bpe->eject.randFrac, qfalse );
ADDRLP4 0
INDIRP4
ARGP4
CNSTP4 0
ARGP4
ADDRFP4 0
INDIRP4
CNSTI4 44
ADDP4
ARGP4
CNSTI4 0
ARGI4
ADDRGP4 CG_ParseValueAndVariance
CALLV
pop
line 1465
;1464:
;1465:      continue;
ADDRGP4 $626
JUMPV
LABELV $648
line 1467
;1466:    }
;1467:    else if( !Q_stricmp( token, "count" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $661
ARGP4
ADDRLP4 32
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 32
INDIRI4
CNSTI4 0
NEI4 $659
line 1468
;1468:    {
line 1469
;1469:      token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 36
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 36
INDIRP4
ASGNP4
line 1470
;1470:      if( !token )
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $662
line 1471
;1471:        break;
ADDRGP4 $627
JUMPV
LABELV $662
line 1473
;1472:
;1473:      if( !Q_stricmp( token, "infinite" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $666
ARGP4
ADDRLP4 40
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 40
INDIRI4
CNSTI4 0
NEI4 $664
line 1474
;1474:      {
line 1475
;1475:        bpe->totalParticles = PARTICLES_INFINITE;
ADDRFP4 0
INDIRP4
CNSTI4 48
ADDP4
CNSTI4 -1
ASGNI4
line 1476
;1476:        bpe->totalParticlesRandFrac = 0.0f;
ADDRFP4 0
INDIRP4
CNSTI4 52
ADDP4
CNSTF4 0
ASGNF4
line 1477
;1477:      }
ADDRGP4 $626
JUMPV
LABELV $664
line 1479
;1478:      else
;1479:      {
line 1480
;1480:        CG_ParseValueAndVariance( token, &number, &randFrac, qfalse );
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 4
ARGP4
ADDRLP4 8
ARGP4
CNSTI4 0
ARGI4
ADDRGP4 CG_ParseValueAndVariance
CALLV
pop
line 1482
;1481:
;1482:        bpe->totalParticles = (int)number;
ADDRFP4 0
INDIRP4
CNSTI4 48
ADDP4
ADDRLP4 4
INDIRF4
CVFI4 4
ASGNI4
line 1483
;1483:        bpe->totalParticlesRandFrac = randFrac;
ADDRFP4 0
INDIRP4
CNSTI4 52
ADDP4
ADDRLP4 8
INDIRF4
ASGNF4
line 1484
;1484:      }
line 1486
;1485:
;1486:      continue;
ADDRGP4 $626
JUMPV
LABELV $659
line 1488
;1487:    }
;1488:    else if( !Q_stricmp( token, "particle" ) ) //acceptable text
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $669
ARGP4
ADDRLP4 36
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 36
INDIRI4
CNSTI4 0
NEI4 $667
line 1489
;1489:      continue;
ADDRGP4 $626
JUMPV
LABELV $667
line 1490
;1490:    else if( !Q_stricmp( token, "}" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $538
ARGP4
ADDRLP4 40
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 40
INDIRI4
CNSTI4 0
NEI4 $670
line 1491
;1491:      return qtrue; //reached the end of this particle ejector
CNSTI4 1
RETI4
ADDRGP4 $624
JUMPV
LABELV $670
line 1493
;1492:    else
;1493:    {
line 1494
;1494:      CG_Printf( S_COLOR_RED "ERROR: unknown token '%s' in particle ejector\n", token );
ADDRGP4 $672
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 CG_Printf
CALLV
pop
line 1495
;1495:      return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $624
JUMPV
LABELV $626
line 1390
ADDRGP4 $625
JUMPV
LABELV $627
line 1499
;1496:    }
;1497:  }
;1498:
;1499:  return qfalse;
CNSTI4 0
RETI4
LABELV $624
endproc CG_ParseParticleEjector 56 16
proc CG_ParseParticleSystem 44 12
line 1511
;1500:}
;1501:
;1502:
;1503:/*
;1504:===============
;1505:CG_ParseParticleSystem
;1506:
;1507:Parse a particle system section
;1508:===============
;1509:*/
;1510:static qboolean CG_ParseParticleSystem( baseParticleSystem_t *bps, char **text_p, const char *name )
;1511:{
ADDRGP4 $675
JUMPV
LABELV $674
line 1517
;1512:  char                  *token;
;1513:  baseParticleEjector_t *bpe;
;1514:
;1515:  // read optional parameters
;1516:  while( 1 )
;1517:  {
line 1518
;1518:    token = COM_Parse( text_p );
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 8
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 8
INDIRP4
ASGNP4
line 1520
;1519:
;1520:    if( !token )
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $677
line 1521
;1521:      break;
ADDRGP4 $676
JUMPV
LABELV $677
line 1523
;1522:
;1523:    if( !Q_stricmp( token, "" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $302
ARGP4
ADDRLP4 12
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 0
NEI4 $679
line 1524
;1524:      return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $673
JUMPV
LABELV $679
line 1526
;1525:
;1526:    if( !Q_stricmp( token, "{" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $533
ARGP4
ADDRLP4 16
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 16
INDIRI4
CNSTI4 0
NEI4 $681
line 1527
;1527:    {
line 1528
;1528:      if( !CG_ParseParticleEjector( &baseParticleEjectors[ numBaseParticleEjectors ], text_p ) )
CNSTI4 56
ADDRGP4 numBaseParticleEjectors
INDIRI4
MULI4
ADDRGP4 baseParticleEjectors
ADDP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 20
ADDRGP4 CG_ParseParticleEjector
CALLI4
ASGNI4
ADDRLP4 20
INDIRI4
CNSTI4 0
NEI4 $683
line 1529
;1529:      {
line 1530
;1530:        CG_Printf( S_COLOR_RED "ERROR: failed to parse particle ejector\n" );
ADDRGP4 $685
ARGP4
ADDRGP4 CG_Printf
CALLV
pop
line 1531
;1531:        return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $673
JUMPV
LABELV $683
line 1534
;1532:      }
;1533:
;1534:      bpe = &baseParticleEjectors[ numBaseParticleEjectors ];
ADDRLP4 4
CNSTI4 56
ADDRGP4 numBaseParticleEjectors
INDIRI4
MULI4
ADDRGP4 baseParticleEjectors
ADDP4
ASGNP4
line 1537
;1535:
;1536:      //check for infinite count + zero period
;1537:      if( bpe->totalParticles == PARTICLES_INFINITE &&
ADDRLP4 4
INDIRP4
CNSTI4 48
ADDP4
INDIRI4
CNSTI4 -1
NEI4 $686
ADDRLP4 28
CNSTF4 0
ASGNF4
ADDRLP4 4
INDIRP4
CNSTI4 28
ADDP4
INDIRF4
ADDRLP4 28
INDIRF4
EQF4 $688
ADDRLP4 4
INDIRP4
CNSTI4 36
ADDP4
INDIRF4
ADDRLP4 28
INDIRF4
NEF4 $686
LABELV $688
line 1539
;1538:          ( bpe->eject.initial == 0.0f || bpe->eject.final == 0.0f ) )
;1539:      {
line 1540
;1540:        CG_Printf( S_COLOR_RED "ERROR: ejector with 'count infinite' potentially has zero period\n" );
ADDRGP4 $689
ARGP4
ADDRGP4 CG_Printf
CALLV
pop
line 1541
;1541:        return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $673
JUMPV
LABELV $686
line 1544
;1542:      }
;1543:
;1544:      if( bps->numEjectors == MAX_EJECTORS_PER_SYSTEM )
ADDRFP4 0
INDIRP4
CNSTI4 80
ADDP4
INDIRI4
CNSTI4 4
NEI4 $690
line 1545
;1545:      {
line 1546
;1546:        CG_Printf( S_COLOR_RED "ERROR: particle system has > %d ejectors\n", MAX_EJECTORS_PER_SYSTEM );
ADDRGP4 $692
ARGP4
CNSTI4 4
ARGI4
ADDRGP4 CG_Printf
CALLV
pop
line 1547
;1547:        return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $673
JUMPV
LABELV $690
line 1549
;1548:      }
;1549:      else if( numBaseParticleEjectors == MAX_BASEPARTICLE_EJECTORS )
ADDRGP4 numBaseParticleEjectors
INDIRI4
CNSTI4 768
NEI4 $693
line 1550
;1550:      {
line 1551
;1551:        CG_Printf( S_COLOR_RED "ERROR: maximum number of particle ejectors (%d) reached\n",
ADDRGP4 $695
ARGP4
CNSTI4 768
ARGI4
ADDRGP4 CG_Printf
CALLV
pop
line 1553
;1552:            MAX_BASEPARTICLE_EJECTORS );
;1553:        return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $673
JUMPV
LABELV $693
line 1556
;1554:      }
;1555:      else
;1556:      {
line 1558
;1557:        //start parsing ejectors again
;1558:        bps->ejectors[ bps->numEjectors ] = &baseParticleEjectors[ numBaseParticleEjectors ];
ADDRLP4 32
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 32
INDIRP4
CNSTI4 80
ADDP4
INDIRI4
CNSTI4 2
LSHI4
ADDRLP4 32
INDIRP4
CNSTI4 64
ADDP4
ADDP4
CNSTI4 56
ADDRGP4 numBaseParticleEjectors
INDIRI4
MULI4
ADDRGP4 baseParticleEjectors
ADDP4
ASGNP4
line 1559
;1559:        bps->numEjectors++;
ADDRLP4 36
ADDRFP4 0
INDIRP4
CNSTI4 80
ADDP4
ASGNP4
ADDRLP4 36
INDIRP4
ADDRLP4 36
INDIRP4
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 1560
;1560:        numBaseParticleEjectors++;
ADDRLP4 40
ADDRGP4 numBaseParticleEjectors
ASGNP4
ADDRLP4 40
INDIRP4
ADDRLP4 40
INDIRP4
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 1561
;1561:      }
line 1562
;1562:      continue;
ADDRGP4 $675
JUMPV
LABELV $681
line 1564
;1563:    }
;1564:    else if( !Q_stricmp( token, "thirdPersonOnly" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $698
ARGP4
ADDRLP4 20
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 20
INDIRI4
CNSTI4 0
NEI4 $696
line 1565
;1565:      bps->thirdPersonOnly = qtrue;
ADDRFP4 0
INDIRP4
CNSTI4 84
ADDP4
CNSTI4 1
ASGNI4
ADDRGP4 $697
JUMPV
LABELV $696
line 1566
;1566:    else if( !Q_stricmp( token, "ejector" ) ) //acceptable text
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $701
ARGP4
ADDRLP4 24
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 24
INDIRI4
CNSTI4 0
NEI4 $699
line 1567
;1567:      continue;
ADDRGP4 $675
JUMPV
LABELV $699
line 1568
;1568:    else if( !Q_stricmp( token, "}" ) )
ADDRLP4 0
INDIRP4
ARGP4
ADDRGP4 $538
ARGP4
ADDRLP4 28
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 28
INDIRI4
CNSTI4 0
NEI4 $702
line 1569
;1569:    {
line 1570
;1570:      if( cg_debugParticles.integer >= 1 )
ADDRGP4 cg_debugParticles+12
INDIRI4
CNSTI4 1
LTI4 $704
line 1571
;1571:        CG_Printf( "Parsed particle system %s\n", name );
ADDRGP4 $707
ARGP4
ADDRFP4 8
INDIRP4
ARGP4
ADDRGP4 CG_Printf
CALLV
pop
LABELV $704
line 1573
;1572:
;1573:      return qtrue; //reached the end of this particle system
CNSTI4 1
RETI4
ADDRGP4 $673
JUMPV
LABELV $702
line 1576
;1574:    }
;1575:    else
;1576:    {
line 1577
;1577:      CG_Printf( S_COLOR_RED "ERROR: unknown token '%s' in particle system %s\n", token, bps->name );
ADDRGP4 $708
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRGP4 CG_Printf
CALLV
pop
line 1578
;1578:      return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $673
JUMPV
LABELV $697
line 1580
;1579:    }
;1580:  }
LABELV $675
line 1516
ADDRGP4 $674
JUMPV
LABELV $676
line 1582
;1581:
;1582:  return qfalse;
CNSTI4 0
RETI4
LABELV $673
endproc CG_ParseParticleSystem 44 12
proc CG_ParseParticleFile 32112 12
line 1593
;1583:}
;1584:
;1585:/*
;1586:===============
;1587:CG_ParseParticleFile
;1588:
;1589:Load the particle systems from a particle file
;1590:===============
;1591:*/
;1592:static qboolean CG_ParseParticleFile( const char *fileName )
;1593:{
line 1600
;1594:  char          *text_p;
;1595:  int           i;
;1596:  int           len;
;1597:  char          *token;
;1598:  char          text[ 32000 ];
;1599:  char          psName[ MAX_QPATH ];
;1600:  qboolean      psNameSet = qfalse;
ADDRLP4 72
CNSTI4 0
ASGNI4
line 1604
;1601:  fileHandle_t  f;
;1602:
;1603:  // load the file
;1604:  len = trap_FS_FOpenFile( fileName, &f, FS_READ );
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 32084
ARGP4
CNSTI4 0
ARGI4
ADDRLP4 32088
ADDRGP4 trap_FS_FOpenFile
CALLI4
ASGNI4
ADDRLP4 80
ADDRLP4 32088
INDIRI4
ASGNI4
line 1605
;1605:  if( len <= 0 )
ADDRLP4 80
INDIRI4
CNSTI4 0
GTI4 $710
line 1606
;1606:    return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $709
JUMPV
LABELV $710
line 1608
;1607:
;1608:  if( len >= sizeof( text ) - 1 )
ADDRLP4 80
INDIRI4
CVIU4 4
CNSTU4 31999
LTU4 $712
line 1609
;1609:  {
line 1610
;1610:    CG_Printf( S_COLOR_RED "ERROR: particle file %s too long\n", fileName );
ADDRGP4 $714
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRGP4 CG_Printf
CALLV
pop
line 1611
;1611:    return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $709
JUMPV
LABELV $712
line 1614
;1612:  }
;1613:
;1614:  trap_FS_Read( text, len, f );
ADDRLP4 84
ARGP4
ADDRLP4 80
INDIRI4
ARGI4
ADDRLP4 32084
INDIRI4
ARGI4
ADDRGP4 trap_FS_Read
CALLV
pop
line 1615
;1615:  text[ len ] = 0;
ADDRLP4 80
INDIRI4
ADDRLP4 84
ADDP4
CNSTI1 0
ASGNI1
line 1616
;1616:  trap_FS_FCloseFile( f );
ADDRLP4 32084
INDIRI4
ARGI4
ADDRGP4 trap_FS_FCloseFile
CALLV
pop
line 1619
;1617:
;1618:  // parse the text
;1619:  text_p = text;
ADDRLP4 76
ADDRLP4 84
ASGNP4
ADDRGP4 $716
JUMPV
LABELV $715
line 1623
;1620:
;1621:  // read optional parameters
;1622:  while( 1 )
;1623:  {
line 1624
;1624:    token = COM_Parse( &text_p );
ADDRLP4 76
ARGP4
ADDRLP4 32092
ADDRGP4 COM_Parse
CALLP4
ASGNP4
ADDRLP4 68
ADDRLP4 32092
INDIRP4
ASGNP4
line 1626
;1625:
;1626:    if( !Q_stricmp( token, "" ) )
ADDRLP4 68
INDIRP4
ARGP4
ADDRGP4 $302
ARGP4
ADDRLP4 32096
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 32096
INDIRI4
CNSTI4 0
NEI4 $718
line 1627
;1627:      break;
ADDRGP4 $717
JUMPV
LABELV $718
line 1629
;1628:
;1629:    if( !Q_stricmp( token, "{" ) )
ADDRLP4 68
INDIRP4
ARGP4
ADDRGP4 $533
ARGP4
ADDRLP4 32100
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 32100
INDIRI4
CNSTI4 0
NEI4 $720
line 1630
;1630:    {
line 1631
;1631:      if( psNameSet )
ADDRLP4 72
INDIRI4
CNSTI4 0
EQI4 $722
line 1632
;1632:      {
line 1634
;1633:        //check for name space clashes
;1634:        for( i = 0; i < numBaseParticleSystems; i++ )
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $727
JUMPV
LABELV $724
line 1635
;1635:        {
line 1636
;1636:          if( !Q_stricmp( baseParticleSystems[ i ].name, psName ) )
CNSTI4 92
ADDRLP4 0
INDIRI4
MULI4
ADDRGP4 baseParticleSystems
ADDP4
ARGP4
ADDRLP4 4
ARGP4
ADDRLP4 32104
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 32104
INDIRI4
CNSTI4 0
NEI4 $728
line 1637
;1637:          {
line 1638
;1638:            CG_Printf( S_COLOR_RED "ERROR: a particle system is already named %s\n", psName );
ADDRGP4 $730
ARGP4
ADDRLP4 4
ARGP4
ADDRGP4 CG_Printf
CALLV
pop
line 1639
;1639:            return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $709
JUMPV
LABELV $728
line 1641
;1640:          }
;1641:        }
LABELV $725
line 1634
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $727
ADDRLP4 0
INDIRI4
ADDRGP4 numBaseParticleSystems
INDIRI4
LTI4 $724
line 1643
;1642:
;1643:        Q_strncpyz( baseParticleSystems[ numBaseParticleSystems ].name, psName, MAX_QPATH );
CNSTI4 92
ADDRGP4 numBaseParticleSystems
INDIRI4
MULI4
ADDRGP4 baseParticleSystems
ADDP4
ARGP4
ADDRLP4 4
ARGP4
CNSTI4 64
ARGI4
ADDRGP4 Q_strncpyz
CALLV
pop
line 1645
;1644:
;1645:        if( !CG_ParseParticleSystem( &baseParticleSystems[ numBaseParticleSystems ], &text_p, psName ) )
CNSTI4 92
ADDRGP4 numBaseParticleSystems
INDIRI4
MULI4
ADDRGP4 baseParticleSystems
ADDP4
ARGP4
ADDRLP4 76
ARGP4
ADDRLP4 4
ARGP4
ADDRLP4 32104
ADDRGP4 CG_ParseParticleSystem
CALLI4
ASGNI4
ADDRLP4 32104
INDIRI4
CNSTI4 0
NEI4 $731
line 1646
;1646:        {
line 1647
;1647:          CG_Printf( S_COLOR_RED "ERROR: %s: failed to parse particle system %s\n", fileName, psName );
ADDRGP4 $733
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 4
ARGP4
ADDRGP4 CG_Printf
CALLV
pop
line 1648
;1648:          return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $709
JUMPV
LABELV $731
line 1652
;1649:        }
;1650:
;1651:        //start parsing particle systems again
;1652:        psNameSet = qfalse;
ADDRLP4 72
CNSTI4 0
ASGNI4
line 1654
;1653:
;1654:        if( numBaseParticleSystems == MAX_BASEPARTICLE_SYSTEMS )
ADDRGP4 numBaseParticleSystems
INDIRI4
CNSTI4 192
NEI4 $734
line 1655
;1655:        {
line 1656
;1656:          CG_Printf( S_COLOR_RED "ERROR: maximum number of particle systems (%d) reached\n",
ADDRGP4 $736
ARGP4
CNSTI4 192
ARGI4
ADDRGP4 CG_Printf
CALLV
pop
line 1658
;1657:              MAX_BASEPARTICLE_SYSTEMS );
;1658:          return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $709
JUMPV
LABELV $734
line 1661
;1659:        }
;1660:        else
;1661:          numBaseParticleSystems++;
ADDRLP4 32108
ADDRGP4 numBaseParticleSystems
ASGNP4
ADDRLP4 32108
INDIRP4
ADDRLP4 32108
INDIRP4
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 1663
;1662:
;1663:        continue;
ADDRGP4 $716
JUMPV
LABELV $722
line 1666
;1664:      }
;1665:      else
;1666:      {
line 1667
;1667:        CG_Printf( S_COLOR_RED "ERROR: unamed particle system\n" );
ADDRGP4 $737
ARGP4
ADDRGP4 CG_Printf
CALLV
pop
line 1668
;1668:        return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $709
JUMPV
LABELV $720
line 1672
;1669:      }
;1670:    }
;1671:
;1672:    if( !psNameSet )
ADDRLP4 72
INDIRI4
CNSTI4 0
NEI4 $738
line 1673
;1673:    {
line 1674
;1674:      Q_strncpyz( psName, token, sizeof( psName ) );
ADDRLP4 4
ARGP4
ADDRLP4 68
INDIRP4
ARGP4
CNSTI4 64
ARGI4
ADDRGP4 Q_strncpyz
CALLV
pop
line 1675
;1675:      psNameSet = qtrue;
ADDRLP4 72
CNSTI4 1
ASGNI4
line 1676
;1676:    }
ADDRGP4 $739
JUMPV
LABELV $738
line 1678
;1677:    else
;1678:    {
line 1679
;1679:      CG_Printf( S_COLOR_RED "ERROR: particle system already named\n" );
ADDRGP4 $740
ARGP4
ADDRGP4 CG_Printf
CALLV
pop
line 1680
;1680:      return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $709
JUMPV
LABELV $739
line 1682
;1681:    }
;1682:  }
LABELV $716
line 1622
ADDRGP4 $715
JUMPV
LABELV $717
line 1684
;1683:
;1684:  return qtrue;
CNSTI4 1
RETI4
LABELV $709
endproc CG_ParseParticleFile 32112 12
export CG_LoadParticleSystems
proc CG_LoadParticleSystems 8296 16
line 1696
;1685:}
;1686:
;1687:
;1688:/*
;1689:===============
;1690:CG_LoadParticleSystems
;1691:
;1692:Load particle systems from .particle files
;1693:===============
;1694:*/
;1695:void CG_LoadParticleSystems( void )
;1696:{
line 1703
;1697:  int   i, j, numFiles, fileLen;
;1698:  char  fileList[ MAX_PARTICLE_FILES * MAX_QPATH ];
;1699:  char  fileName[ MAX_QPATH ];
;1700:  char  *filePtr;
;1701:
;1702:  //clear out the old
;1703:  numBaseParticleSystems = 0;
ADDRGP4 numBaseParticleSystems
CNSTI4 0
ASGNI4
line 1704
;1704:  numBaseParticleEjectors = 0;
ADDRGP4 numBaseParticleEjectors
CNSTI4 0
ASGNI4
line 1705
;1705:  numBaseParticles = 0;
ADDRGP4 numBaseParticles
CNSTI4 0
ASGNI4
line 1707
;1706:
;1707:  for( i = 0; i < MAX_BASEPARTICLE_SYSTEMS; i++ )
ADDRLP4 4
CNSTI4 0
ASGNI4
LABELV $742
line 1708
;1708:  {
line 1709
;1709:    baseParticleSystem_t  *bps = &baseParticleSystems[ i ];
ADDRLP4 8276
CNSTI4 92
ADDRLP4 4
INDIRI4
MULI4
ADDRGP4 baseParticleSystems
ADDP4
ASGNP4
line 1710
;1710:    memset( bps, 0, sizeof( baseParticleSystem_t ) );
ADDRLP4 8276
INDIRP4
ARGP4
CNSTI4 0
ARGI4
CNSTI4 92
ARGI4
ADDRGP4 memset
CALLP4
pop
line 1711
;1711:  }
LABELV $743
line 1707
ADDRLP4 4
ADDRLP4 4
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 192
LTI4 $742
line 1713
;1712:
;1713:  for( i = 0; i < MAX_BASEPARTICLE_EJECTORS; i++ )
ADDRLP4 4
CNSTI4 0
ASGNI4
LABELV $746
line 1714
;1714:  {
line 1715
;1715:    baseParticleEjector_t  *bpe = &baseParticleEjectors[ i ];
ADDRLP4 8276
CNSTI4 56
ADDRLP4 4
INDIRI4
MULI4
ADDRGP4 baseParticleEjectors
ADDP4
ASGNP4
line 1716
;1716:    memset( bpe, 0, sizeof( baseParticleEjector_t ) );
ADDRLP4 8276
INDIRP4
ARGP4
CNSTI4 0
ARGI4
CNSTI4 56
ARGI4
ADDRGP4 memset
CALLP4
pop
line 1717
;1717:  }
LABELV $747
line 1713
ADDRLP4 4
ADDRLP4 4
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 768
LTI4 $746
line 1719
;1718:
;1719:  for( i = 0; i < MAX_BASEPARTICLES; i++ )
ADDRLP4 4
CNSTI4 0
ASGNI4
LABELV $750
line 1720
;1720:  {
line 1721
;1721:    baseParticle_t  *bp = &baseParticles[ i ];
ADDRLP4 8276
CNSTI4 3424
ADDRLP4 4
INDIRI4
MULI4
ADDRGP4 baseParticles
ADDP4
ASGNP4
line 1722
;1722:    memset( bp, 0, sizeof( baseParticle_t ) );
ADDRLP4 8276
INDIRP4
ARGP4
CNSTI4 0
ARGI4
CNSTI4 3424
ARGI4
ADDRGP4 memset
CALLP4
pop
line 1723
;1723:  }
LABELV $751
line 1719
ADDRLP4 4
ADDRLP4 4
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 3072
LTI4 $750
line 1727
;1724:
;1725:
;1726:  //and bring in the new
;1727:  numFiles = trap_FS_GetFileList( "scripts", ".particle",
ADDRGP4 $754
ARGP4
ADDRGP4 $755
ARGP4
ADDRLP4 84
ARGP4
CNSTI4 8192
ARGI4
ADDRLP4 8276
ADDRGP4 trap_FS_GetFileList
CALLI4
ASGNI4
ADDRLP4 80
ADDRLP4 8276
INDIRI4
ASGNI4
line 1729
;1728:      fileList, MAX_PARTICLE_FILES * MAX_QPATH );
;1729:  filePtr = fileList;
ADDRLP4 72
ADDRLP4 84
ASGNP4
line 1731
;1730:
;1731:  for( i = 0; i < numFiles; i++, filePtr += fileLen + 1 )
ADDRLP4 4
CNSTI4 0
ASGNI4
ADDRGP4 $759
JUMPV
LABELV $756
line 1732
;1732:  {
line 1733
;1733:    fileLen = strlen( filePtr );
ADDRLP4 72
INDIRP4
ARGP4
ADDRLP4 8280
ADDRGP4 strlen
CALLI4
ASGNI4
ADDRLP4 76
ADDRLP4 8280
INDIRI4
ASGNI4
line 1734
;1734:    strcpy( fileName, "scripts/" );
ADDRLP4 8
ARGP4
ADDRGP4 $760
ARGP4
ADDRGP4 strcpy
CALLP4
pop
line 1735
;1735:    strcat( fileName, filePtr );
ADDRLP4 8
ARGP4
ADDRLP4 72
INDIRP4
ARGP4
ADDRGP4 strcat
CALLP4
pop
line 1736
;1736:    CG_Printf( "...loading '%s'\n", fileName );
ADDRGP4 $761
ARGP4
ADDRLP4 8
ARGP4
ADDRGP4 CG_Printf
CALLV
pop
line 1737
;1737:    CG_ParseParticleFile( fileName );
ADDRLP4 8
ARGP4
ADDRGP4 CG_ParseParticleFile
CALLI4
pop
line 1738
;1738:  }
LABELV $757
line 1731
ADDRLP4 8280
CNSTI4 1
ASGNI4
ADDRLP4 4
ADDRLP4 4
INDIRI4
ADDRLP4 8280
INDIRI4
ADDI4
ASGNI4
ADDRLP4 72
ADDRLP4 76
INDIRI4
ADDRLP4 8280
INDIRI4
ADDI4
ADDRLP4 72
INDIRP4
ADDP4
ASGNP4
LABELV $759
ADDRLP4 4
INDIRI4
ADDRLP4 80
INDIRI4
LTI4 $756
line 1741
;1739:
;1740:  //connect any child systems to their psHandle
;1741:  for( i = 0; i < numBaseParticles; i++ )
ADDRLP4 4
CNSTI4 0
ASGNI4
ADDRGP4 $765
JUMPV
LABELV $762
line 1742
;1742:  {
line 1743
;1743:    baseParticle_t  *bp = &baseParticles[ i ];
ADDRLP4 8284
CNSTI4 3424
ADDRLP4 4
INDIRI4
MULI4
ADDRGP4 baseParticles
ADDP4
ASGNP4
line 1745
;1744:
;1745:    if( bp->childSystemName[ 0 ] )
ADDRLP4 8284
INDIRP4
CNSTI4 446
ADDP4
INDIRI1
CVII4 1
CNSTI4 0
EQI4 $766
line 1746
;1746:    {
line 1748
;1747:      //particle class has a child, resolve the name
;1748:      for( j = 0; j < numBaseParticleSystems; j++ )
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $771
JUMPV
LABELV $768
line 1749
;1749:      {
line 1750
;1750:        baseParticleSystem_t  *bps = &baseParticleSystems[ j ];
ADDRLP4 8288
CNSTI4 92
ADDRLP4 0
INDIRI4
MULI4
ADDRGP4 baseParticleSystems
ADDP4
ASGNP4
line 1752
;1751:
;1752:        if( !Q_stricmp( bps->name, bp->childSystemName ) )
ADDRLP4 8288
INDIRP4
ARGP4
ADDRLP4 8284
INDIRP4
CNSTI4 446
ADDP4
ARGP4
ADDRLP4 8292
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 8292
INDIRI4
CNSTI4 0
NEI4 $772
line 1753
;1753:        {
line 1756
;1754:          //FIXME: add checks for cycles and infinite children
;1755:
;1756:          bp->childSystemHandle = j + 1;
ADDRLP4 8284
INDIRP4
CNSTI4 512
ADDP4
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 1758
;1757:
;1758:          break;
ADDRGP4 $770
JUMPV
LABELV $772
line 1760
;1759:        }
;1760:      }
LABELV $769
line 1748
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $771
ADDRLP4 0
INDIRI4
ADDRGP4 numBaseParticleSystems
INDIRI4
LTI4 $768
LABELV $770
line 1762
;1761:
;1762:      if( j == numBaseParticleSystems )
ADDRLP4 0
INDIRI4
ADDRGP4 numBaseParticleSystems
INDIRI4
NEI4 $774
line 1763
;1763:      {
line 1765
;1764:        //couldn't find named particle system
;1765:        CG_Printf( S_COLOR_YELLOW "WARNING: failed to find child %s\n", bp->childSystemName );
ADDRGP4 $776
ARGP4
ADDRLP4 8284
INDIRP4
CNSTI4 446
ADDP4
ARGP4
ADDRGP4 CG_Printf
CALLV
pop
line 1766
;1766:        bp->childSystemName[ 0 ] = '\0';
ADDRLP4 8284
INDIRP4
CNSTI4 446
ADDP4
CNSTI1 0
ASGNI1
line 1767
;1767:      }
LABELV $774
line 1768
;1768:    }
LABELV $766
line 1770
;1769:
;1770:    if( bp->onDeathSystemName[ 0 ] )
ADDRLP4 8284
INDIRP4
CNSTI4 516
ADDP4
INDIRI1
CVII4 1
CNSTI4 0
EQI4 $777
line 1771
;1771:    {
line 1773
;1772:      //particle class has a child, resolve the name
;1773:      for( j = 0; j < numBaseParticleSystems; j++ )
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $782
JUMPV
LABELV $779
line 1774
;1774:      {
line 1775
;1775:        baseParticleSystem_t  *bps = &baseParticleSystems[ j ];
ADDRLP4 8288
CNSTI4 92
ADDRLP4 0
INDIRI4
MULI4
ADDRGP4 baseParticleSystems
ADDP4
ASGNP4
line 1777
;1776:
;1777:        if( !Q_stricmp( bps->name, bp->onDeathSystemName ) )
ADDRLP4 8288
INDIRP4
ARGP4
ADDRLP4 8284
INDIRP4
CNSTI4 516
ADDP4
ARGP4
ADDRLP4 8292
ADDRGP4 Q_stricmp
CALLI4
ASGNI4
ADDRLP4 8292
INDIRI4
CNSTI4 0
NEI4 $783
line 1778
;1778:        {
line 1781
;1779:          //FIXME: add checks for cycles and infinite children
;1780:
;1781:          bp->onDeathSystemHandle = j + 1;
ADDRLP4 8284
INDIRP4
CNSTI4 580
ADDP4
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 1783
;1782:
;1783:          break;
ADDRGP4 $781
JUMPV
LABELV $783
line 1785
;1784:        }
;1785:      }
LABELV $780
line 1773
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $782
ADDRLP4 0
INDIRI4
ADDRGP4 numBaseParticleSystems
INDIRI4
LTI4 $779
LABELV $781
line 1787
;1786:
;1787:      if( j == numBaseParticleSystems )
ADDRLP4 0
INDIRI4
ADDRGP4 numBaseParticleSystems
INDIRI4
NEI4 $785
line 1788
;1788:      {
line 1790
;1789:        //couldn't find named particle system
;1790:        CG_Printf( S_COLOR_YELLOW "WARNING: failed to find onDeath system %s\n", bp->onDeathSystemName );
ADDRGP4 $787
ARGP4
ADDRLP4 8284
INDIRP4
CNSTI4 516
ADDP4
ARGP4
ADDRGP4 CG_Printf
CALLV
pop
line 1791
;1791:        bp->onDeathSystemName[ 0 ] = '\0';
ADDRLP4 8284
INDIRP4
CNSTI4 516
ADDP4
CNSTI1 0
ASGNI1
line 1792
;1792:      }
LABELV $785
line 1793
;1793:    }
LABELV $777
line 1794
;1794:  }
LABELV $763
line 1741
ADDRLP4 4
ADDRLP4 4
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $765
ADDRLP4 4
INDIRI4
ADDRGP4 numBaseParticles
INDIRI4
LTI4 $762
line 1795
;1795:}
LABELV $741
endproc CG_LoadParticleSystems 8296 16
export CG_SetParticleSystemNormal
proc CG_SetParticleSystemNormal 4 4
line 1803
;1796:
;1797:/*
;1798:===============
;1799:CG_SetParticleSystemNormal
;1800:===============
;1801:*/
;1802:void CG_SetParticleSystemNormal( particleSystem_t *ps, vec3_t normal )
;1803:{
line 1804
;1804:  if( ps == NULL || !ps->valid )
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 0
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $791
ADDRLP4 0
INDIRP4
CNSTI4 1384
ADDP4
INDIRI4
CNSTI4 0
NEI4 $789
LABELV $791
line 1805
;1805:  {
line 1806
;1806:    CG_Printf( S_COLOR_YELLOW "WARNING: tried to modify a NULL particle system\n" );
ADDRGP4 $792
ARGP4
ADDRGP4 CG_Printf
CALLV
pop
line 1807
;1807:    return;
ADDRGP4 $788
JUMPV
LABELV $789
line 1810
;1808:  }
;1809:
;1810:  ps->normalValid = qtrue;
ADDRFP4 0
INDIRP4
CNSTI4 1392
ADDP4
CNSTI4 1
ASGNI4
line 1811
;1811:  VectorCopy( normal, ps->normal );
ADDRFP4 0
INDIRP4
CNSTI4 1396
ADDP4
ADDRFP4 4
INDIRP4
INDIRB
ASGNB 12
line 1812
;1812:  VectorNormalize( ps->normal );
ADDRFP4 0
INDIRP4
CNSTI4 1396
ADDP4
ARGP4
ADDRGP4 VectorNormalize
CALLF4
pop
line 1813
;1813:}
LABELV $788
endproc CG_SetParticleSystemNormal 4 4
export CG_DestroyParticleSystem
proc CG_DestroyParticleSystem 24 4
line 1830
;1814:
;1815:
;1816:/*
;1817:===============
;1818:CG_DestroyParticleSystem
;1819:
;1820:Destroy a particle system
;1821:
;1822:This doesn't actually invalidate anything, it just stops
;1823:particle ejectors from producing new particles so the
;1824:garbage collector will eventually remove this system.
;1825:However is does set the pointer to NULL so the user is
;1826:unable to manipulate this particle system any longer.
;1827:===============
;1828:*/
;1829:void CG_DestroyParticleSystem( particleSystem_t **ps )
;1830:{
line 1834
;1831:  int               i;
;1832:  particleEjector_t *pe;
;1833:
;1834:  if( *ps == NULL || !(*ps)->valid )
ADDRLP4 8
ADDRFP4 0
INDIRP4
INDIRP4
ASGNP4
ADDRLP4 8
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $796
ADDRLP4 8
INDIRP4
CNSTI4 1384
ADDP4
INDIRI4
CNSTI4 0
NEI4 $794
LABELV $796
line 1835
;1835:  {
line 1836
;1836:    CG_Printf( S_COLOR_YELLOW "WARNING: tried to destroy a NULL particle system\n" );
ADDRGP4 $797
ARGP4
ADDRGP4 CG_Printf
CALLV
pop
line 1837
;1837:    return;
ADDRGP4 $793
JUMPV
LABELV $794
line 1840
;1838:  }
;1839:
;1840:  if( cg_debugParticles.integer >= 1 )
ADDRGP4 cg_debugParticles+12
INDIRI4
CNSTI4 1
LTI4 $798
line 1841
;1841:    CG_Printf( "PS destroyed\n" );
ADDRGP4 $801
ARGP4
ADDRGP4 CG_Printf
CALLV
pop
LABELV $798
line 1843
;1842:
;1843:  for( i = 0; i < MAX_PARTICLE_EJECTORS; i++ )
ADDRLP4 4
CNSTI4 0
ASGNI4
LABELV $802
line 1844
;1844:  {
line 1845
;1845:    pe = &particleEjectors[ i ];
ADDRLP4 0
CNSTI4 52
ADDRLP4 4
INDIRI4
MULI4
ADDRGP4 particleEjectors
ADDP4
ASGNP4
line 1847
;1846:
;1847:    if( pe->valid && pe->parent == *ps )
ADDRLP4 0
INDIRP4
CNSTI4 48
ADDP4
INDIRI4
CNSTI4 0
EQI4 $806
ADDRLP4 0
INDIRP4
CNSTI4 4
ADDP4
INDIRP4
CVPU4 4
ADDRFP4 0
INDIRP4
INDIRP4
CVPU4 4
NEU4 $806
line 1848
;1848:      pe->totalParticles = pe->count = 0;
ADDRLP4 20
CNSTI4 0
ASGNI4
ADDRLP4 0
INDIRP4
CNSTI4 36
ADDP4
ADDRLP4 20
INDIRI4
ASGNI4
ADDRLP4 0
INDIRP4
CNSTI4 40
ADDP4
ADDRLP4 20
INDIRI4
ASGNI4
LABELV $806
line 1849
;1849:  }
LABELV $803
line 1843
ADDRLP4 4
ADDRLP4 4
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 192
LTI4 $802
line 1851
;1850:
;1851:  *ps = NULL;
ADDRFP4 0
INDIRP4
CNSTP4 0
ASGNP4
line 1852
;1852:}
LABELV $793
endproc CG_DestroyParticleSystem 24 4
export CG_IsParticleSystemInfinite
proc CG_IsParticleSystemInfinite 12 4
line 1862
;1853:
;1854:/*
;1855:===============
;1856:CG_IsParticleSystemInfinite
;1857:
;1858:Test a particle system for 'count infinite' ejectors
;1859:===============
;1860:*/
;1861:qboolean CG_IsParticleSystemInfinite( particleSystem_t *ps )
;1862:{
line 1866
;1863:  int               i;
;1864:  particleEjector_t *pe;
;1865:
;1866:  if( ps == NULL )
ADDRFP4 0
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $809
line 1867
;1867:  {
line 1868
;1868:    CG_Printf( S_COLOR_YELLOW "WARNING: tried to test a NULL particle system\n" );
ADDRGP4 $811
ARGP4
ADDRGP4 CG_Printf
CALLV
pop
line 1869
;1869:    return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $808
JUMPV
LABELV $809
line 1872
;1870:  }
;1871:
;1872:  if( !ps->valid )
ADDRFP4 0
INDIRP4
CNSTI4 1384
ADDP4
INDIRI4
CNSTI4 0
NEI4 $812
line 1873
;1873:  {
line 1874
;1874:    CG_Printf( S_COLOR_YELLOW "WARNING: tried to test an invalid particle system\n" );
ADDRGP4 $814
ARGP4
ADDRGP4 CG_Printf
CALLV
pop
line 1875
;1875:    return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $808
JUMPV
LABELV $812
line 1879
;1876:  }
;1877:
;1878:  //don't bother checking already invalid systems
;1879:  if( !ps->valid )
ADDRFP4 0
INDIRP4
CNSTI4 1384
ADDP4
INDIRI4
CNSTI4 0
NEI4 $815
line 1880
;1880:    return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $808
JUMPV
LABELV $815
line 1882
;1881:
;1882:  for( i = 0; i < MAX_PARTICLE_EJECTORS; i++ )
ADDRLP4 4
CNSTI4 0
ASGNI4
LABELV $817
line 1883
;1883:  {
line 1884
;1884:    pe = &particleEjectors[ i ];
ADDRLP4 0
CNSTI4 52
ADDRLP4 4
INDIRI4
MULI4
ADDRGP4 particleEjectors
ADDP4
ASGNP4
line 1886
;1885:
;1886:    if( pe->valid && pe->parent == ps )
ADDRLP4 0
INDIRP4
CNSTI4 48
ADDP4
INDIRI4
CNSTI4 0
EQI4 $821
ADDRLP4 0
INDIRP4
CNSTI4 4
ADDP4
INDIRP4
CVPU4 4
ADDRFP4 0
INDIRP4
CVPU4 4
NEU4 $821
line 1887
;1887:    {
line 1888
;1888:      if( pe->totalParticles == PARTICLES_INFINITE )
ADDRLP4 0
INDIRP4
CNSTI4 40
ADDP4
INDIRI4
CNSTI4 -1
NEI4 $823
line 1889
;1889:        return qtrue;
CNSTI4 1
RETI4
ADDRGP4 $808
JUMPV
LABELV $823
line 1890
;1890:    }
LABELV $821
line 1891
;1891:  }
LABELV $818
line 1882
ADDRLP4 4
ADDRLP4 4
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 192
LTI4 $817
line 1893
;1892:
;1893:  return qfalse;
CNSTI4 0
RETI4
LABELV $808
endproc CG_IsParticleSystemInfinite 12 4
export CG_IsParticleSystemValid
proc CG_IsParticleSystemValid 16 0
line 1904
;1894:}
;1895:
;1896:/*
;1897:===============
;1898:CG_IsParticleSystemValid
;1899:
;1900:Test a particle system for validity
;1901:===============
;1902:*/
;1903:qboolean CG_IsParticleSystemValid( particleSystem_t **ps )
;1904:{
line 1905
;1905:  if( *ps == NULL || ( *ps && !(*ps)->valid ) )
ADDRLP4 0
ADDRFP4 0
INDIRP4
INDIRP4
ASGNP4
ADDRLP4 4
ADDRLP4 0
INDIRP4
CVPU4 4
ASGNU4
ADDRLP4 8
CNSTU4 0
ASGNU4
ADDRLP4 4
INDIRU4
ADDRLP4 8
INDIRU4
EQU4 $828
ADDRLP4 4
INDIRU4
ADDRLP4 8
INDIRU4
EQU4 $826
ADDRLP4 0
INDIRP4
CNSTI4 1384
ADDP4
INDIRI4
CNSTI4 0
NEI4 $826
LABELV $828
line 1906
;1906:  {
line 1907
;1907:    if( *ps && !(*ps)->valid )
ADDRLP4 12
ADDRFP4 0
INDIRP4
INDIRP4
ASGNP4
ADDRLP4 12
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $829
ADDRLP4 12
INDIRP4
CNSTI4 1384
ADDP4
INDIRI4
CNSTI4 0
NEI4 $829
line 1908
;1908:      *ps = NULL;
ADDRFP4 0
INDIRP4
CNSTP4 0
ASGNP4
LABELV $829
line 1910
;1909:
;1910:    return qfalse;
CNSTI4 0
RETI4
ADDRGP4 $825
JUMPV
LABELV $826
line 1913
;1911:  }
;1912:
;1913:  return qtrue;
CNSTI4 1
RETI4
LABELV $825
endproc CG_IsParticleSystemValid 16 0
proc CG_GarbageCollectParticleSystems 28 8
line 1924
;1914:}
;1915:
;1916:/*
;1917:===============
;1918:CG_GarbageCollectParticleSystems
;1919:
;1920:Destroy inactive particle systems
;1921:===============
;1922:*/
;1923:static void CG_GarbageCollectParticleSystems( void )
;1924:{
line 1930
;1925:  int               i, j, count;
;1926:  particleSystem_t  *ps;
;1927:  particleEjector_t *pe;
;1928:  int               centNum;
;1929:
;1930:  for( i = 0; i < MAX_PARTICLE_SYSTEMS; i++ )
ADDRLP4 16
CNSTI4 0
ASGNI4
LABELV $832
line 1931
;1931:  {
line 1932
;1932:    ps = &particleSystems[ i ];
ADDRLP4 8
CNSTI4 1408
ADDRLP4 16
INDIRI4
MULI4
ADDRGP4 particleSystems
ADDP4
ASGNP4
line 1933
;1933:    count = 0;
ADDRLP4 12
CNSTI4 0
ASGNI4
line 1936
;1934:
;1935:    //don't bother checking already invalid systems
;1936:    if( !ps->valid )
ADDRLP4 8
INDIRP4
CNSTI4 1384
ADDP4
INDIRI4
CNSTI4 0
NEI4 $836
line 1937
;1937:      continue;
ADDRGP4 $833
JUMPV
LABELV $836
line 1939
;1938:
;1939:    for( j = 0; j < MAX_PARTICLE_EJECTORS; j++ )
ADDRLP4 0
CNSTI4 0
ASGNI4
LABELV $838
line 1940
;1940:    {
line 1941
;1941:      pe = &particleEjectors[ j ];
ADDRLP4 4
CNSTI4 52
ADDRLP4 0
INDIRI4
MULI4
ADDRGP4 particleEjectors
ADDP4
ASGNP4
line 1943
;1942:
;1943:      if( pe->valid && pe->parent == ps )
ADDRLP4 4
INDIRP4
CNSTI4 48
ADDP4
INDIRI4
CNSTI4 0
EQI4 $842
ADDRLP4 4
INDIRP4
CNSTI4 4
ADDP4
INDIRP4
CVPU4 4
ADDRLP4 8
INDIRP4
CVPU4 4
NEU4 $842
line 1944
;1944:        count++;
ADDRLP4 12
ADDRLP4 12
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $842
line 1945
;1945:    }
LABELV $839
line 1939
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 192
LTI4 $838
line 1947
;1946:
;1947:    if( !count )
ADDRLP4 12
INDIRI4
CNSTI4 0
NEI4 $844
line 1948
;1948:      ps->valid = qfalse;
ADDRLP4 8
INDIRP4
CNSTI4 1384
ADDP4
CNSTI4 0
ASGNI4
LABELV $844
line 1952
;1949:
;1950:    //check systems where the parent cent has left the PVS
;1951:    //( local player entity is always valid )
;1952:    if( ( centNum = CG_AttachmentCentNum( &ps->attachment ) ) >= 0 &&
ADDRLP4 8
INDIRP4
CNSTI4 4
ADDP4
ARGP4
ADDRLP4 24
ADDRGP4 CG_AttachmentCentNum
CALLI4
ASGNI4
ADDRLP4 20
ADDRLP4 24
INDIRI4
ASGNI4
ADDRLP4 24
INDIRI4
CNSTI4 0
LTI4 $846
ADDRLP4 20
INDIRI4
ADDRGP4 cg+36
INDIRP4
CNSTI4 184
ADDP4
INDIRI4
EQI4 $846
line 1954
;1953:        centNum != cg.snap->ps.clientNum )
;1954:    {
line 1955
;1955:      if( !cg_entities[ centNum ].valid )
CNSTI4 1724
ADDRLP4 20
INDIRI4
MULI4
ADDRGP4 cg_entities+1712
ADDP4
INDIRI4
CNSTI4 0
NEI4 $849
line 1956
;1956:        ps->lazyRemove = qtrue;
ADDRLP4 8
INDIRP4
CNSTI4 1388
ADDP4
CNSTI4 1
ASGNI4
LABELV $849
line 1957
;1957:    }
LABELV $846
line 1959
;1958:
;1959:    if( cg_debugParticles.integer >= 1 && !ps->valid )
ADDRGP4 cg_debugParticles+12
INDIRI4
CNSTI4 1
LTI4 $852
ADDRLP4 8
INDIRP4
CNSTI4 1384
ADDP4
INDIRI4
CNSTI4 0
NEI4 $852
line 1960
;1960:      CG_Printf( "PS %s garbage collected\n", ps->class->name );
ADDRGP4 $855
ARGP4
ADDRLP4 8
INDIRP4
INDIRP4
ARGP4
ADDRGP4 CG_Printf
CALLV
pop
LABELV $852
line 1961
;1961:  }
LABELV $833
line 1930
ADDRLP4 16
ADDRLP4 16
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 16
INDIRI4
CNSTI4 48
LTI4 $832
line 1962
;1962:}
LABELV $831
endproc CG_GarbageCollectParticleSystems 28 8
proc CG_CalculateTimeFrac 8 0
line 1973
;1963:
;1964:
;1965:/*
;1966:===============
;1967:CG_CalculateTimeFrac
;1968:
;1969:Calculate the fraction of time passed
;1970:===============
;1971:*/
;1972:static float CG_CalculateTimeFrac( int birth, int life, int delay )
;1973:{
line 1976
;1974:  float frac;
;1975:
;1976:  frac = ( (float)cg.time - (float)( birth + delay ) ) / (float)( life - delay );
ADDRLP4 4
ADDRFP4 8
INDIRI4
ASGNI4
ADDRLP4 0
ADDRGP4 cg+107604
INDIRI4
CVIF4 4
ADDRFP4 0
INDIRI4
ADDRLP4 4
INDIRI4
ADDI4
CVIF4 4
SUBF4
ADDRFP4 4
INDIRI4
ADDRLP4 4
INDIRI4
SUBI4
CVIF4 4
DIVF4
ASGNF4
line 1978
;1977:
;1978:  if( frac < 0.0f )
ADDRLP4 0
INDIRF4
CNSTF4 0
GEF4 $858
line 1979
;1979:    frac = 0.0f;
ADDRLP4 0
CNSTF4 0
ASGNF4
ADDRGP4 $859
JUMPV
LABELV $858
line 1980
;1980:  else if( frac > 1.0f )
ADDRLP4 0
INDIRF4
CNSTF4 1065353216
LEF4 $860
line 1981
;1981:    frac = 1.0f;
ADDRLP4 0
CNSTF4 1065353216
ASGNF4
LABELV $860
LABELV $859
line 1983
;1982:
;1983:  return frac;
ADDRLP4 0
INDIRF4
RETF4
LABELV $856
endproc CG_CalculateTimeFrac 8 0
proc CG_EvaluateParticlePhysics 300 44
line 1994
;1984:}
;1985:
;1986:/*
;1987:===============
;1988:CG_EvaluateParticlePhysics
;1989:
;1990:Compute the physics on a specific particle
;1991:===============
;1992:*/
;1993:static void CG_EvaluateParticlePhysics( particle_t *p )
;1994:{
line 1995
;1995:  particleSystem_t  *ps = p->parent->parent;
ADDRLP4 168
CNSTI4 4
ASGNI4
ADDRLP4 128
ADDRFP4 0
INDIRP4
ADDRLP4 168
INDIRI4
ADDP4
INDIRP4
ADDRLP4 168
INDIRI4
ADDP4
INDIRP4
ASGNP4
line 1996
;1996:  baseParticle_t    *bp = p->class;
ADDRLP4 0
ADDRFP4 0
INDIRP4
INDIRP4
ASGNP4
line 2003
;1997:  vec3_t            acceleration, newOrigin;
;1998:  vec3_t            mins, maxs;
;1999:  float             deltaTime, bounce, radius, dot;
;2000:  trace_t           trace;
;2001:  vec3_t            transform[ 3 ];
;2002:
;2003:  if( p->atRest )
ADDRFP4 0
INDIRP4
CNSTI4 28
ADDP4
INDIRI4
CNSTI4 0
EQI4 $863
line 2004
;2004:  {
line 2005
;2005:    VectorClear( p->velocity );
ADDRLP4 172
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 176
CNSTF4 0
ASGNF4
ADDRLP4 172
INDIRP4
CNSTI4 52
ADDP4
ADDRLP4 176
INDIRF4
ASGNF4
ADDRLP4 172
INDIRP4
CNSTI4 48
ADDP4
ADDRLP4 176
INDIRF4
ASGNF4
ADDRLP4 172
INDIRP4
CNSTI4 44
ADDP4
ADDRLP4 176
INDIRF4
ASGNF4
line 2006
;2006:    return;
ADDRGP4 $862
JUMPV
LABELV $863
line 2009
;2007:  }
;2008:
;2009:  switch( bp->accMoveType )
ADDRLP4 172
ADDRLP4 0
INDIRP4
CNSTI4 76
ADDP4
INDIRI4
ASGNI4
ADDRLP4 172
INDIRI4
CNSTI4 0
LTI4 $865
ADDRLP4 172
INDIRI4
CNSTI4 4
GTI4 $865
ADDRLP4 172
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 $902
ADDP4
INDIRP4
JUMPV
lit
align 4
LABELV $902
address $868
address $875
address $886
address $886
address $899
code
line 2010
;2010:  {
LABELV $868
line 2012
;2011:    case PMT_STATIC:
;2012:      if( bp->accMoveValues.dirType == PMD_POINT )
ADDRLP4 0
INDIRP4
CNSTI4 80
ADDP4
INDIRI4
CNSTI4 1
NEI4 $869
line 2013
;2013:        VectorSubtract( bp->accMoveValues.point, p->origin, acceleration );
ADDRLP4 184
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 64
ADDRLP4 0
INDIRP4
CNSTI4 100
ADDP4
INDIRF4
ADDRLP4 184
INDIRP4
CNSTI4 32
ADDP4
INDIRF4
SUBF4
ASGNF4
ADDRLP4 64+4
ADDRLP4 0
INDIRP4
CNSTI4 104
ADDP4
INDIRF4
ADDRLP4 184
INDIRP4
CNSTI4 36
ADDP4
INDIRF4
SUBF4
ASGNF4
ADDRLP4 64+8
ADDRLP4 0
INDIRP4
CNSTI4 108
ADDP4
INDIRF4
ADDRFP4 0
INDIRP4
CNSTI4 40
ADDP4
INDIRF4
SUBF4
ASGNF4
ADDRGP4 $866
JUMPV
LABELV $869
line 2014
;2014:      else if( bp->accMoveValues.dirType == PMD_LINEAR )
ADDRLP4 0
INDIRP4
CNSTI4 80
ADDP4
INDIRI4
CNSTI4 0
NEI4 $866
line 2015
;2015:        VectorCopy( bp->accMoveValues.dir, acceleration );
ADDRLP4 64
ADDRLP4 0
INDIRP4
CNSTI4 84
ADDP4
INDIRB
ASGNB 12
line 2017
;2016:
;2017:      break;
ADDRGP4 $866
JUMPV
LABELV $875
line 2020
;2018:
;2019:    case PMT_STATIC_TRANSFORM:
;2020:      if( !CG_AttachmentAxis( &ps->attachment, transform ) )
ADDRLP4 128
INDIRP4
CNSTI4 4
ADDP4
ARGP4
ADDRLP4 132
ARGP4
ADDRLP4 188
ADDRGP4 CG_AttachmentAxis
CALLI4
ASGNI4
ADDRLP4 188
INDIRI4
CNSTI4 0
NEI4 $876
line 2021
;2021:        return;
ADDRGP4 $862
JUMPV
LABELV $876
line 2023
;2022:
;2023:      if( bp->accMoveValues.dirType == PMD_POINT )
ADDRLP4 0
INDIRP4
CNSTI4 80
ADDP4
INDIRI4
CNSTI4 1
NEI4 $878
line 2024
;2024:      {
line 2027
;2025:        vec3_t transPoint;
;2026:
;2027:        VectorMatrixMultiply( bp->accMoveValues.point, transform, transPoint );
ADDRLP4 0
INDIRP4
CNSTI4 100
ADDP4
ARGP4
ADDRLP4 132
ARGP4
ADDRLP4 192
ARGP4
ADDRGP4 VectorMatrixMultiply
CALLV
pop
line 2028
;2028:        VectorSubtract( transPoint, p->origin, acceleration );
ADDRLP4 204
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 64
ADDRLP4 192
INDIRF4
ADDRLP4 204
INDIRP4
CNSTI4 32
ADDP4
INDIRF4
SUBF4
ASGNF4
ADDRLP4 64+4
ADDRLP4 192+4
INDIRF4
ADDRLP4 204
INDIRP4
CNSTI4 36
ADDP4
INDIRF4
SUBF4
ASGNF4
ADDRLP4 64+8
ADDRLP4 192+8
INDIRF4
ADDRFP4 0
INDIRP4
CNSTI4 40
ADDP4
INDIRF4
SUBF4
ASGNF4
line 2029
;2029:      }
ADDRGP4 $866
JUMPV
LABELV $878
line 2030
;2030:      else if( bp->accMoveValues.dirType == PMD_LINEAR )
ADDRLP4 0
INDIRP4
CNSTI4 80
ADDP4
INDIRI4
CNSTI4 0
NEI4 $866
line 2031
;2031:        VectorMatrixMultiply( bp->accMoveValues.dir, transform, acceleration );
ADDRLP4 0
INDIRP4
CNSTI4 84
ADDP4
ARGP4
ADDRLP4 132
ARGP4
ADDRLP4 64
ARGP4
ADDRGP4 VectorMatrixMultiply
CALLV
pop
line 2032
;2032:      break;
ADDRGP4 $866
JUMPV
LABELV $886
line 2036
;2033:
;2034:    case PMT_TAG:
;2035:    case PMT_CENT_ANGLES:
;2036:      if( bp->accMoveValues.dirType == PMD_POINT )
ADDRLP4 0
INDIRP4
CNSTI4 80
ADDP4
INDIRI4
CNSTI4 1
NEI4 $887
line 2037
;2037:      {
line 2040
;2038:        vec3_t point;
;2039:
;2040:        if( !CG_AttachmentPoint( &ps->attachment, point ) )
ADDRLP4 128
INDIRP4
CNSTI4 4
ADDP4
ARGP4
ADDRLP4 192
ARGP4
ADDRLP4 204
ADDRGP4 CG_AttachmentPoint
CALLI4
ASGNI4
ADDRLP4 204
INDIRI4
CNSTI4 0
NEI4 $889
line 2041
;2041:          return;
ADDRGP4 $862
JUMPV
LABELV $889
line 2043
;2042:
;2043:        VectorSubtract( point, p->origin, acceleration );
ADDRLP4 208
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 64
ADDRLP4 192
INDIRF4
ADDRLP4 208
INDIRP4
CNSTI4 32
ADDP4
INDIRF4
SUBF4
ASGNF4
ADDRLP4 64+4
ADDRLP4 192+4
INDIRF4
ADDRLP4 208
INDIRP4
CNSTI4 36
ADDP4
INDIRF4
SUBF4
ASGNF4
ADDRLP4 64+8
ADDRLP4 192+8
INDIRF4
ADDRFP4 0
INDIRP4
CNSTI4 40
ADDP4
INDIRF4
SUBF4
ASGNF4
line 2044
;2044:      }
ADDRGP4 $866
JUMPV
LABELV $887
line 2045
;2045:      else if( bp->accMoveValues.dirType == PMD_LINEAR )
ADDRLP4 0
INDIRP4
CNSTI4 80
ADDP4
INDIRI4
CNSTI4 0
NEI4 $866
line 2046
;2046:      {
line 2047
;2047:        if( !CG_AttachmentDir( &ps->attachment, acceleration ) )
ADDRLP4 128
INDIRP4
CNSTI4 4
ADDP4
ARGP4
ADDRLP4 64
ARGP4
ADDRLP4 192
ADDRGP4 CG_AttachmentDir
CALLI4
ASGNI4
ADDRLP4 192
INDIRI4
CNSTI4 0
NEI4 $866
line 2048
;2048:          return;
ADDRGP4 $862
JUMPV
line 2049
;2049:      }
line 2050
;2050:      break;
LABELV $899
line 2053
;2051:
;2052:    case PMT_NORMAL:
;2053:      if( !ps->normalValid )
ADDRLP4 128
INDIRP4
CNSTI4 1392
ADDP4
INDIRI4
CNSTI4 0
NEI4 $900
line 2054
;2054:        return;
ADDRGP4 $862
JUMPV
LABELV $900
line 2056
;2055:
;2056:      VectorCopy( ps->normal, acceleration );
ADDRLP4 64
ADDRLP4 128
INDIRP4
CNSTI4 1396
ADDP4
INDIRB
ASGNB 12
line 2058
;2057:
;2058:      break;
LABELV $865
LABELV $866
line 2063
;2059:  }
;2060:
;2061:#define MAX_ACC_RADIUS 1000.0f
;2062:
;2063:  if( bp->accMoveValues.dirType == PMD_POINT )
ADDRLP4 0
INDIRP4
CNSTI4 80
ADDP4
INDIRI4
CNSTI4 1
NEI4 $903
line 2064
;2064:  {
line 2066
;2065:    //FIXME: so this fall off is a bit... odd -- it works..
;2066:    float r2 = DotProduct( acceleration, acceleration ); // = radius^2
ADDRLP4 188
ADDRLP4 64
INDIRF4
ASGNF4
ADDRLP4 184
ADDRLP4 188
INDIRF4
ADDRLP4 188
INDIRF4
MULF4
ADDRLP4 64+4
INDIRF4
ADDRLP4 64+4
INDIRF4
MULF4
ADDF4
ADDRLP4 64+8
INDIRF4
ADDRLP4 64+8
INDIRF4
MULF4
ADDF4
ASGNF4
line 2067
;2067:    float scale = ( MAX_ACC_RADIUS - r2 ) / MAX_ACC_RADIUS;
ADDRLP4 192
CNSTF4 1148846080
ASGNF4
ADDRLP4 180
ADDRLP4 192
INDIRF4
ADDRLP4 184
INDIRF4
SUBF4
ADDRLP4 192
INDIRF4
DIVF4
ASGNF4
line 2069
;2068:
;2069:    if( scale > 1.0f )
ADDRLP4 180
INDIRF4
CNSTF4 1065353216
LEF4 $909
line 2070
;2070:      scale = 1.0f;
ADDRLP4 180
CNSTF4 1065353216
ASGNF4
ADDRGP4 $910
JUMPV
LABELV $909
line 2071
;2071:    else if( scale < 0.1f )
ADDRLP4 180
INDIRF4
CNSTF4 1036831949
GEF4 $911
line 2072
;2072:      scale = 0.1f;
ADDRLP4 180
CNSTF4 1036831949
ASGNF4
LABELV $911
LABELV $910
line 2074
;2073:
;2074:    scale *= CG_RandomiseValue( bp->accMoveValues.mag, bp->accMoveValues.magRandFrac );
ADDRLP4 0
INDIRP4
CNSTI4 116
ADDP4
INDIRF4
ARGF4
ADDRLP4 0
INDIRP4
CNSTI4 120
ADDP4
INDIRF4
ARGF4
ADDRLP4 200
ADDRGP4 CG_RandomiseValue
CALLF4
ASGNF4
ADDRLP4 180
ADDRLP4 180
INDIRF4
ADDRLP4 200
INDIRF4
MULF4
ASGNF4
line 2076
;2075:
;2076:    VectorNormalize( acceleration );
ADDRLP4 64
ARGP4
ADDRGP4 VectorNormalize
CALLF4
pop
line 2077
;2077:    CG_SpreadVector( acceleration, bp->accMoveValues.dirRandAngle );
ADDRLP4 64
ARGP4
ADDRLP4 0
INDIRP4
CNSTI4 96
ADDP4
INDIRF4
ARGF4
ADDRGP4 CG_SpreadVector
CALLV
pop
line 2078
;2078:    VectorScale( acceleration, scale, acceleration );
ADDRLP4 64
ADDRLP4 64
INDIRF4
ADDRLP4 180
INDIRF4
MULF4
ASGNF4
ADDRLP4 64+4
ADDRLP4 64+4
INDIRF4
ADDRLP4 180
INDIRF4
MULF4
ASGNF4
ADDRLP4 64+8
ADDRLP4 64+8
INDIRF4
ADDRLP4 180
INDIRF4
MULF4
ASGNF4
line 2079
;2079:  }
ADDRGP4 $904
JUMPV
LABELV $903
line 2080
;2080:  else if( bp->accMoveValues.dirType == PMD_LINEAR )
ADDRLP4 0
INDIRP4
CNSTI4 80
ADDP4
INDIRI4
CNSTI4 0
NEI4 $917
line 2081
;2081:  {
line 2082
;2082:    VectorNormalize( acceleration );
ADDRLP4 64
ARGP4
ADDRGP4 VectorNormalize
CALLF4
pop
line 2083
;2083:    CG_SpreadVector( acceleration, bp->accMoveValues.dirRandAngle );
ADDRLP4 64
ARGP4
ADDRLP4 0
INDIRP4
CNSTI4 96
ADDP4
INDIRF4
ARGF4
ADDRGP4 CG_SpreadVector
CALLV
pop
line 2084
;2084:    VectorScale( acceleration,
ADDRLP4 0
INDIRP4
CNSTI4 116
ADDP4
INDIRF4
ARGF4
ADDRLP4 0
INDIRP4
CNSTI4 120
ADDP4
INDIRF4
ARGF4
ADDRLP4 184
ADDRGP4 CG_RandomiseValue
CALLF4
ASGNF4
ADDRLP4 64
ADDRLP4 64
INDIRF4
ADDRLP4 184
INDIRF4
MULF4
ASGNF4
ADDRLP4 0
INDIRP4
CNSTI4 116
ADDP4
INDIRF4
ARGF4
ADDRLP4 0
INDIRP4
CNSTI4 120
ADDP4
INDIRF4
ARGF4
ADDRLP4 192
ADDRGP4 CG_RandomiseValue
CALLF4
ASGNF4
ADDRLP4 64+4
ADDRLP4 64+4
INDIRF4
ADDRLP4 192
INDIRF4
MULF4
ASGNF4
ADDRLP4 0
INDIRP4
CNSTI4 116
ADDP4
INDIRF4
ARGF4
ADDRLP4 0
INDIRP4
CNSTI4 120
ADDP4
INDIRF4
ARGF4
ADDRLP4 200
ADDRGP4 CG_RandomiseValue
CALLF4
ASGNF4
ADDRLP4 64+8
ADDRLP4 64+8
INDIRF4
ADDRLP4 200
INDIRF4
MULF4
ASGNF4
line 2087
;2085:                 CG_RandomiseValue( bp->accMoveValues.mag, bp->accMoveValues.magRandFrac ),
;2086:                 acceleration );
;2087:  }
LABELV $917
LABELV $904
line 2089
;2088:
;2089:  radius = CG_LerpValues( p->radius.initial,
ADDRLP4 180
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 180
INDIRP4
CNSTI4 8
ADDP4
INDIRI4
ARGI4
ADDRLP4 180
INDIRP4
CNSTI4 12
ADDP4
INDIRI4
ARGI4
ADDRLP4 180
INDIRP4
CNSTI4 120
ADDP4
INDIRI4
ARGI4
ADDRLP4 184
ADDRGP4 CG_CalculateTimeFrac
CALLF4
ASGNF4
ADDRLP4 188
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 188
INDIRP4
CNSTI4 128
ADDP4
INDIRF4
ARGF4
ADDRLP4 188
INDIRP4
CNSTI4 136
ADDP4
INDIRF4
ARGF4
ADDRLP4 184
INDIRF4
ARGF4
ADDRLP4 192
ADDRGP4 CG_LerpValues
CALLF4
ASGNF4
ADDRLP4 80
ADDRLP4 192
INDIRF4
ASGNF4
line 2095
;2090:                 p->radius.final,
;2091:                 CG_CalculateTimeFrac( p->birthTime,
;2092:                                       p->lifeTime,
;2093:                                       p->radius.delay ) );
;2094:
;2095:  VectorSet( mins, -radius, -radius, -radius );
ADDRLP4 196
ADDRLP4 80
INDIRF4
NEGF4
ASGNF4
ADDRLP4 100
ADDRLP4 196
INDIRF4
ASGNF4
ADDRLP4 100+4
ADDRLP4 196
INDIRF4
ASGNF4
ADDRLP4 100+8
ADDRLP4 80
INDIRF4
NEGF4
ASGNF4
line 2096
;2096:  VectorSet( maxs, radius, radius, radius );
ADDRLP4 112
ADDRLP4 80
INDIRF4
ASGNF4
ADDRLP4 112+4
ADDRLP4 80
INDIRF4
ASGNF4
ADDRLP4 112+8
ADDRLP4 80
INDIRF4
ASGNF4
line 2098
;2097:
;2098:  bounce = CG_RandomiseValue( bp->bounceFrac, bp->bounceFracRandFrac );
ADDRLP4 0
INDIRP4
CNSTI4 140
ADDP4
INDIRF4
ARGF4
ADDRLP4 0
INDIRP4
CNSTI4 144
ADDP4
INDIRF4
ARGF4
ADDRLP4 208
ADDRGP4 CG_RandomiseValue
CALLF4
ASGNF4
ADDRLP4 84
ADDRLP4 208
INDIRF4
ASGNF4
line 2100
;2099:
;2100:  deltaTime = (float)( cg.time - p->lastEvalTime ) * 0.001;
ADDRLP4 76
CNSTF4 981668463
ADDRGP4 cg+107604
INDIRI4
ADDRFP4 0
INDIRP4
CNSTI4 112
ADDP4
INDIRI4
SUBI4
CVIF4 4
MULF4
ASGNF4
line 2101
;2101:  VectorMA( p->velocity, deltaTime, acceleration, p->velocity );
ADDRLP4 212
ADDRFP4 0
INDIRP4
CNSTI4 44
ADDP4
ASGNP4
ADDRLP4 212
INDIRP4
ADDRLP4 212
INDIRP4
INDIRF4
ADDRLP4 64
INDIRF4
ADDRLP4 76
INDIRF4
MULF4
ADDF4
ASGNF4
ADDRLP4 216
ADDRFP4 0
INDIRP4
CNSTI4 48
ADDP4
ASGNP4
ADDRLP4 216
INDIRP4
ADDRLP4 216
INDIRP4
INDIRF4
ADDRLP4 64+4
INDIRF4
ADDRLP4 76
INDIRF4
MULF4
ADDF4
ASGNF4
ADDRLP4 220
ADDRFP4 0
INDIRP4
CNSTI4 52
ADDP4
ASGNP4
ADDRLP4 220
INDIRP4
ADDRLP4 220
INDIRP4
INDIRF4
ADDRLP4 64+8
INDIRF4
ADDRLP4 76
INDIRF4
MULF4
ADDF4
ASGNF4
line 2102
;2102:  VectorMA( p->origin, deltaTime, p->velocity, newOrigin );
ADDRLP4 224
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 88
ADDRLP4 224
INDIRP4
CNSTI4 32
ADDP4
INDIRF4
ADDRLP4 224
INDIRP4
CNSTI4 44
ADDP4
INDIRF4
ADDRLP4 76
INDIRF4
MULF4
ADDF4
ASGNF4
ADDRLP4 88+4
ADDRLP4 224
INDIRP4
CNSTI4 36
ADDP4
INDIRF4
ADDRLP4 224
INDIRP4
CNSTI4 48
ADDP4
INDIRF4
ADDRLP4 76
INDIRF4
MULF4
ADDF4
ASGNF4
ADDRLP4 232
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 88+8
ADDRLP4 232
INDIRP4
CNSTI4 40
ADDP4
INDIRF4
ADDRLP4 232
INDIRP4
CNSTI4 52
ADDP4
INDIRF4
ADDRLP4 76
INDIRF4
MULF4
ADDF4
ASGNF4
line 2103
;2103:  p->lastEvalTime = cg.time;
ADDRFP4 0
INDIRP4
CNSTI4 112
ADDP4
ADDRGP4 cg+107604
INDIRI4
ASGNI4
line 2105
;2104:
;2105:  CG_Trace( &trace, p->origin, mins, maxs, newOrigin,
ADDRLP4 128
INDIRP4
CNSTI4 4
ADDP4
ARGP4
ADDRLP4 236
ADDRGP4 CG_AttachmentCentNum
CALLI4
ASGNI4
ADDRLP4 4
ARGP4
ADDRFP4 0
INDIRP4
CNSTI4 32
ADDP4
ARGP4
ADDRLP4 100
ARGP4
ADDRLP4 112
ARGP4
ADDRLP4 88
ARGP4
ADDRLP4 236
INDIRI4
ARGI4
CNSTI4 1
ARGI4
ADDRGP4 CG_Trace
CALLV
pop
line 2109
;2106:      CG_AttachmentCentNum( &ps->attachment ), CONTENTS_SOLID );
;2107:
;2108:  //not hit anything or not a collider
;2109:  if( trace.fraction == 1.0f || bounce == 0.0f )
ADDRLP4 4+8
INDIRF4
CNSTF4 1065353216
EQF4 $936
ADDRLP4 84
INDIRF4
CNSTF4 0
NEF4 $933
LABELV $936
line 2110
;2110:  {
line 2111
;2111:    VectorCopy( newOrigin, p->origin );
ADDRFP4 0
INDIRP4
CNSTI4 32
ADDP4
ADDRLP4 88
INDIRB
ASGNB 12
line 2112
;2112:    return;
ADDRGP4 $862
JUMPV
LABELV $933
line 2116
;2113:  }
;2114:
;2115:  //remove particles that get into a CONTENTS_NODROP brush
;2116:  if( ( trap_CM_PointContents( trace.endpos, 0 ) & CONTENTS_NODROP ) ||
ADDRLP4 4+12
ARGP4
CNSTI4 0
ARGI4
ADDRLP4 240
ADDRGP4 trap_CM_PointContents
CALLI4
ASGNI4
ADDRLP4 240
INDIRI4
CVIU4 4
CNSTU4 2147483648
BANDU4
CNSTU4 0
NEU4 $941
ADDRLP4 244
CNSTI4 0
ASGNI4
ADDRLP4 0
INDIRP4
CNSTI4 3420
ADDP4
INDIRI4
ADDRLP4 244
INDIRI4
EQI4 $937
ADDRLP4 4+4
INDIRI4
ADDRLP4 244
INDIRI4
EQI4 $937
LABELV $941
line 2118
;2117:      ( bp->cullOnStartSolid && trace.startsolid ) )
;2118:  {
line 2119
;2119:    CG_DestroyParticle( p, NULL );
ADDRFP4 0
INDIRP4
ARGP4
CNSTP4 0
ARGP4
ADDRGP4 CG_DestroyParticle
CALLV
pop
line 2120
;2120:    return;
ADDRGP4 $862
JUMPV
LABELV $937
line 2122
;2121:  }
;2122:  else if( bp->bounceCull )
ADDRLP4 0
INDIRP4
CNSTI4 148
ADDP4
INDIRI4
CNSTI4 0
EQI4 $942
line 2123
;2123:  {
line 2124
;2124:    CG_DestroyParticle( p, trace.plane.normal );
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 4+24
ARGP4
ADDRGP4 CG_DestroyParticle
CALLV
pop
line 2125
;2125:    return;
ADDRGP4 $862
JUMPV
LABELV $942
line 2129
;2126:  }
;2127:
;2128:  //reflect the velocity on the trace plane
;2129:  dot = DotProduct( p->velocity, trace.plane.normal );
ADDRLP4 248
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 124
ADDRLP4 248
INDIRP4
CNSTI4 44
ADDP4
INDIRF4
ADDRLP4 4+24
INDIRF4
MULF4
ADDRLP4 248
INDIRP4
CNSTI4 48
ADDP4
INDIRF4
ADDRLP4 4+24+4
INDIRF4
MULF4
ADDF4
ADDRLP4 248
INDIRP4
CNSTI4 52
ADDP4
INDIRF4
ADDRLP4 4+24+8
INDIRF4
MULF4
ADDF4
ASGNF4
line 2130
;2130:  VectorMA( p->velocity, -2.0f * dot, trace.plane.normal, p->velocity );
ADDRLP4 252
ADDRFP4 0
INDIRP4
CNSTI4 44
ADDP4
ASGNP4
ADDRLP4 252
INDIRP4
ADDRLP4 252
INDIRP4
INDIRF4
ADDRLP4 4+24
INDIRF4
CNSTF4 3221225472
ADDRLP4 124
INDIRF4
MULF4
MULF4
ADDF4
ASGNF4
ADDRLP4 256
ADDRFP4 0
INDIRP4
CNSTI4 48
ADDP4
ASGNP4
ADDRLP4 256
INDIRP4
ADDRLP4 256
INDIRP4
INDIRF4
ADDRLP4 4+24+4
INDIRF4
CNSTF4 3221225472
ADDRLP4 124
INDIRF4
MULF4
MULF4
ADDF4
ASGNF4
ADDRLP4 260
ADDRFP4 0
INDIRP4
CNSTI4 52
ADDP4
ASGNP4
ADDRLP4 260
INDIRP4
ADDRLP4 260
INDIRP4
INDIRF4
ADDRLP4 4+24+8
INDIRF4
CNSTF4 3221225472
ADDRLP4 124
INDIRF4
MULF4
MULF4
ADDF4
ASGNF4
line 2132
;2131:
;2132:  VectorScale( p->velocity, bounce, p->velocity );
ADDRLP4 264
ADDRFP4 0
INDIRP4
CNSTI4 44
ADDP4
ASGNP4
ADDRLP4 264
INDIRP4
ADDRLP4 264
INDIRP4
INDIRF4
ADDRLP4 84
INDIRF4
MULF4
ASGNF4
ADDRLP4 268
ADDRFP4 0
INDIRP4
CNSTI4 48
ADDP4
ASGNP4
ADDRLP4 268
INDIRP4
ADDRLP4 268
INDIRP4
INDIRF4
ADDRLP4 84
INDIRF4
MULF4
ASGNF4
ADDRLP4 272
ADDRFP4 0
INDIRP4
CNSTI4 52
ADDP4
ASGNP4
ADDRLP4 272
INDIRP4
ADDRLP4 272
INDIRP4
INDIRF4
ADDRLP4 84
INDIRF4
MULF4
ASGNF4
line 2134
;2133:
;2134:  if( trace.plane.normal[ 2 ] > 0.5f &&
ADDRLP4 4+24+8
INDIRF4
CNSTF4 1056964608
LEF4 $955
ADDRLP4 276
ADDRFP4 0
INDIRP4
CNSTI4 52
ADDP4
INDIRF4
ASGNF4
ADDRLP4 276
INDIRF4
CNSTF4 1109393408
LTF4 $960
ADDRLP4 276
INDIRF4
ADDRGP4 cg+107600
INDIRI4
NEGI4
CVIF4 4
ADDRLP4 276
INDIRF4
MULF4
GEF4 $955
LABELV $960
line 2137
;2135:      ( p->velocity[ 2 ] < 40.0f ||
;2136:        p->velocity[ 2 ] < -cg.frametime * p->velocity[ 2 ] ) )
;2137:    p->atRest = qtrue;
ADDRFP4 0
INDIRP4
CNSTI4 28
ADDP4
CNSTI4 1
ASGNI4
LABELV $955
line 2139
;2138:
;2139:  if( bp->bounceMarkName[ 0 ] && p->bounceMarkCount > 0 )
ADDRLP4 280
CNSTI4 0
ASGNI4
ADDRLP4 0
INDIRP4
CNSTI4 152
ADDP4
INDIRI1
CVII4 1
ADDRLP4 280
INDIRI4
EQI4 $961
ADDRFP4 0
INDIRP4
CNSTI4 20
ADDP4
INDIRI4
ADDRLP4 280
INDIRI4
LEI4 $961
line 2140
;2140:  {
line 2141
;2141:    CG_ImpactMark( bp->bounceMark, trace.endpos, trace.plane.normal,
ADDRLP4 284
ADDRGP4 rand
CALLI4
ASGNI4
ADDRLP4 0
INDIRP4
CNSTI4 216
ADDP4
INDIRI4
ARGI4
ADDRLP4 4+12
ARGP4
ADDRLP4 4+24
ARGP4
CNSTF4 1135869952
ADDRLP4 284
INDIRI4
CNSTI4 32767
BANDI4
CVIF4 4
CNSTF4 1191181824
DIVF4
MULF4
ARGF4
ADDRLP4 292
CNSTF4 1065353216
ASGNF4
ADDRLP4 292
INDIRF4
ARGF4
ADDRLP4 292
INDIRF4
ARGF4
ADDRLP4 292
INDIRF4
ARGF4
ADDRLP4 292
INDIRF4
ARGF4
CNSTI4 1
ARGI4
ADDRLP4 0
INDIRP4
CNSTI4 220
ADDP4
INDIRF4
ARGF4
CNSTI4 0
ARGI4
ADDRGP4 CG_ImpactMark
CALLV
pop
line 2143
;2142:        random( ) * 360, 1, 1, 1, 1, qtrue, bp->bounceMarkRadius, qfalse );
;2143:    p->bounceMarkCount--;
ADDRLP4 296
ADDRFP4 0
INDIRP4
CNSTI4 20
ADDP4
ASGNP4
ADDRLP4 296
INDIRP4
ADDRLP4 296
INDIRP4
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
line 2144
;2144:  }
LABELV $961
line 2146
;2145:
;2146:  if( bp->bounceSoundName[ 0 ] && p->bounceSoundCount > 0 )
ADDRLP4 284
CNSTI4 0
ASGNI4
ADDRLP4 0
INDIRP4
CNSTI4 236
ADDP4
INDIRI1
CVII4 1
ADDRLP4 284
INDIRI4
EQI4 $965
ADDRFP4 0
INDIRP4
CNSTI4 24
ADDP4
INDIRI4
ADDRLP4 284
INDIRI4
LEI4 $965
line 2147
;2147:  {
line 2148
;2148:    trap_S_StartSound( trace.endpos, ENTITYNUM_WORLD, CHAN_AUTO, bp->bounceSound );
ADDRLP4 4+12
ARGP4
CNSTI4 1022
ARGI4
CNSTI4 0
ARGI4
ADDRLP4 0
INDIRP4
CNSTI4 300
ADDP4
INDIRI4
ARGI4
ADDRGP4 trap_S_StartSound
CALLV
pop
line 2149
;2149:    p->bounceSoundCount--;
ADDRLP4 288
ADDRFP4 0
INDIRP4
CNSTI4 24
ADDP4
ASGNP4
ADDRLP4 288
INDIRP4
ADDRLP4 288
INDIRP4
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
line 2150
;2150:  }
LABELV $965
line 2152
;2151:
;2152:  VectorCopy( trace.endpos, p->origin );
ADDRFP4 0
INDIRP4
CNSTI4 32
ADDP4
ADDRLP4 4+12
INDIRB
ASGNB 12
line 2153
;2153:}
LABELV $862
endproc CG_EvaluateParticlePhysics 300 44
proc CG_Radix 2080 12
line 2164
;2154:
;2155:
;2156:#define GETKEY(x,y) (((x)>>y)&0xFF)
;2157:
;2158:/*
;2159:===============
;2160:CG_Radix
;2161:===============
;2162:*/
;2163:static void CG_Radix( int bits, int size, particle_t **source, particle_t **dest )
;2164:{
line 2169
;2165:  int count[ 256 ];
;2166:  int index[ 256 ];
;2167:  int i;
;2168:
;2169:  memset( count, 0, sizeof( count ) );
ADDRLP4 1028
ARGP4
CNSTI4 0
ARGI4
CNSTI4 1024
ARGI4
ADDRGP4 memset
CALLP4
pop
line 2171
;2170:
;2171:  for( i = 0; i < size; i++ )
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $973
JUMPV
LABELV $970
line 2172
;2172:    count[ GETKEY( source[ i ]->sortKey, bits ) ]++;
ADDRLP4 2052
CNSTI4 2
ASGNI4
ADDRLP4 2056
ADDRLP4 0
INDIRI4
ADDRLP4 2052
INDIRI4
LSHI4
ADDRFP4 8
INDIRP4
ADDP4
INDIRP4
CNSTI4 332
ADDP4
INDIRI4
ADDRFP4 0
INDIRI4
RSHI4
CNSTI4 255
BANDI4
ADDRLP4 2052
INDIRI4
LSHI4
ADDRLP4 1028
ADDP4
ASGNP4
ADDRLP4 2056
INDIRP4
ADDRLP4 2056
INDIRP4
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $971
line 2171
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $973
ADDRLP4 0
INDIRI4
ADDRFP4 4
INDIRI4
LTI4 $970
line 2174
;2173:
;2174:  index[ 0 ] = 0;
ADDRLP4 4
CNSTI4 0
ASGNI4
line 2176
;2175:
;2176:  for( i = 1; i < 256; i++ )
ADDRLP4 0
CNSTI4 1
ASGNI4
LABELV $974
line 2177
;2177:    index[ i ] = index[ i - 1 ] + count[ i - 1 ];
ADDRLP4 2060
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ASGNI4
ADDRLP4 2060
INDIRI4
ADDRLP4 4
ADDP4
ADDRLP4 2060
INDIRI4
ADDRLP4 4-4
ADDP4
INDIRI4
ADDRLP4 2060
INDIRI4
ADDRLP4 1028-4
ADDP4
INDIRI4
ADDI4
ASGNI4
LABELV $975
line 2176
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 256
LTI4 $974
line 2179
;2178:
;2179:  for( i = 0; i < size; i++ )
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $983
JUMPV
LABELV $980
line 2180
;2180:    dest[ index[ GETKEY( source[ i ]->sortKey, bits ) ]++ ] = source[ i ];
ADDRLP4 2068
CNSTI4 2
ASGNI4
ADDRLP4 2072
ADDRLP4 0
INDIRI4
ADDRLP4 2068
INDIRI4
LSHI4
ADDRFP4 8
INDIRP4
ADDP4
INDIRP4
CNSTI4 332
ADDP4
INDIRI4
ADDRFP4 0
INDIRI4
RSHI4
CNSTI4 255
BANDI4
ADDRLP4 2068
INDIRI4
LSHI4
ADDRLP4 4
ADDP4
ASGNP4
ADDRLP4 2064
ADDRLP4 2072
INDIRP4
INDIRI4
ASGNI4
ADDRLP4 2072
INDIRP4
ADDRLP4 2064
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 2076
CNSTI4 2
ASGNI4
ADDRLP4 2064
INDIRI4
ADDRLP4 2076
INDIRI4
LSHI4
ADDRFP4 12
INDIRP4
ADDP4
ADDRLP4 0
INDIRI4
ADDRLP4 2076
INDIRI4
LSHI4
ADDRFP4 8
INDIRP4
ADDP4
INDIRP4
ASGNP4
LABELV $981
line 2179
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $983
ADDRLP4 0
INDIRI4
ADDRFP4 4
INDIRI4
LTI4 $980
line 2181
;2181:}
LABELV $969
endproc CG_Radix 2080 12
proc CG_RadixSort 0 16
line 2191
;2182:
;2183:/*
;2184:===============
;2185:CG_RadixSort
;2186:
;2187:Radix sort with 4 byte size buckets
;2188:===============
;2189:*/
;2190:static void CG_RadixSort( particle_t **source, particle_t **temp, int size )
;2191:{
line 2192
;2192:  CG_Radix( 0,   size, source, temp );
CNSTI4 0
ARGI4
ADDRFP4 8
INDIRI4
ARGI4
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRGP4 CG_Radix
CALLV
pop
line 2193
;2193:  CG_Radix( 8,   size, temp, source );
CNSTI4 8
ARGI4
ADDRFP4 8
INDIRI4
ARGI4
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRGP4 CG_Radix
CALLV
pop
line 2194
;2194:  CG_Radix( 16,  size, source, temp );
CNSTI4 16
ARGI4
ADDRFP4 8
INDIRI4
ARGI4
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRGP4 CG_Radix
CALLV
pop
line 2195
;2195:  CG_Radix( 24,  size, temp, source );
CNSTI4 24
ARGI4
ADDRFP4 8
INDIRI4
ARGI4
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRGP4 CG_Radix
CALLV
pop
line 2196
;2196:}
LABELV $984
endproc CG_RadixSort 0 16
proc CG_CompactAndSortParticles 40 12
line 2206
;2197:
;2198:/*
;2199:===============
;2200:CG_CompactAndSortParticles
;2201:
;2202:Depth sort the particles
;2203:===============
;2204:*/
;2205:static void CG_CompactAndSortParticles( void )
;2206:{
line 2207
;2207:  int     i, j = 0;
ADDRLP4 4
CNSTI4 0
ASGNI4
line 2211
;2208:  int     numParticles;
;2209:  vec3_t  delta;
;2210:
;2211:  for( i = 0; i < MAX_PARTICLES; i++ )
ADDRLP4 0
CNSTI4 0
ASGNI4
LABELV $986
line 2212
;2212:    sortedParticles[ i ] = &particles[ i ];
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 sortedParticles
ADDP4
CNSTI4 336
ADDRLP4 0
INDIRI4
MULI4
ADDRGP4 particles
ADDP4
ASGNP4
LABELV $987
line 2211
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 960
LTI4 $986
line 2214
;2213:
;2214:  if( !cg_depthSortParticles.integer )
ADDRGP4 cg_depthSortParticles+12
INDIRI4
CNSTI4 0
NEI4 $990
line 2215
;2215:    return;
ADDRGP4 $985
JUMPV
LABELV $990
line 2217
;2216:
;2217:  for( i = MAX_PARTICLES - 1; i >= 0; i-- )
ADDRLP4 0
CNSTI4 959
ASGNI4
LABELV $993
line 2218
;2218:  {
line 2219
;2219:    if( sortedParticles[ i ]->valid )
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 sortedParticles
ADDP4
INDIRP4
CNSTI4 324
ADDP4
INDIRI4
CNSTI4 0
EQI4 $997
line 2220
;2220:    {
ADDRGP4 $1000
JUMPV
LABELV $999
line 2223
;2221:      //find the first hole
;2222:      while( sortedParticles[ j ]->valid )
;2223:        j++;
ADDRLP4 4
ADDRLP4 4
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $1000
line 2222
ADDRLP4 4
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 sortedParticles
ADDP4
INDIRP4
CNSTI4 324
ADDP4
INDIRI4
CNSTI4 0
NEI4 $999
line 2226
;2224:
;2225:      //no more holes
;2226:      if( j >= i )
ADDRLP4 4
INDIRI4
ADDRLP4 0
INDIRI4
LTI4 $1002
line 2227
;2227:        break;
ADDRGP4 $995
JUMPV
LABELV $1002
line 2229
;2228:
;2229:      sortedParticles[ j ] = sortedParticles[ i ];
ADDRLP4 28
CNSTI4 2
ASGNI4
ADDRLP4 32
ADDRGP4 sortedParticles
ASGNP4
ADDRLP4 4
INDIRI4
ADDRLP4 28
INDIRI4
LSHI4
ADDRLP4 32
INDIRP4
ADDP4
ADDRLP4 0
INDIRI4
ADDRLP4 28
INDIRI4
LSHI4
ADDRLP4 32
INDIRP4
ADDP4
INDIRP4
ASGNP4
line 2230
;2230:    }
LABELV $997
line 2231
;2231:  }
LABELV $994
line 2217
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 0
GEI4 $993
LABELV $995
line 2233
;2232:
;2233:  numParticles = i;
ADDRLP4 20
ADDRLP4 0
INDIRI4
ASGNI4
line 2236
;2234:
;2235:  //set sort keys
;2236:  for( i = 0; i < numParticles; i++ )
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $1007
JUMPV
LABELV $1004
line 2237
;2237:  {
line 2238
;2238:    VectorSubtract( sortedParticles[ i ]->origin, cg.refdef.vieworg, delta );
ADDRLP4 28
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 sortedParticles
ADDP4
ASGNP4
ADDRLP4 8
ADDRLP4 28
INDIRP4
INDIRP4
CNSTI4 32
ADDP4
INDIRF4
ADDRGP4 cg+110040+24
INDIRF4
SUBF4
ASGNF4
ADDRLP4 8+4
ADDRLP4 28
INDIRP4
INDIRP4
CNSTI4 36
ADDP4
INDIRF4
ADDRGP4 cg+110040+24+4
INDIRF4
SUBF4
ASGNF4
ADDRLP4 8+8
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 sortedParticles
ADDP4
INDIRP4
CNSTI4 40
ADDP4
INDIRF4
ADDRGP4 cg+110040+24+8
INDIRF4
SUBF4
ASGNF4
line 2239
;2239:    sortedParticles[ i ]->sortKey = (int)DotProduct( delta, delta );
ADDRLP4 32
ADDRLP4 8
INDIRF4
ASGNF4
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 sortedParticles
ADDP4
INDIRP4
CNSTI4 332
ADDP4
ADDRLP4 32
INDIRF4
ADDRLP4 32
INDIRF4
MULF4
ADDRLP4 8+4
INDIRF4
ADDRLP4 8+4
INDIRF4
MULF4
ADDF4
ADDRLP4 8+8
INDIRF4
ADDRLP4 8+8
INDIRF4
MULF4
ADDF4
CVFI4 4
ASGNI4
line 2240
;2240:  }
LABELV $1005
line 2236
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $1007
ADDRLP4 0
INDIRI4
ADDRLP4 20
INDIRI4
LTI4 $1004
line 2242
;2241:
;2242:  CG_RadixSort( sortedParticles, radixBuffer, numParticles );
ADDRGP4 sortedParticles
ARGP4
ADDRGP4 radixBuffer
ARGP4
ADDRLP4 20
INDIRI4
ARGI4
ADDRGP4 CG_RadixSort
CALLV
pop
line 2246
;2243:
;2244:  //FIXME: wtf?
;2245:  //reverse order of particles array
;2246:  for( i = 0; i < numParticles; i++ )
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $1025
JUMPV
LABELV $1022
line 2247
;2247:    radixBuffer[ i ] = sortedParticles[ numParticles - i - 1 ];
ADDRLP4 32
CNSTI4 2
ASGNI4
ADDRLP4 0
INDIRI4
ADDRLP4 32
INDIRI4
LSHI4
ADDRGP4 radixBuffer
ADDP4
ADDRLP4 20
INDIRI4
ADDRLP4 0
INDIRI4
SUBI4
ADDRLP4 32
INDIRI4
LSHI4
ADDRGP4 sortedParticles-4
ADDP4
INDIRP4
ASGNP4
LABELV $1023
line 2246
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $1025
ADDRLP4 0
INDIRI4
ADDRLP4 20
INDIRI4
LTI4 $1022
line 2249
;2248:
;2249:  for( i = 0; i < numParticles; i++ )
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $1030
JUMPV
LABELV $1027
line 2250
;2250:    sortedParticles[ i ] = radixBuffer[ i ];
ADDRLP4 36
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ASGNI4
ADDRLP4 36
INDIRI4
ADDRGP4 sortedParticles
ADDP4
ADDRLP4 36
INDIRI4
ADDRGP4 radixBuffer
ADDP4
INDIRP4
ASGNP4
LABELV $1028
line 2249
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $1030
ADDRLP4 0
INDIRI4
ADDRLP4 20
INDIRI4
LTI4 $1027
line 2251
;2251:}
LABELV $985
endproc CG_CompactAndSortParticles 40 12
lit
align 4
LABELV $1032
byte 4 0
byte 4 0
byte 4 1065353216
code
proc CG_RenderParticle 324 20
line 2261
;2252:
;2253:/*
;2254:===============
;2255:CG_RenderParticle
;2256:
;2257:Actually render a particle
;2258:===============
;2259:*/
;2260:static void CG_RenderParticle( particle_t *p )
;2261:{
line 2265
;2262:  refEntity_t           re;
;2263:  float                 timeFrac, scale;
;2264:  int                   index;
;2265:  baseParticle_t        *bp = p->class;
ADDRLP4 140
ADDRFP4 0
INDIRP4
INDIRP4
ASGNP4
line 2266
;2266:  particleSystem_t      *ps = p->parent->parent;
ADDRLP4 216
CNSTI4 4
ASGNI4
ADDRLP4 148
ADDRFP4 0
INDIRP4
ADDRLP4 216
INDIRI4
ADDP4
INDIRP4
ADDRLP4 216
INDIRI4
ADDP4
INDIRP4
ASGNP4
line 2267
;2267:  baseParticleSystem_t  *bps = ps->class;
ADDRLP4 168
ADDRLP4 148
INDIRP4
INDIRP4
ASGNP4
line 2270
;2268:  vec3_t                alight, dlight, lightdir;
;2269:  int                   i;
;2270:  vec3_t                up = { 0.0f, 0.0f, 1.0f };
ADDRLP4 180
ADDRGP4 $1032
INDIRB
ASGNB 12
line 2272
;2271:
;2272:  memset( &re, 0, sizeof( refEntity_t ) );
ADDRLP4 0
ARGP4
CNSTI4 0
ARGI4
CNSTI4 140
ARGI4
ADDRGP4 memset
CALLP4
pop
line 2274
;2273:
;2274:  timeFrac = CG_CalculateTimeFrac( p->birthTime, p->lifeTime, 0 );
ADDRLP4 220
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 220
INDIRP4
CNSTI4 8
ADDP4
INDIRI4
ARGI4
ADDRLP4 220
INDIRP4
CNSTI4 12
ADDP4
INDIRI4
ARGI4
CNSTI4 0
ARGI4
ADDRLP4 224
ADDRGP4 CG_CalculateTimeFrac
CALLF4
ASGNF4
ADDRLP4 172
ADDRLP4 224
INDIRF4
ASGNF4
line 2276
;2275:
;2276:  scale = CG_LerpValues( p->radius.initial,
ADDRLP4 228
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 228
INDIRP4
CNSTI4 8
ADDP4
INDIRI4
ARGI4
ADDRLP4 228
INDIRP4
CNSTI4 12
ADDP4
INDIRI4
ARGI4
ADDRLP4 228
INDIRP4
CNSTI4 120
ADDP4
INDIRI4
ARGI4
ADDRLP4 232
ADDRGP4 CG_CalculateTimeFrac
CALLF4
ASGNF4
ADDRLP4 236
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 236
INDIRP4
CNSTI4 128
ADDP4
INDIRF4
ARGF4
ADDRLP4 236
INDIRP4
CNSTI4 136
ADDP4
INDIRF4
ARGF4
ADDRLP4 232
INDIRF4
ARGF4
ADDRLP4 240
ADDRGP4 CG_LerpValues
CALLF4
ASGNF4
ADDRLP4 152
ADDRLP4 240
INDIRF4
ASGNF4
line 2282
;2277:                    p->radius.final,
;2278:                    CG_CalculateTimeFrac( p->birthTime,
;2279:                                          p->lifeTime,
;2280:                                          p->radius.delay ) );
;2281:
;2282:  re.shaderTime = p->birthTime / 1000.0f;
ADDRLP4 0+128
ADDRFP4 0
INDIRP4
CNSTI4 8
ADDP4
INDIRI4
CVIF4 4
CNSTF4 1148846080
DIVF4
ASGNF4
line 2284
;2283:
;2284:  if( bp->numFrames )       //shader based
ADDRLP4 140
INDIRP4
CNSTI4 2828
ADDP4
INDIRI4
CNSTI4 0
EQI4 $1034
line 2285
;2285:  {
line 2286
;2286:    re.reType = RT_SPRITE;
ADDRLP4 0
CNSTI4 2
ASGNI4
line 2289
;2287:
;2288:    //apply environmental lighting to the particle
;2289:    if( bp->realLight )
ADDRLP4 140
INDIRP4
CNSTI4 3416
ADDP4
INDIRI4
CNSTI4 0
EQI4 $1036
line 2290
;2290:    {
line 2291
;2291:      trap_R_LightForPoint( p->origin, alight, dlight, lightdir );
ADDRFP4 0
INDIRP4
CNSTI4 32
ADDP4
ARGP4
ADDRLP4 156
ARGP4
ADDRLP4 192
ARGP4
ADDRLP4 204
ARGP4
ADDRGP4 trap_R_LightForPoint
CALLI4
pop
line 2292
;2292:      for( i = 0; i <= 2; i++ )
ADDRLP4 144
CNSTI4 0
ASGNI4
LABELV $1038
line 2293
;2293:        re.shaderRGBA[ i ] = (byte)alight[ i ];
ADDRLP4 252
ADDRLP4 144
INDIRI4
CNSTI4 2
LSHI4
ADDRLP4 156
ADDP4
INDIRF4
ASGNF4
ADDRLP4 256
CNSTF4 1325400064
ASGNF4
ADDRLP4 252
INDIRF4
ADDRLP4 256
INDIRF4
LTF4 $1044
ADDRLP4 244
ADDRLP4 252
INDIRF4
ADDRLP4 256
INDIRF4
SUBF4
CVFI4 4
CVIU4 4
CNSTU4 2147483648
ADDU4
ASGNU4
ADDRGP4 $1045
JUMPV
LABELV $1044
ADDRLP4 244
ADDRLP4 252
INDIRF4
CVFI4 4
CVIU4 4
ASGNU4
LABELV $1045
ADDRLP4 144
INDIRI4
ADDRLP4 0+116
ADDP4
ADDRLP4 244
INDIRU4
CVUU1 4
ASGNU1
LABELV $1039
line 2292
ADDRLP4 144
ADDRLP4 144
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 144
INDIRI4
CNSTI4 2
LEI4 $1038
line 2294
;2294:    }
ADDRGP4 $1037
JUMPV
LABELV $1036
line 2296
;2295:    else
;2296:    {
line 2299
;2297:      vec3_t  colorRange;
;2298:
;2299:      VectorSubtract( bp->finalColor,
ADDRLP4 244
ADDRLP4 140
INDIRP4
CNSTI4 443
ADDP4
INDIRU1
CVUI4 1
ADDRLP4 140
INDIRP4
CNSTI4 440
ADDP4
INDIRU1
CVUI4 1
SUBI4
CVIF4 4
ASGNF4
ADDRLP4 244+4
ADDRLP4 140
INDIRP4
CNSTI4 444
ADDP4
INDIRU1
CVUI4 1
ADDRLP4 140
INDIRP4
CNSTI4 441
ADDP4
INDIRU1
CVUI4 1
SUBI4
CVIF4 4
ASGNF4
ADDRLP4 244+8
ADDRLP4 140
INDIRP4
CNSTI4 445
ADDP4
INDIRU1
CVUI4 1
ADDRLP4 140
INDIRP4
CNSTI4 442
ADDP4
INDIRU1
CVUI4 1
SUBI4
CVIF4 4
ASGNF4
line 2302
;2300:          bp->initialColor, colorRange );
;2301:
;2302:      VectorMA( bp->initialColor,
ADDRLP4 276
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 276
INDIRP4
CNSTI4 8
ADDP4
INDIRI4
ARGI4
ADDRLP4 276
INDIRP4
CNSTI4 12
ADDP4
INDIRI4
ARGI4
ADDRLP4 276
INDIRP4
CNSTI4 232
ADDP4
INDIRI4
ARGI4
ADDRLP4 280
ADDRGP4 CG_CalculateTimeFrac
CALLF4
ASGNF4
ADDRLP4 284
ADDRLP4 140
INDIRP4
CNSTI4 440
ADDP4
INDIRU1
CVUI4 1
CVIF4 4
ADDRLP4 244
INDIRF4
ADDRLP4 280
INDIRF4
MULF4
ADDF4
ASGNF4
ADDRLP4 288
CNSTF4 1325400064
ASGNF4
ADDRLP4 284
INDIRF4
ADDRLP4 288
INDIRF4
LTF4 $1058
ADDRLP4 264
ADDRLP4 284
INDIRF4
ADDRLP4 288
INDIRF4
SUBF4
CVFI4 4
CVIU4 4
CNSTU4 2147483648
ADDU4
ASGNU4
ADDRGP4 $1059
JUMPV
LABELV $1058
ADDRLP4 264
ADDRLP4 284
INDIRF4
CVFI4 4
CVIU4 4
ASGNU4
LABELV $1059
ADDRLP4 0+116
ADDRLP4 264
INDIRU4
CVUU1 4
ASGNU1
ADDRLP4 292
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 292
INDIRP4
CNSTI4 8
ADDP4
INDIRI4
ARGI4
ADDRLP4 292
INDIRP4
CNSTI4 12
ADDP4
INDIRI4
ARGI4
ADDRLP4 292
INDIRP4
CNSTI4 232
ADDP4
INDIRI4
ARGI4
ADDRLP4 296
ADDRGP4 CG_CalculateTimeFrac
CALLF4
ASGNF4
ADDRLP4 300
ADDRLP4 140
INDIRP4
CNSTI4 441
ADDP4
INDIRU1
CVUI4 1
CVIF4 4
ADDRLP4 244+4
INDIRF4
ADDRLP4 296
INDIRF4
MULF4
ADDF4
ASGNF4
ADDRLP4 304
CNSTF4 1325400064
ASGNF4
ADDRLP4 300
INDIRF4
ADDRLP4 304
INDIRF4
LTF4 $1060
ADDRLP4 268
ADDRLP4 300
INDIRF4
ADDRLP4 304
INDIRF4
SUBF4
CVFI4 4
CVIU4 4
CNSTU4 2147483648
ADDU4
ASGNU4
ADDRGP4 $1061
JUMPV
LABELV $1060
ADDRLP4 268
ADDRLP4 300
INDIRF4
CVFI4 4
CVIU4 4
ASGNU4
LABELV $1061
ADDRLP4 0+116+1
ADDRLP4 268
INDIRU4
CVUU1 4
ASGNU1
ADDRLP4 308
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 308
INDIRP4
CNSTI4 8
ADDP4
INDIRI4
ARGI4
ADDRLP4 308
INDIRP4
CNSTI4 12
ADDP4
INDIRI4
ARGI4
ADDRLP4 308
INDIRP4
CNSTI4 232
ADDP4
INDIRI4
ARGI4
ADDRLP4 312
ADDRGP4 CG_CalculateTimeFrac
CALLF4
ASGNF4
ADDRLP4 316
ADDRLP4 140
INDIRP4
CNSTI4 442
ADDP4
INDIRU1
CVUI4 1
CVIF4 4
ADDRLP4 244+8
INDIRF4
ADDRLP4 312
INDIRF4
MULF4
ADDF4
ASGNF4
ADDRLP4 320
CNSTF4 1325400064
ASGNF4
ADDRLP4 316
INDIRF4
ADDRLP4 320
INDIRF4
LTF4 $1062
ADDRLP4 272
ADDRLP4 316
INDIRF4
ADDRLP4 320
INDIRF4
SUBF4
CVFI4 4
CVIU4 4
CNSTU4 2147483648
ADDU4
ASGNU4
ADDRGP4 $1063
JUMPV
LABELV $1062
ADDRLP4 272
ADDRLP4 316
INDIRF4
CVFI4 4
CVIU4 4
ASGNU4
LABELV $1063
ADDRLP4 0+116+2
ADDRLP4 272
INDIRU4
CVUU1 4
ASGNU1
line 2307
;2303:          CG_CalculateTimeFrac( p->birthTime,
;2304:            p->lifeTime,
;2305:            p->colorDelay ),
;2306:          colorRange, re.shaderRGBA );
;2307:    }
LABELV $1037
line 2309
;2308:
;2309:    re.shaderRGBA[ 3 ] = (byte)( (float)0xFF *
ADDRLP4 248
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 248
INDIRP4
CNSTI4 8
ADDP4
INDIRI4
ARGI4
ADDRLP4 248
INDIRP4
CNSTI4 12
ADDP4
INDIRI4
ARGI4
ADDRLP4 248
INDIRP4
CNSTI4 148
ADDP4
INDIRI4
ARGI4
ADDRLP4 252
ADDRGP4 CG_CalculateTimeFrac
CALLF4
ASGNF4
ADDRLP4 256
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 256
INDIRP4
CNSTI4 156
ADDP4
INDIRF4
ARGF4
ADDRLP4 256
INDIRP4
CNSTI4 164
ADDP4
INDIRF4
ARGF4
ADDRLP4 252
INDIRF4
ARGF4
ADDRLP4 260
ADDRGP4 CG_LerpValues
CALLF4
ASGNF4
ADDRLP4 264
CNSTF4 1132396544
ADDRLP4 260
INDIRF4
MULF4
ASGNF4
ADDRLP4 268
CNSTF4 1325400064
ASGNF4
ADDRLP4 264
INDIRF4
ADDRLP4 268
INDIRF4
LTF4 $1067
ADDRLP4 244
ADDRLP4 264
INDIRF4
ADDRLP4 268
INDIRF4
SUBF4
CVFI4 4
CVIU4 4
CNSTU4 2147483648
ADDU4
ASGNU4
ADDRGP4 $1068
JUMPV
LABELV $1067
ADDRLP4 244
ADDRLP4 264
INDIRF4
CVFI4 4
CVIU4 4
ASGNU4
LABELV $1068
ADDRLP4 0+116+3
ADDRLP4 244
INDIRU4
CVUU1 4
ASGNU1
line 2316
;2310:                         CG_LerpValues( p->alpha.initial,
;2311:                               p->alpha.final,
;2312:                               CG_CalculateTimeFrac( p->birthTime,
;2313:                                                     p->lifeTime,
;2314:                                                     p->alpha.delay ) ) );
;2315:
;2316:    re.radius = scale;
ADDRLP4 0+132
ADDRLP4 152
INDIRF4
ASGNF4
line 2318
;2317:
;2318:    re.rotation = CG_LerpValues( p->rotation.initial,
ADDRLP4 272
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 272
INDIRP4
CNSTI4 8
ADDP4
INDIRI4
ARGI4
ADDRLP4 272
INDIRP4
CNSTI4 12
ADDP4
INDIRI4
ARGI4
ADDRLP4 272
INDIRP4
CNSTI4 176
ADDP4
INDIRI4
ARGI4
ADDRLP4 276
ADDRGP4 CG_CalculateTimeFrac
CALLF4
ASGNF4
ADDRLP4 280
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 280
INDIRP4
CNSTI4 184
ADDP4
INDIRF4
ARGF4
ADDRLP4 280
INDIRP4
CNSTI4 192
ADDP4
INDIRF4
ARGF4
ADDRLP4 276
INDIRF4
ARGF4
ADDRLP4 284
ADDRGP4 CG_LerpValues
CALLF4
ASGNF4
ADDRLP4 0+136
ADDRLP4 284
INDIRF4
ASGNF4
line 2326
;2319:                        p->rotation.final,
;2320:                        CG_CalculateTimeFrac( p->birthTime,
;2321:                                              p->lifeTime,
;2322:                                              p->rotation.delay ) );
;2323:
;2324:    // if the view would be "inside" the sprite, kill the sprite
;2325:    // so it doesn't add too much overdraw
;2326:    if( Distance( p->origin, cg.refdef.vieworg ) < re.radius && bp->overdrawProtection )
ADDRFP4 0
INDIRP4
CNSTI4 32
ADDP4
ARGP4
ADDRGP4 cg+110040+24
ARGP4
ADDRLP4 288
ADDRGP4 Distance
CALLF4
ASGNF4
ADDRLP4 288
INDIRF4
ADDRLP4 0+132
INDIRF4
GEF4 $1071
ADDRLP4 140
INDIRP4
CNSTI4 3412
ADDP4
INDIRI4
CNSTI4 0
EQI4 $1071
line 2327
;2327:      return;
ADDRGP4 $1031
JUMPV
LABELV $1071
line 2329
;2328:
;2329:    if( bp->framerate == 0.0f )
ADDRLP4 140
INDIRP4
CNSTI4 2832
ADDP4
INDIRF4
CNSTF4 0
NEF4 $1076
line 2330
;2330:    {
line 2332
;2331:      //sync animation time to lifeTime of particle
;2332:      index = (int)( timeFrac * ( bp->numFrames + 1 ) );
ADDRLP4 176
ADDRLP4 172
INDIRF4
ADDRLP4 140
INDIRP4
CNSTI4 2828
ADDP4
INDIRI4
CNSTI4 1
ADDI4
CVIF4 4
MULF4
CVFI4 4
ASGNI4
line 2334
;2333:
;2334:      if( index >= bp->numFrames )
ADDRLP4 176
INDIRI4
ADDRLP4 140
INDIRP4
CNSTI4 2828
ADDP4
INDIRI4
LTI4 $1078
line 2335
;2335:        index = bp->numFrames - 1;
ADDRLP4 176
ADDRLP4 140
INDIRP4
CNSTI4 2828
ADDP4
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
LABELV $1078
line 2337
;2336:
;2337:      re.customShader = bp->shaders[ index ];
ADDRLP4 0+112
ADDRLP4 176
INDIRI4
CNSTI4 2
LSHI4
ADDRLP4 140
INDIRP4
CNSTI4 2700
ADDP4
ADDP4
INDIRI4
ASGNI4
line 2338
;2338:    }
ADDRGP4 $1035
JUMPV
LABELV $1076
line 2340
;2339:    else
;2340:    {
line 2342
;2341:      //looping animation
;2342:      index = (int)( bp->framerate * timeFrac * p->lifeTime * 0.001 ) % bp->numFrames;
ADDRLP4 176
CNSTF4 981668463
ADDRLP4 140
INDIRP4
CNSTI4 2832
ADDP4
INDIRF4
ADDRLP4 172
INDIRF4
MULF4
ADDRFP4 0
INDIRP4
CNSTI4 12
ADDP4
INDIRI4
CVIF4 4
MULF4
MULF4
CVFI4 4
ADDRLP4 140
INDIRP4
CNSTI4 2828
ADDP4
INDIRI4
MODI4
ASGNI4
line 2343
;2343:      re.customShader = bp->shaders[ index ];
ADDRLP4 0+112
ADDRLP4 176
INDIRI4
CNSTI4 2
LSHI4
ADDRLP4 140
INDIRP4
CNSTI4 2700
ADDP4
ADDP4
INDIRI4
ASGNI4
line 2344
;2344:    }
line 2346
;2345:
;2346:  }
ADDRGP4 $1035
JUMPV
LABELV $1034
line 2347
;2347:  else if( bp->numModels )  //model based
ADDRLP4 140
INDIRP4
CNSTI4 3380
ADDP4
INDIRI4
CNSTI4 0
EQI4 $1082
line 2348
;2348:  {
line 2349
;2349:    re.reType = RT_MODEL;
ADDRLP4 0
CNSTI4 0
ASGNI4
line 2351
;2350:
;2351:    re.hModel = p->model;
ADDRLP4 0+8
ADDRFP4 0
INDIRP4
CNSTI4 236
ADDP4
INDIRI4
ASGNI4
line 2353
;2352:
;2353:    if( p->atRest )
ADDRFP4 0
INDIRP4
CNSTI4 28
ADDP4
INDIRI4
CNSTI4 0
EQI4 $1085
line 2354
;2354:      AxisCopy( p->lastAxis, re.axis );
ADDRFP4 0
INDIRP4
CNSTI4 288
ADDP4
ARGP4
ADDRLP4 0+28
ARGP4
ADDRGP4 AxisCopy
CALLV
pop
ADDRGP4 $1086
JUMPV
LABELV $1085
line 2356
;2355:    else
;2356:    {
line 2358
;2357:      // convert direction of travel into axis
;2358:      VectorNormalize2( p->velocity, re.axis[ 0 ] );
ADDRFP4 0
INDIRP4
CNSTI4 44
ADDP4
ARGP4
ADDRLP4 0+28
ARGP4
ADDRGP4 VectorNormalize2
CALLF4
pop
line 2360
;2359:
;2360:      if( re.axis[ 0 ][ 0 ] == 0.0f && re.axis[ 0 ][ 1 ] == 0.0f )
ADDRLP4 244
CNSTF4 0
ASGNF4
ADDRLP4 0+28
INDIRF4
ADDRLP4 244
INDIRF4
NEF4 $1089
ADDRLP4 0+28+4
INDIRF4
ADDRLP4 244
INDIRF4
NEF4 $1089
line 2361
;2361:        AxisCopy( axisDefault, re.axis );
ADDRGP4 axisDefault
ARGP4
ADDRLP4 0+28
ARGP4
ADDRGP4 AxisCopy
CALLV
pop
ADDRGP4 $1090
JUMPV
LABELV $1089
line 2363
;2362:      else
;2363:      {
line 2364
;2364:        ProjectPointOnPlane( re.axis[ 2 ], up, re.axis[ 0 ] );
ADDRLP4 0+28+24
ARGP4
ADDRLP4 180
ARGP4
ADDRLP4 0+28
ARGP4
ADDRGP4 ProjectPointOnPlane
CALLV
pop
line 2365
;2365:        VectorNormalize( re.axis[ 2 ] );
ADDRLP4 0+28+24
ARGP4
ADDRGP4 VectorNormalize
CALLF4
pop
line 2366
;2366:        CrossProduct( re.axis[ 2 ], re.axis[ 0 ], re.axis[ 1 ] );
ADDRLP4 0+28+24
ARGP4
ADDRLP4 0+28
ARGP4
ADDRLP4 0+28+12
ARGP4
ADDRGP4 CrossProduct
CALLV
pop
line 2367
;2367:      }
LABELV $1090
line 2369
;2368:
;2369:      AxisCopy( re.axis, p->lastAxis );
ADDRLP4 0+28
ARGP4
ADDRFP4 0
INDIRP4
CNSTI4 288
ADDP4
ARGP4
ADDRGP4 AxisCopy
CALLV
pop
line 2370
;2370:    }
LABELV $1086
line 2372
;2371:
;2372:    if( scale != 1.0f )
ADDRLP4 152
INDIRF4
CNSTF4 1065353216
EQF4 $1106
line 2373
;2373:    {
line 2374
;2374:      VectorScale( re.axis[ 0 ], scale, re.axis[ 0 ] );
ADDRLP4 0+28
ADDRLP4 0+28
INDIRF4
ADDRLP4 152
INDIRF4
MULF4
ASGNF4
ADDRLP4 0+28+4
ADDRLP4 0+28+4
INDIRF4
ADDRLP4 152
INDIRF4
MULF4
ASGNF4
ADDRLP4 0+28+8
ADDRLP4 0+28+8
INDIRF4
ADDRLP4 152
INDIRF4
MULF4
ASGNF4
line 2375
;2375:      VectorScale( re.axis[ 1 ], scale, re.axis[ 1 ] );
ADDRLP4 0+28+12
ADDRLP4 0+28+12
INDIRF4
ADDRLP4 152
INDIRF4
MULF4
ASGNF4
ADDRLP4 0+28+12+4
ADDRLP4 0+28+12+4
INDIRF4
ADDRLP4 152
INDIRF4
MULF4
ASGNF4
ADDRLP4 0+28+12+8
ADDRLP4 0+28+12+8
INDIRF4
ADDRLP4 152
INDIRF4
MULF4
ASGNF4
line 2376
;2376:      VectorScale( re.axis[ 2 ], scale, re.axis[ 2 ] );
ADDRLP4 0+28+24
ADDRLP4 0+28+24
INDIRF4
ADDRLP4 152
INDIRF4
MULF4
ASGNF4
ADDRLP4 0+28+24+4
ADDRLP4 0+28+24+4
INDIRF4
ADDRLP4 152
INDIRF4
MULF4
ASGNF4
ADDRLP4 0+28+24+8
ADDRLP4 0+28+24+8
INDIRF4
ADDRLP4 152
INDIRF4
MULF4
ASGNF4
line 2377
;2377:      re.nonNormalizedAxes = qtrue;
ADDRLP4 0+64
CNSTI4 1
ASGNI4
line 2378
;2378:    }
ADDRGP4 $1107
JUMPV
LABELV $1106
line 2380
;2379:    else
;2380:      re.nonNormalizedAxes = qfalse;
ADDRLP4 0+64
CNSTI4 0
ASGNI4
LABELV $1107
line 2382
;2381:
;2382:    p->lf.animation = &bp->modelAnimation;
ADDRFP4 0
INDIRP4
CNSTI4 280
ADDP4
ADDRLP4 140
INDIRP4
CNSTI4 3384
ADDP4
ASGNP4
line 2385
;2383:
;2384:    //run animation
;2385:    CG_RunLerpFrame( &p->lf );
ADDRFP4 0
INDIRP4
CNSTI4 240
ADDP4
ARGP4
ADDRGP4 CG_RunLerpFrame
CALLV
pop
line 2387
;2386:
;2387:    re.oldframe = p->lf.oldFrame;
ADDRLP4 0+96
ADDRFP4 0
INDIRP4
CNSTI4 240
ADDP4
INDIRI4
ASGNI4
line 2388
;2388:    re.frame    = p->lf.frame;
ADDRLP4 0+80
ADDRFP4 0
INDIRP4
CNSTI4 248
ADDP4
INDIRI4
ASGNI4
line 2389
;2389:    re.backlerp = p->lf.backlerp;
ADDRLP4 0+100
ADDRFP4 0
INDIRP4
CNSTI4 256
ADDP4
INDIRF4
ASGNF4
line 2390
;2390:  }
LABELV $1082
LABELV $1035
line 2392
;2391:
;2392:  if( bps->thirdPersonOnly &&
ADDRLP4 168
INDIRP4
CNSTI4 84
ADDP4
INDIRI4
CNSTI4 0
EQI4 $1155
ADDRLP4 148
INDIRP4
CNSTI4 4
ADDP4
ARGP4
ADDRLP4 244
ADDRGP4 CG_AttachmentCentNum
CALLI4
ASGNI4
ADDRLP4 244
INDIRI4
ADDRGP4 cg+36
INDIRP4
CNSTI4 184
ADDP4
INDIRI4
NEI4 $1155
ADDRGP4 cg+107628
INDIRI4
CNSTI4 0
NEI4 $1155
line 2395
;2393:      CG_AttachmentCentNum( &ps->attachment ) == cg.snap->ps.clientNum &&
;2394:      !cg.renderingThirdPerson )
;2395:    re.renderfx |= RF_THIRD_PERSON;
ADDRLP4 0+4
ADDRLP4 0+4
INDIRI4
CNSTI4 2
BORI4
ASGNI4
LABELV $1155
line 2397
;2396:
;2397:  if( bp->dynamicLight && !( re.renderfx & RF_THIRD_PERSON ) )
ADDRLP4 248
CNSTI4 0
ASGNI4
ADDRLP4 140
INDIRP4
CNSTI4 396
ADDP4
INDIRI4
ADDRLP4 248
INDIRI4
EQI4 $1160
ADDRLP4 0+4
INDIRI4
CNSTI4 2
BANDI4
ADDRLP4 248
INDIRI4
NEI4 $1160
line 2398
;2398:  {
line 2399
;2399:    trap_R_AddLightToScene( p->origin,
ADDRLP4 252
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 252
INDIRP4
CNSTI4 8
ADDP4
INDIRI4
ARGI4
ADDRLP4 252
INDIRP4
CNSTI4 12
ADDP4
INDIRI4
ARGI4
ADDRLP4 252
INDIRP4
CNSTI4 204
ADDP4
INDIRI4
ARGI4
ADDRLP4 256
ADDRGP4 CG_CalculateTimeFrac
CALLF4
ASGNF4
ADDRLP4 260
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 260
INDIRP4
CNSTI4 212
ADDP4
INDIRF4
ARGF4
ADDRLP4 260
INDIRP4
CNSTI4 220
ADDP4
INDIRF4
ARGF4
ADDRLP4 256
INDIRF4
ARGF4
ADDRLP4 264
ADDRGP4 CG_LerpValues
CALLF4
ASGNF4
ADDRFP4 0
INDIRP4
CNSTI4 32
ADDP4
ARGP4
ADDRLP4 264
INDIRF4
ARGF4
ADDRLP4 272
CNSTF4 1132396544
ASGNF4
ADDRLP4 140
INDIRP4
CNSTI4 428
ADDP4
INDIRU1
CVUI4 1
CVIF4 4
ADDRLP4 272
INDIRF4
DIVF4
ARGF4
ADDRLP4 140
INDIRP4
CNSTI4 429
ADDP4
INDIRU1
CVUI4 1
CVIF4 4
ADDRLP4 272
INDIRF4
DIVF4
ARGF4
ADDRLP4 140
INDIRP4
CNSTI4 430
ADDP4
INDIRU1
CVUI4 1
CVIF4 4
ADDRLP4 272
INDIRF4
DIVF4
ARGF4
ADDRGP4 trap_R_AddLightToScene
CALLV
pop
line 2405
;2400:      CG_LerpValues( p->dLightRadius.initial, p->dLightRadius.final,
;2401:        CG_CalculateTimeFrac( p->birthTime, p->lifeTime, p->dLightRadius.delay ) ),
;2402:        (float)bp->dLightColor[ 0 ] / (float)0xFF,
;2403:        (float)bp->dLightColor[ 1 ] / (float)0xFF,
;2404:        (float)bp->dLightColor[ 2 ] / (float)0xFF );
;2405:  }
LABELV $1160
line 2407
;2406:
;2407:  VectorCopy( p->origin, re.origin );
ADDRLP4 0+68
ADDRFP4 0
INDIRP4
CNSTI4 32
ADDP4
INDIRB
ASGNB 12
line 2409
;2408:
;2409:  trap_R_AddRefEntityToScene( &re );
ADDRLP4 0
ARGP4
ADDRGP4 trap_R_AddRefEntityToScene
CALLV
pop
line 2410
;2410:}
LABELV $1031
endproc CG_RenderParticle 324 20
export CG_AddParticles
proc CG_AddParticles 24 16
line 2420
;2411:
;2412:/*
;2413:===============
;2414:CG_AddParticles
;2415:
;2416:Add particles to the scene
;2417:===============
;2418:*/
;2419:void CG_AddParticles( void )
;2420:{
line 2423
;2421:  int           i;
;2422:  particle_t    *p;
;2423:  int           numPS = 0, numPE = 0, numP = 0;
ADDRLP4 8
CNSTI4 0
ASGNI4
ADDRLP4 12
CNSTI4 0
ASGNI4
ADDRLP4 16
CNSTI4 0
ASGNI4
line 2426
;2424:
;2425:  //remove expired particle systems
;2426:  CG_GarbageCollectParticleSystems( );
ADDRGP4 CG_GarbageCollectParticleSystems
CALLV
pop
line 2429
;2427:
;2428:  //check each ejector and introduce any new particles
;2429:  CG_SpawnNewParticles( );
ADDRGP4 CG_SpawnNewParticles
CALLV
pop
line 2432
;2430:
;2431:  //sorting
;2432:  CG_CompactAndSortParticles( );
ADDRGP4 CG_CompactAndSortParticles
CALLV
pop
line 2434
;2433:
;2434:  for( i = 0; i < MAX_PARTICLES; i++ )
ADDRLP4 0
CNSTI4 0
ASGNI4
LABELV $1165
line 2435
;2435:  {
line 2436
;2436:    p = sortedParticles[ i ];
ADDRLP4 4
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 sortedParticles
ADDP4
INDIRP4
ASGNP4
line 2438
;2437:
;2438:    if( p->valid )
ADDRLP4 4
INDIRP4
CNSTI4 324
ADDP4
INDIRI4
CNSTI4 0
EQI4 $1169
line 2439
;2439:    {
line 2440
;2440:      if( p->birthTime + p->lifeTime > cg.time )
ADDRLP4 4
INDIRP4
CNSTI4 8
ADDP4
INDIRI4
ADDRLP4 4
INDIRP4
CNSTI4 12
ADDP4
INDIRI4
ADDI4
ADDRGP4 cg+107604
INDIRI4
LEI4 $1171
line 2441
;2441:      {
line 2443
;2442:        //particle is active
;2443:        CG_EvaluateParticlePhysics( p );
ADDRLP4 4
INDIRP4
ARGP4
ADDRGP4 CG_EvaluateParticlePhysics
CALLV
pop
line 2444
;2444:        CG_RenderParticle( p );
ADDRLP4 4
INDIRP4
ARGP4
ADDRGP4 CG_RenderParticle
CALLV
pop
line 2445
;2445:      }
ADDRGP4 $1172
JUMPV
LABELV $1171
line 2447
;2446:      else
;2447:        CG_DestroyParticle( p, NULL );
ADDRLP4 4
INDIRP4
ARGP4
CNSTP4 0
ARGP4
ADDRGP4 CG_DestroyParticle
CALLV
pop
LABELV $1172
line 2448
;2448:    }
LABELV $1169
line 2449
;2449:  }
LABELV $1166
line 2434
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 960
LTI4 $1165
line 2451
;2450:
;2451:  if( cg_debugParticles.integer >= 2 )
ADDRGP4 cg_debugParticles+12
INDIRI4
CNSTI4 2
LTI4 $1174
line 2452
;2452:  {
line 2453
;2453:    for( i = 0; i < MAX_PARTICLE_SYSTEMS; i++ )
ADDRLP4 0
CNSTI4 0
ASGNI4
LABELV $1177
line 2454
;2454:      if( particleSystems[ i ].valid )
CNSTI4 1408
ADDRLP4 0
INDIRI4
MULI4
ADDRGP4 particleSystems+1384
ADDP4
INDIRI4
CNSTI4 0
EQI4 $1181
line 2455
;2455:        numPS++;
ADDRLP4 8
ADDRLP4 8
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $1181
LABELV $1178
line 2453
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 48
LTI4 $1177
line 2457
;2456:
;2457:    for( i = 0; i < MAX_PARTICLE_EJECTORS; i++ )
ADDRLP4 0
CNSTI4 0
ASGNI4
LABELV $1184
line 2458
;2458:      if( particleEjectors[ i ].valid )
CNSTI4 52
ADDRLP4 0
INDIRI4
MULI4
ADDRGP4 particleEjectors+48
ADDP4
INDIRI4
CNSTI4 0
EQI4 $1188
line 2459
;2459:        numPE++;
ADDRLP4 12
ADDRLP4 12
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $1188
LABELV $1185
line 2457
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 192
LTI4 $1184
line 2461
;2460:
;2461:    for( i = 0; i < MAX_PARTICLES; i++ )
ADDRLP4 0
CNSTI4 0
ASGNI4
LABELV $1191
line 2462
;2462:      if( particles[ i ].valid )
CNSTI4 336
ADDRLP4 0
INDIRI4
MULI4
ADDRGP4 particles+324
ADDP4
INDIRI4
CNSTI4 0
EQI4 $1195
line 2463
;2463:        numP++;
ADDRLP4 16
ADDRLP4 16
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $1195
LABELV $1192
line 2461
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 960
LTI4 $1191
line 2465
;2464:
;2465:    CG_Printf( "PS: %d  PE: %d  P: %d\n", numPS, numPE, numP );
ADDRGP4 $1198
ARGP4
ADDRLP4 8
INDIRI4
ARGI4
ADDRLP4 12
INDIRI4
ARGI4
ADDRLP4 16
INDIRI4
ARGI4
ADDRGP4 CG_Printf
CALLV
pop
line 2466
;2466:  }
LABELV $1174
line 2467
;2467:}
LABELV $1164
endproc CG_AddParticles 24 16
export CG_ParticleSystemEntity
proc CG_ParticleSystemEntity 28 8
line 2477
;2468:
;2469:/*
;2470:===============
;2471:CG_ParticleSystemEntity
;2472:
;2473:Particle system entity client code
;2474:===============
;2475:*/
;2476:void CG_ParticleSystemEntity( centity_t *cent )
;2477:{
line 2480
;2478:  entityState_t *es;
;2479:
;2480:  es = &cent->currentState;
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
line 2482
;2481:
;2482:  if( es->eFlags & EF_NODRAW )
ADDRLP4 0
INDIRP4
CNSTI4 8
ADDP4
INDIRI4
CNSTI4 256
BANDI4
CNSTI4 0
EQI4 $1200
line 2483
;2483:  {
line 2484
;2484:    if( CG_IsParticleSystemValid( &cent->entityPS ) && CG_IsParticleSystemInfinite( cent->entityPS ) )
ADDRFP4 0
INDIRP4
CNSTI4 1684
ADDP4
ARGP4
ADDRLP4 4
ADDRGP4 CG_IsParticleSystemValid
CALLI4
ASGNI4
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $1199
ADDRFP4 0
INDIRP4
CNSTI4 1684
ADDP4
INDIRP4
ARGP4
ADDRLP4 8
ADDRGP4 CG_IsParticleSystemInfinite
CALLI4
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 0
EQI4 $1199
line 2485
;2485:      CG_DestroyParticleSystem( &cent->entityPS );
ADDRFP4 0
INDIRP4
CNSTI4 1684
ADDP4
ARGP4
ADDRGP4 CG_DestroyParticleSystem
CALLV
pop
line 2487
;2486:
;2487:    return;
ADDRGP4 $1199
JUMPV
LABELV $1200
line 2490
;2488:  }
;2489:
;2490:  if( !CG_IsParticleSystemValid( &cent->entityPS ) && !cent->entityPSMissing )
ADDRFP4 0
INDIRP4
CNSTI4 1684
ADDP4
ARGP4
ADDRLP4 4
ADDRGP4 CG_IsParticleSystemValid
CALLI4
ASGNI4
ADDRLP4 8
CNSTI4 0
ASGNI4
ADDRLP4 4
INDIRI4
ADDRLP4 8
INDIRI4
NEI4 $1204
ADDRFP4 0
INDIRP4
CNSTI4 1688
ADDP4
INDIRI4
ADDRLP4 8
INDIRI4
NEI4 $1204
line 2491
;2491:  {
line 2492
;2492:    cent->entityPS = CG_SpawnNewParticleSystem( cgs.gameParticleSystems[ es->modelindex ] );
ADDRLP4 0
INDIRP4
CNSTI4 160
ADDP4
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 cgs+36028
ADDP4
INDIRI4
ARGI4
ADDRLP4 12
ADDRGP4 CG_SpawnNewParticleSystem
CALLP4
ASGNP4
ADDRFP4 0
INDIRP4
CNSTI4 1684
ADDP4
ADDRLP4 12
INDIRP4
ASGNP4
line 2494
;2493:
;2494:    if( CG_IsParticleSystemValid( &cent->entityPS ) )
ADDRFP4 0
INDIRP4
CNSTI4 1684
ADDP4
ARGP4
ADDRLP4 16
ADDRGP4 CG_IsParticleSystemValid
CALLI4
ASGNI4
ADDRLP4 16
INDIRI4
CNSTI4 0
EQI4 $1207
line 2495
;2495:    {
line 2496
;2496:      CG_SetAttachmentPoint( &cent->entityPS->attachment, cent->lerpOrigin );
ADDRLP4 20
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 20
INDIRP4
CNSTI4 1684
ADDP4
INDIRP4
CNSTI4 4
ADDP4
ARGP4
ADDRLP4 20
INDIRP4
CNSTI4 1556
ADDP4
ARGP4
ADDRGP4 CG_SetAttachmentPoint
CALLV
pop
line 2497
;2497:      CG_SetAttachmentCent( &cent->entityPS->attachment, cent );
ADDRLP4 24
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 24
INDIRP4
CNSTI4 1684
ADDP4
INDIRP4
CNSTI4 4
ADDP4
ARGP4
ADDRLP4 24
INDIRP4
ARGP4
ADDRGP4 CG_SetAttachmentCent
CALLV
pop
line 2498
;2498:      CG_AttachToPoint( &cent->entityPS->attachment );
ADDRFP4 0
INDIRP4
CNSTI4 1684
ADDP4
INDIRP4
CNSTI4 4
ADDP4
ARGP4
ADDRGP4 CG_AttachToPoint
CALLV
pop
line 2499
;2499:    }
ADDRGP4 $1208
JUMPV
LABELV $1207
line 2501
;2500:    else
;2501:      cent->entityPSMissing = qtrue;
ADDRFP4 0
INDIRP4
CNSTI4 1688
ADDP4
CNSTI4 1
ASGNI4
LABELV $1208
line 2502
;2502:  }
LABELV $1204
line 2503
;2503:}
LABELV $1199
endproc CG_ParticleSystemEntity 28 8
export CG_DestroyTestPS_f
proc CG_DestroyTestPS_f 4 4
line 2516
;2504:
;2505:static particleSystem_t *testPS;
;2506:static qhandle_t        testPSHandle;
;2507:
;2508:/*
;2509:===============
;2510:CG_DestroyTestPS_f
;2511:
;2512:Destroy the test a particle system
;2513:===============
;2514:*/
;2515:void CG_DestroyTestPS_f( void )
;2516:{
line 2517
;2517:  if( CG_IsParticleSystemValid( &testPS ) )
ADDRGP4 testPS
ARGP4
ADDRLP4 0
ADDRGP4 CG_IsParticleSystemValid
CALLI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 0
EQI4 $1210
line 2518
;2518:    CG_DestroyParticleSystem( &testPS );
ADDRGP4 testPS
ARGP4
ADDRGP4 CG_DestroyParticleSystem
CALLV
pop
LABELV $1210
line 2519
;2519:}
LABELV $1209
endproc CG_DestroyTestPS_f 4 4
lit
align 4
LABELV $1213
byte 4 0
byte 4 0
byte 4 1065353216
export CG_TestPS_f
code
proc CG_TestPS_f 112 12
line 2529
;2520:
;2521:/*
;2522:===============
;2523:CG_TestPS_f
;2524:
;2525:Test a particle system
;2526:===============
;2527:*/
;2528:void CG_TestPS_f( void )
;2529:{
line 2531
;2530:  vec3_t  origin;
;2531:  vec3_t  up = { 0.0f, 0.0f, 1.0f };
ADDRLP4 76
ADDRGP4 $1213
INDIRB
ASGNB 12
line 2534
;2532:  char    psName[ MAX_QPATH ];
;2533:
;2534:  if( trap_Argc( ) < 2 )
ADDRLP4 88
ADDRGP4 trap_Argc
CALLI4
ASGNI4
ADDRLP4 88
INDIRI4
CNSTI4 2
GEI4 $1214
line 2535
;2535:    return;
ADDRGP4 $1212
JUMPV
LABELV $1214
line 2537
;2536:
;2537:  Q_strncpyz( psName, CG_Argv( 1 ), MAX_QPATH );
CNSTI4 1
ARGI4
ADDRLP4 92
ADDRGP4 CG_Argv
CALLP4
ASGNP4
ADDRLP4 0
ARGP4
ADDRLP4 92
INDIRP4
ARGP4
CNSTI4 64
ARGI4
ADDRGP4 Q_strncpyz
CALLV
pop
line 2538
;2538:  testPSHandle = CG_RegisterParticleSystem( psName );
ADDRLP4 0
ARGP4
ADDRLP4 96
ADDRGP4 CG_RegisterParticleSystem
CALLI4
ASGNI4
ADDRGP4 testPSHandle
ADDRLP4 96
INDIRI4
ASGNI4
line 2540
;2539:
;2540:  if( testPSHandle )
ADDRGP4 testPSHandle
INDIRI4
CNSTI4 0
EQI4 $1216
line 2541
;2541:  {
line 2542
;2542:    CG_DestroyTestPS_f( );
ADDRGP4 CG_DestroyTestPS_f
CALLV
pop
line 2544
;2543:
;2544:    testPS = CG_SpawnNewParticleSystem( testPSHandle );
ADDRGP4 testPSHandle
INDIRI4
ARGI4
ADDRLP4 100
ADDRGP4 CG_SpawnNewParticleSystem
CALLP4
ASGNP4
ADDRGP4 testPS
ADDRLP4 100
INDIRP4
ASGNP4
line 2546
;2545:
;2546:    VectorMA( cg.refdef.vieworg, 100, cg.refdef.viewaxis[ 0 ], origin );
ADDRLP4 104
CNSTF4 1120403456
ASGNF4
ADDRLP4 64
ADDRGP4 cg+110040+24
INDIRF4
ADDRLP4 104
INDIRF4
ADDRGP4 cg+110040+36
INDIRF4
MULF4
ADDF4
ASGNF4
ADDRLP4 64+4
ADDRGP4 cg+110040+24+4
INDIRF4
ADDRLP4 104
INDIRF4
ADDRGP4 cg+110040+36+4
INDIRF4
MULF4
ADDF4
ASGNF4
ADDRLP4 64+8
ADDRGP4 cg+110040+24+8
INDIRF4
CNSTF4 1120403456
ADDRGP4 cg+110040+36+8
INDIRF4
MULF4
ADDF4
ASGNF4
line 2548
;2547:
;2548:    if( CG_IsParticleSystemValid( &testPS ) )
ADDRGP4 testPS
ARGP4
ADDRLP4 108
ADDRGP4 CG_IsParticleSystemValid
CALLI4
ASGNI4
ADDRLP4 108
INDIRI4
CNSTI4 0
EQI4 $1236
line 2549
;2549:    {
line 2550
;2550:      CG_SetAttachmentPoint( &testPS->attachment, origin );
ADDRGP4 testPS
INDIRP4
CNSTI4 4
ADDP4
ARGP4
ADDRLP4 64
ARGP4
ADDRGP4 CG_SetAttachmentPoint
CALLV
pop
line 2551
;2551:      CG_SetParticleSystemNormal( testPS, up );
ADDRGP4 testPS
INDIRP4
ARGP4
ADDRLP4 76
ARGP4
ADDRGP4 CG_SetParticleSystemNormal
CALLV
pop
line 2552
;2552:      CG_AttachToPoint( &testPS->attachment );
ADDRGP4 testPS
INDIRP4
CNSTI4 4
ADDP4
ARGP4
ADDRGP4 CG_AttachToPoint
CALLV
pop
line 2553
;2553:    }
LABELV $1236
line 2554
;2554:  }
LABELV $1216
line 2555
;2555:}
LABELV $1212
endproc CG_TestPS_f 112 12
bss
align 4
LABELV testPSHandle
skip 4
align 4
LABELV testPS
skip 4
align 4
LABELV radixBuffer
skip 3840
align 4
LABELV sortedParticles
skip 3840
align 4
LABELV particles
skip 322560
align 4
LABELV particleEjectors
skip 9984
align 4
LABELV particleSystems
skip 67584
align 4
LABELV baseParticles
skip 10518528
align 4
LABELV baseParticleEjectors
skip 43008
align 4
LABELV baseParticleSystems
skip 17664
import trap_GetDemoName
import trap_GetDemoPos
import trap_GetDemoState
import trap_GetEntityToken
import trap_getCameraInfo
import trap_startCamera
import trap_loadCamera
import trap_SnapVector
import trap_CIN_SetExtents
import trap_CIN_DrawCinematic
import trap_CIN_RunCinematic
import trap_CIN_StopCinematic
import trap_CIN_PlayCinematic
import trap_Key_SetBinding
import trap_Key_GetBindingBuf
import trap_Key_KeynumToStringBuf
import trap_Key_GetKey
import trap_Key_SetCatcher
import trap_Key_GetCatcher
import trap_Key_IsDown
import trap_R_RegisterFont
import trap_MemoryRemaining
import testPrintFloat
import testPrintInt
import trap_SetUserCmdValue
import trap_GetUserCmd
import trap_GetCurrentCmdNumber
import trap_GetServerCommand
import trap_GetSnapshot
import trap_GetCurrentSnapshotNumber
import trap_GetGameState
import trap_GetGlconfig
import trap_R_RemapShader
import trap_R_LerpTag
import trap_R_ModelBounds
import trap_R_DrawStretchPic
import trap_R_SetColor
import trap_R_RenderScene
import trap_R_LightForPoint
import trap_R_AddAdditiveLightToScene
import trap_R_AddLightToScene
import trap_R_AddPolysToScene
import trap_R_AddPolyToScene
import trap_R_AddRefEntityToScene
import trap_R_ClearScene
import trap_R_RegisterShaderNoMip
import trap_R_RegisterShader
import trap_R_RegisterSkin
import trap_R_RegisterModel
import trap_R_LoadWorldMap
import trap_S_StopBackgroundTrack
import trap_S_StartBackgroundTrack
import trap_S_RegisterSound
import trap_S_Respatialize
import trap_S_UpdateEntityPosition
import trap_S_AddRealLoopingSound
import trap_S_AddLoopingSound
import trap_S_ClearLoopingSounds
import trap_S_StartLocalSound
import trap_S_StopLoopingSound
import trap_S_StartSound
import trap_CM_MarkFragments
import trap_CM_TransformedBiSphereTrace
import trap_CM_BiSphereTrace
import trap_CM_TransformedCapsuleTrace
import trap_CM_CapsuleTrace
import trap_CM_TransformedBoxTrace
import trap_CM_BoxTrace
import trap_CM_TransformedPointContents
import trap_CM_PointContents
import trap_CM_TempBoxModel
import trap_CM_InlineModel
import trap_CM_NumInlineModels
import trap_CM_LoadMap
import trap_UpdateScreen
import trap_SendClientCommand
import trap_AddCommand
import trap_SendConsoleCommand
import trap_FS_GetFileList
import trap_FS_Seek
import trap_FS_FCloseFile
import trap_FS_Write
import trap_FS_Read
import trap_FS_FOpenFile
import trap_LiteralArgs
import trap_Args
import trap_Argv
import trap_Argc
import trap_Cvar_VariableStringBuffer
import trap_Cvar_Set
import trap_Cvar_Update
import trap_Cvar_Register
import trap_Milliseconds
import trap_Error
import trap_Print
import CG_TutorialText
import CG_WritePTRCode
import CG_ReadPTRCode
import CG_DestroyTestTS_f
import CG_TestTS_f
import CG_AddTrails
import CG_IsTrailSystemValid
import CG_DestroyTrailSystem
import CG_SpawnNewTrailSystem
import CG_RegisterTrailSystem
import CG_LoadTrailSystems
import CG_SetAttachmentOffset
import CG_SetAttachmentParticle
import CG_SetAttachmentTag
import CG_SetAttachmentCent
import CG_SetAttachmentPoint
import CG_AttachToParticle
import CG_AttachToTag
import CG_AttachToCent
import CG_AttachToPoint
import CG_Attached
import CG_AttachmentCentNum
import CG_AttachmentVelocity
import CG_AttachmentAxis
import CG_AttachmentDir
import CG_AttachmentPoint
import CG_DefragmentMemory
import CG_Free
import CG_Alloc
import CG_InitMemory
import CG_CheckChangedPredictableEvents
import CG_TransitionPlayerState
import CG_Respawn
import CG_ShaderStateChanged
import CG_SetConfigValues
import CG_ParseServerinfo
import CG_ExecuteNewServerCommands
import CG_RequestScores
import CG_InitConsoleCommands
import CG_ConsoleCommand
import CG_ProcessSnapshots
import CG_ImpactMark
import CG_AddMarks
import CG_InitMarkPolys
import CG_AlienSense
import CG_Scanner
import CG_UpdateEntityPositions
import CG_DrawItemSelectText
import CG_DrawItemSelect
import CG_AddPlayerWeapon
import CG_AddViewWeapon
import CG_ShotgunFire
import CG_Bullet
import CG_MissileHitPlayer
import CG_MissileHitWall
import CG_FireWeapon
import CG_RegisterWeapon
import CG_InitWeapons
import CG_RegisterUpgrade
import CG_InitUpgrades
import CG_Weapon_f
import CG_PrevWeapon_f
import CG_NextWeapon_f
import CG_PositionRotatedEntityOnTag
import CG_PositionEntityOnTag
import CG_AdjustPositionForMover
import CG_Beam
import CG_AddPacketEntities
import CG_SetEntitySoundPosition
import CG_DrawBoundingBox
import CG_PainEvent
import CG_EntityEvent
import CG_CheckEvents
import CG_PredictPlayerState
import CG_BiSphereTrace
import CG_CapTrace
import CG_Trace
import CG_PointContents
import CG_BuildSolidList
import CG_ModelDoor
import CG_AnimMapObj
import CG_RunLerpFrame
import CG_AlienBuildableExplosion
import CG_HumanBuildableExplosion
import CG_InitBuildables
import CG_Buildable
import CG_GhostBuildable
import CG_AtHighestClass
import CG_Bleed
import CG_PlayerOnFire
import CG_PlayerDisconnect
import CG_CustomSound
import CG_PrecacheClientInfo
import CG_NewClientInfo
import CG_AddRefEntityWithPowerups
import CG_ResetPlayerEntity
import CG_Corpse
import CG_Player
import CG_ResetPainBlend
import CG_UpdateMediaFraction
import CG_DrawLoadingScreen
import CG_Text_PaintChar
import CG_GetKillerText
import CG_GetTeamColor
import CG_InitTeamChat
import CG_SetPrintString
import CG_RunMenuScript
import CG_GetValue
import CG_Text_Height
import CG_Text_Width
import CG_Text_Paint
import CG_OwnerDraw
import CG_DrawActive
import CG_CenterPrint
import CG_AddLagometerSnapshotInfo
import CG_AddLagometerFrameInfo
import teamChat2
import teamChat1
import systemChat
import numSortedTeamPlayers
import sortedTeamPlayers
import CG_DrawTopBottom
import CG_DrawSides
import CG_DrawRect
import CG_GetColorForHealth
import CG_ColorForHealth
import CG_TileClear
import CG_FadeColor
import CG_DrawStrlen
import CG_DrawFadePic
import CG_DrawPic
import CG_FillRect
import CG_AdjustFrom640
import CG_DrawPlane
import CG_DrawActiveFrame
import CG_AddBufferedSound
import CG_TestModelPrevSkin_f
import CG_TestModelNextSkin_f
import CG_TestModelPrevFrame_f
import CG_TestModelNextFrame_f
import CG_TestGun_f
import CG_TestModel_f
import CG_addSmoothOp
import CG_AddNotifyText
import CG_RemoveNotifyLine
import CG_FileExists
import CG_BuildSpectatorString
import CG_SetScoreSelection
import CG_EventHandling
import CG_MouseEvent
import CG_KeyEvent
import CG_LoadMenus
import CG_LastAttacker
import CG_CrosshairPlayer
import CG_UpdateCvars
import CG_PlayerCount
import CG_StartMusic
import CG_Error
import CG_Printf
import CG_Argv
import CG_ConfigString
import cg_debugRandom
import ui_humanTeamVoteActive
import ui_alienTeamVoteActive
import ui_voteActive
import ui_loading
import ui_dialog
import ui_stages
import ui_carriage
import ui_currentClass
import cg_painBlendZoom
import cg_painBlendScale
import cg_painBlendMax
import cg_painBlendDownRate
import cg_painBlendUpRate
import cg_tutorial
import cg_disableScannerPlane
import cg_disableWarningDialogs
import cg_debugPVS
import cg_debugTrails
import cg_debugParticles
import cg_lightFlare
import cg_consoleLatency
import cg_depthSortParticles
import cg_wwToggle
import cg_wwFollow
import cg_wwSmoothTime
import cg_debugAlloc
import cg_drawBBOX
import cg_drawSurfNormal
import cg_creepRes
import cg_trueLightning
import cg_oldPlasma
import cg_oldRocket
import cg_oldRail
import cg_noProjectileTrail
import cg_noTaunt
import cg_bigFont
import cg_smallFont
import cg_cameraMode
import cg_timescale
import cg_timescaleFadeSpeed
import cg_timescaleFadeEnd
import cg_cameraOrbitDelay
import cg_cameraOrbit
import pmove_msec
import pmove_fixed
import cg_smoothClients
import cg_scorePlum
import cg_noVoiceText
import cg_noVoiceChats
import cg_teamChatsOnly
import cg_drawFriend
import cg_deferPlayers
import cg_predictItems
import cg_blood
import cg_paused
import cg_buildScript
import cg_forceModel
import cg_stats
import cg_teamChatHeight
import cg_teamChatTime
import cg_synchronousClients
import cg_drawAttacker
import cg_lagometer
import cg_stereoSeparation
import cg_thirdPersonhax
import cg_thirdPerson
import cg_thirdPersonAngle
import cg_thirdPersonRangehax
import cg_thirdPersonRange
import cg_zoomFov
import cg_fov
import cg_simpleItems
import cg_ignore
import cg_autoswitch
import cg_tracerLength
import cg_tracerWidth
import cg_tracerChance
import cg_viewsize
import cg_drawGun
import cg_gun_z
import cg_gun_y
import cg_gun_x
import cg_gun_frame
import cg_brassTime
import cg_addMarks
import cg_footsteps
import cg_showmiss
import cg_noPlayerAnims
import cg_debugMove
import cg_nopredict
import cg_errorDecay
import cg_railTrailTime
import cg_teslaTrailTime
import cg_debugEvents
import cg_debugPosition
import cg_debugAnim
import cg_animSpeed
import cg_draw2D
import cg_drawStatus
import cg_crosshairY
import cg_crosshairX
import cg_teamOverlayUserinfo
import cg_drawTeamOverlay
import cg_drawRewards
import cg_drawCrosshairNames
import cg_drawCrosshair
import cg_drawAmmoWarning
import cg_drawIcons
import cg_draw3dIcons
import cg_drawSnapshot
import cg_drawDemoState
import cg_drawFPS
import cg_drawTimer
import cg_gibs
import cg_shadows
import cg_swingSpeed
import cg_bobroll
import cg_bobpitch
import cg_bobup
import cg_runroll
import cg_runpitch
import cg_centertime
import cg_markPolys
import cg_buildables
import cg_upgrades
import cg_weapons
import cg_entities
import cg
import cgs
import g_nameBind2
import g_nameBind1
import BindingFromName
import trap_PC_SourceFileAndLine
import trap_PC_ReadToken
import trap_PC_FreeSource
import trap_PC_LoadSource
import trap_PC_AddGlobalDefine
import Item_Text_AutoWrapped_Paint
import Controls_SetDefaults
import Controls_SetConfig
import Controls_GetConfig
import UI_OutOfMemory
import UI_InitMemory
import UI_Alloc
import Display_CacheAll
import Menu_SetFeederSelection
import Menu_Paint
import Menus_CloseAll
import LerpColor
import Display_HandleKey
import Menus_CloseByName
import Menus_ShowByName
import Menus_FindByName
import Menus_OpenByName
import Display_KeyBindPending
import Display_CursorType
import Display_MouseMove
import Display_CaptureItem
import Display_GetContext
import Menus_Activate
import Menus_AnyFullScreenVisible
import Menu_Reset
import Menus_ActivateByName
import Menu_PaintAll
import Menu_New
import Menu_Count
import PC_Script_Parse
import PC_String_Parse
import PC_Rect_Parse
import PC_Int_Parse
import PC_Color_Parse
import PC_Float_Parse
import Script_Parse
import String_Parse
import Rect_Parse
import Int_Parse
import Color_Parse
import Float_Parse
import Menu_ScrollFeeder
import Menu_HandleMouseMove
import Menu_HandleKey
import Menu_GetFocused
import Menu_PostParse
import Item_Init
import Menu_Init
import Display_ExpandMacros
import Init_Display
import String_Report
import String_Init
import String_Alloc
import BG_ClientListParse
import BG_ClientListString
import BG_ClientListRemove
import BG_ClientListAdd
import BG_ClientListTest
import BG_UpgradeClassAvailable
import BG_BuildableIsAllowed
import BG_ClassIsAllowed
import BG_UpgradeIsAllowed
import BG_WeaponIsAllowed
import BG_InitAllowedGameElements
import BG_ParseCSVBuildableList
import BG_ParseCSVClassList
import BG_ParseCSVEquipmentList
import atoi_neg
import atof_neg
import BG_PlayerTouchesItem
import BG_PlayerStateToEntityStateExtraPolate
import BG_PlayerStateToEntityState
import BG_AddPredictableEventToPlayerstate
import BG_EvaluateTrajectoryDelta
import BG_EvaluateTrajectory
import BG_FindTeamForUpgrade
import BG_FindUsableForUpgrade
import BG_FindPurchasableForUpgrade
import BG_FindIconForUpgrade
import BG_FindHumanNameForUpgrade
import BG_FindUpgradeNumForName
import BG_FindNameForUpgrade
import BG_FindSlotsForUpgrade
import BG_FindStagesForUpgrade
import BG_FindPriceForUpgrade
import BG_FindTeamForWeapon
import BG_FindBuildDelayForWeapon
import BG_FindLongRangedForWeapon
import BG_FindPurchasableForWeapon
import BG_FindZoomFovForWeapon
import BG_WeaponCanZoom
import BG_WeaponHasThirdMode
import BG_WeaponHasAltMode
import BG_FindKnockbackScaleForWeapon
import BG_FindReloadTimeForWeapon
import BG_FindRepeatRate3ForWeapon
import BG_FindRepeatRate2ForWeapon
import BG_FindRepeatRate1ForWeapon
import BG_FindUsesEnergyForWeapon
import BG_FindInfinteAmmoForWeapon
import BG_FindAmmoForWeapon
import BG_FindCrosshairSizeForWeapon
import BG_FindCrosshairForWeapon
import BG_FindIconForWeapon
import BG_FindModelsForWeapon
import BG_FindHumanNameForWeapon
import BG_FindWeaponNumForName
import BG_FindNameForWeapon
import BG_FindSlotsForWeapon
import BG_FindStagesForWeapon
import BG_FindPriceForWeapon
import BG_InitClassOverrides
import BG_FindValueOfClass
import BG_FindCostOfClass
import BG_ClassCanEvolveFromTo
import BG_FindBuildDistForClass
import BG_FindStartWeaponForClass
import BG_ClassHasAbility
import BG_FindSteptimeForClass
import BG_FindKnockbackScaleForClass
import BG_FindJumpMagnitudeForClass
import BG_FindStopSpeedForClass
import BG_FindFrictionForClass
import BG_FindAirAccelerationForClass
import BG_FindAccelerationForClass
import BG_FindSpeedForClass
import BG_FindBobCycleForClass
import BG_FindBobForClass
import BG_FindFovForClass
import BG_FindRegenRateForClass
import BG_FindFallDamageForClass
import BG_FindHealthForClass
import BG_FindViewheightForClass
import BG_FindZOffsetForClass
import BG_FindBBoxForClass
import BG_FindSpriteHeightForClass
import BG_FindStagesForClass
import BG_FindHudNameForClass
import BG_FindShadowScaleForClass
import BG_FindSkinNameForClass
import BG_FindModelScaleForClass
import BG_FindModelNameForClass
import BG_FindHumanNameForClassNum
import BG_FindNameForClassNum
import BG_FindClassNumForName
import BG_InitBuildableOverrides
import BG_FindTransparentTestForBuildable
import BG_FindReplaceableTestForBuildable
import BG_FindUniqueTestForBuildable
import BG_FindDCCTestForBuildable
import BG_FindCreepSizeForBuildable
import BG_FindCreepTestForBuildable
import BG_FindInvertNormalForBuildable
import BG_FindMinNormalForBuildable
import BG_FindProjTypeForBuildable
import BG_FindFireSpeedForBuildable
import BG_FindRangeForBuildable
import BG_FindUsableForBuildable
import BG_FindBuildTimeForBuildable
import BG_FindNextThinkForBuildable
import BG_FindAnimForBuildable
import BG_FindBuildWeaponForBuildable
import BG_FindTeamForBuildable
import BG_FindMODForBuildable
import BG_FindSplashRadiusForBuildable
import BG_FindSplashDamageForBuildable
import BG_FindStagesForBuildable
import BG_FindBuildPointsForBuildable
import BG_FindBounceForBuildable
import BG_FindTrajectoryForBuildable
import BG_FindRegenRateForBuildable
import BG_FindHealthForBuildable
import BG_FindZOffsetForBuildable
import BG_FindBBoxForBuildable
import BG_FindModelScaleForBuildable
import BG_FindModelsForBuildable
import BG_FindEntityNameForBuildable
import BG_FindHumanNameForBuildable
import BG_FindNameForBuildable
import BG_FindBuildNumForEntityName
import BG_FindBuildNumForName
import BG_GetValueOfEquipment
import BG_GetValueOfHuman
import BG_PositionBuildableRelativeToPlayer
import BG_RotateAxis
import BG_UpgradeIsActive
import BG_DeactivateUpgrade
import BG_ActivateUpgrade
import BG_InventoryContainsUpgrade
import BG_RemoveUpgradeFromInventory
import BG_AddUpgradeToInventory
import BG_InventoryContainsWeapon
import BG_RemoveWeaponFromInventory
import BG_AddWeaponToInventory
import BG_WeaponIsFull
import BG_PackAmmoArray
import BG_UnpackAmmoArray
import Pmove
import PM_UpdateViewAngles
import Com_Printf
import Com_Error
import Info_NextPair
import Info_Validate
import Info_SetValueForKey_Big
import Info_SetValueForKey
import Info_RemoveKey_big
import Info_RemoveKey
import Info_ValueForKey
import Com_TruncateLongString
import va
import Q_CountChar
import Q_CleanStr
import Q_PrintStrlen
import Q_strcat
import Q_strncpyz
import Q_stristr
import Q_strrchr
import Q_strupr
import Q_strlwr
import Q_stricmpn
import Q_strncmp
import Q_stricmp
import Q_isintegral
import Q_isanumber
import Q_isdigit
import Q_isalpha
import Q_isupper
import Q_islower
import Q_isprint
import Com_RandomBytes
import Com_SkipCharset
import Com_SkipTokens
import Com_sprintf
import Com_HexStrToInt
import Parse3DMatrix
import Parse2DMatrix
import Parse1DMatrix
import SkipRestOfLine
import SkipBracedSection
import COM_MatchToken
import COM_ParseWarning
import COM_ParseError
import COM_Compress
import COM_ParseExt
import COM_Parse
import COM_GetCurrentParseLine
import COM_BeginParseSession
import COM_DefaultExtension
import COM_StripExtension
import COM_GetExtension
import COM_SkipPath
import Com_Clamp
import DistanceBetweenLineSegments
import DistanceBetweenLineSegmentsSquared
import VectorMaxComponent
import VectorMinComponent
import pointToLineDistance
import VectorDistance
import ProjectPointOntoVector
import GetPerpendicularViewVector
import Q_isnan
import PerpendicularVector
import AngleVectors
import VectorMatrixMultiply
import MatrixMultiply
import MakeNormalVectors
import RotateAroundAxe
import RotateAroundDirection
import RotatePointAroundVector
import ProjectPointOnPlane
import PlaneFromPoints
import AngleDelta
import AngleNormalize180
import AngleNormalize360
import AnglesSubtract
import AngleSubtract
import LerpAngle
import AngleMod
import BoundsIntersectPoint
import BoundsIntersectSphere
import BoundsIntersect
import BoxOnPlaneSide
import SetPlaneSignbits
import AxisCopy
import AxisClear
import AxisToAngles
import AnglesToAxis
import vectoangles
import Q_crandom
import Q_random
import Q_rand
import Q_acos
import Q_log2
import VectorRotate
import Vector4Scale
import VectorNormalize2
import VectorNormalize
import CrossProduct
import VectorInverse
import VectorNormalizeFast
import DistanceSquared
import Distance
import VectorLengthSquared
import VectorLength
import VectorCompare
import AddPointToBounds
import ClearBounds
import RadiusFromBounds
import NormalizeColor
import ColorBytes4
import ColorBytes3
import _VectorMA
import _VectorScale
import _VectorCopy
import _VectorAdd
import _VectorSubtract
import _DotProduct
import ByteToDir
import DirToByte
import ClampShort
import ClampChar
import Q_rsqrt
import Q_fabs
import axisDefault
import vec3_origin
import g_color_table
import colorDkGrey
import colorMdGrey
import colorLtGrey
import colorWhite
import colorCyan
import colorMagenta
import colorYellow
import colorBlue
import colorGreen
import colorRed
import colorBlack
import bytedirs
import Hunk_Alloc
import FloatSwap
import LongSwap
import ShortSwap
import rint
import pow
import acos
import fabs
import abs
import tan
import atan2
import cos
import sin
import sqrt
import floor
import ceil
import memcpy
import memset
import memmove
import sscanf
import vsprintf
import _atoi
import atoi
import _atof
import atof
import toupper
import tolower
import strncpy
import strstr
import strrchr
import strchr
import strcmp
import strcpy
import strcat
import strlen
import rand
import srand
import qsort
lit
align 1
LABELV $1198
byte 1 80
byte 1 83
byte 1 58
byte 1 32
byte 1 37
byte 1 100
byte 1 32
byte 1 32
byte 1 80
byte 1 69
byte 1 58
byte 1 32
byte 1 37
byte 1 100
byte 1 32
byte 1 32
byte 1 80
byte 1 58
byte 1 32
byte 1 37
byte 1 100
byte 1 10
byte 1 0
align 1
LABELV $855
byte 1 80
byte 1 83
byte 1 32
byte 1 37
byte 1 115
byte 1 32
byte 1 103
byte 1 97
byte 1 114
byte 1 98
byte 1 97
byte 1 103
byte 1 101
byte 1 32
byte 1 99
byte 1 111
byte 1 108
byte 1 108
byte 1 101
byte 1 99
byte 1 116
byte 1 101
byte 1 100
byte 1 10
byte 1 0
align 1
LABELV $814
byte 1 94
byte 1 51
byte 1 87
byte 1 65
byte 1 82
byte 1 78
byte 1 73
byte 1 78
byte 1 71
byte 1 58
byte 1 32
byte 1 116
byte 1 114
byte 1 105
byte 1 101
byte 1 100
byte 1 32
byte 1 116
byte 1 111
byte 1 32
byte 1 116
byte 1 101
byte 1 115
byte 1 116
byte 1 32
byte 1 97
byte 1 110
byte 1 32
byte 1 105
byte 1 110
byte 1 118
byte 1 97
byte 1 108
byte 1 105
byte 1 100
byte 1 32
byte 1 112
byte 1 97
byte 1 114
byte 1 116
byte 1 105
byte 1 99
byte 1 108
byte 1 101
byte 1 32
byte 1 115
byte 1 121
byte 1 115
byte 1 116
byte 1 101
byte 1 109
byte 1 10
byte 1 0
align 1
LABELV $811
byte 1 94
byte 1 51
byte 1 87
byte 1 65
byte 1 82
byte 1 78
byte 1 73
byte 1 78
byte 1 71
byte 1 58
byte 1 32
byte 1 116
byte 1 114
byte 1 105
byte 1 101
byte 1 100
byte 1 32
byte 1 116
byte 1 111
byte 1 32
byte 1 116
byte 1 101
byte 1 115
byte 1 116
byte 1 32
byte 1 97
byte 1 32
byte 1 78
byte 1 85
byte 1 76
byte 1 76
byte 1 32
byte 1 112
byte 1 97
byte 1 114
byte 1 116
byte 1 105
byte 1 99
byte 1 108
byte 1 101
byte 1 32
byte 1 115
byte 1 121
byte 1 115
byte 1 116
byte 1 101
byte 1 109
byte 1 10
byte 1 0
align 1
LABELV $801
byte 1 80
byte 1 83
byte 1 32
byte 1 100
byte 1 101
byte 1 115
byte 1 116
byte 1 114
byte 1 111
byte 1 121
byte 1 101
byte 1 100
byte 1 10
byte 1 0
align 1
LABELV $797
byte 1 94
byte 1 51
byte 1 87
byte 1 65
byte 1 82
byte 1 78
byte 1 73
byte 1 78
byte 1 71
byte 1 58
byte 1 32
byte 1 116
byte 1 114
byte 1 105
byte 1 101
byte 1 100
byte 1 32
byte 1 116
byte 1 111
byte 1 32
byte 1 100
byte 1 101
byte 1 115
byte 1 116
byte 1 114
byte 1 111
byte 1 121
byte 1 32
byte 1 97
byte 1 32
byte 1 78
byte 1 85
byte 1 76
byte 1 76
byte 1 32
byte 1 112
byte 1 97
byte 1 114
byte 1 116
byte 1 105
byte 1 99
byte 1 108
byte 1 101
byte 1 32
byte 1 115
byte 1 121
byte 1 115
byte 1 116
byte 1 101
byte 1 109
byte 1 10
byte 1 0
align 1
LABELV $792
byte 1 94
byte 1 51
byte 1 87
byte 1 65
byte 1 82
byte 1 78
byte 1 73
byte 1 78
byte 1 71
byte 1 58
byte 1 32
byte 1 116
byte 1 114
byte 1 105
byte 1 101
byte 1 100
byte 1 32
byte 1 116
byte 1 111
byte 1 32
byte 1 109
byte 1 111
byte 1 100
byte 1 105
byte 1 102
byte 1 121
byte 1 32
byte 1 97
byte 1 32
byte 1 78
byte 1 85
byte 1 76
byte 1 76
byte 1 32
byte 1 112
byte 1 97
byte 1 114
byte 1 116
byte 1 105
byte 1 99
byte 1 108
byte 1 101
byte 1 32
byte 1 115
byte 1 121
byte 1 115
byte 1 116
byte 1 101
byte 1 109
byte 1 10
byte 1 0
align 1
LABELV $787
byte 1 94
byte 1 51
byte 1 87
byte 1 65
byte 1 82
byte 1 78
byte 1 73
byte 1 78
byte 1 71
byte 1 58
byte 1 32
byte 1 102
byte 1 97
byte 1 105
byte 1 108
byte 1 101
byte 1 100
byte 1 32
byte 1 116
byte 1 111
byte 1 32
byte 1 102
byte 1 105
byte 1 110
byte 1 100
byte 1 32
byte 1 111
byte 1 110
byte 1 68
byte 1 101
byte 1 97
byte 1 116
byte 1 104
byte 1 32
byte 1 115
byte 1 121
byte 1 115
byte 1 116
byte 1 101
byte 1 109
byte 1 32
byte 1 37
byte 1 115
byte 1 10
byte 1 0
align 1
LABELV $776
byte 1 94
byte 1 51
byte 1 87
byte 1 65
byte 1 82
byte 1 78
byte 1 73
byte 1 78
byte 1 71
byte 1 58
byte 1 32
byte 1 102
byte 1 97
byte 1 105
byte 1 108
byte 1 101
byte 1 100
byte 1 32
byte 1 116
byte 1 111
byte 1 32
byte 1 102
byte 1 105
byte 1 110
byte 1 100
byte 1 32
byte 1 99
byte 1 104
byte 1 105
byte 1 108
byte 1 100
byte 1 32
byte 1 37
byte 1 115
byte 1 10
byte 1 0
align 1
LABELV $761
byte 1 46
byte 1 46
byte 1 46
byte 1 108
byte 1 111
byte 1 97
byte 1 100
byte 1 105
byte 1 110
byte 1 103
byte 1 32
byte 1 39
byte 1 37
byte 1 115
byte 1 39
byte 1 10
byte 1 0
align 1
LABELV $760
byte 1 115
byte 1 99
byte 1 114
byte 1 105
byte 1 112
byte 1 116
byte 1 115
byte 1 47
byte 1 0
align 1
LABELV $755
byte 1 46
byte 1 112
byte 1 97
byte 1 114
byte 1 116
byte 1 105
byte 1 99
byte 1 108
byte 1 101
byte 1 0
align 1
LABELV $754
byte 1 115
byte 1 99
byte 1 114
byte 1 105
byte 1 112
byte 1 116
byte 1 115
byte 1 0
align 1
LABELV $740
byte 1 94
byte 1 49
byte 1 69
byte 1 82
byte 1 82
byte 1 79
byte 1 82
byte 1 58
byte 1 32
byte 1 112
byte 1 97
byte 1 114
byte 1 116
byte 1 105
byte 1 99
byte 1 108
byte 1 101
byte 1 32
byte 1 115
byte 1 121
byte 1 115
byte 1 116
byte 1 101
byte 1 109
byte 1 32
byte 1 97
byte 1 108
byte 1 114
byte 1 101
byte 1 97
byte 1 100
byte 1 121
byte 1 32
byte 1 110
byte 1 97
byte 1 109
byte 1 101
byte 1 100
byte 1 10
byte 1 0
align 1
LABELV $737
byte 1 94
byte 1 49
byte 1 69
byte 1 82
byte 1 82
byte 1 79
byte 1 82
byte 1 58
byte 1 32
byte 1 117
byte 1 110
byte 1 97
byte 1 109
byte 1 101
byte 1 100
byte 1 32
byte 1 112
byte 1 97
byte 1 114
byte 1 116
byte 1 105
byte 1 99
byte 1 108
byte 1 101
byte 1 32
byte 1 115
byte 1 121
byte 1 115
byte 1 116
byte 1 101
byte 1 109
byte 1 10
byte 1 0
align 1
LABELV $736
byte 1 94
byte 1 49
byte 1 69
byte 1 82
byte 1 82
byte 1 79
byte 1 82
byte 1 58
byte 1 32
byte 1 109
byte 1 97
byte 1 120
byte 1 105
byte 1 109
byte 1 117
byte 1 109
byte 1 32
byte 1 110
byte 1 117
byte 1 109
byte 1 98
byte 1 101
byte 1 114
byte 1 32
byte 1 111
byte 1 102
byte 1 32
byte 1 112
byte 1 97
byte 1 114
byte 1 116
byte 1 105
byte 1 99
byte 1 108
byte 1 101
byte 1 32
byte 1 115
byte 1 121
byte 1 115
byte 1 116
byte 1 101
byte 1 109
byte 1 115
byte 1 32
byte 1 40
byte 1 37
byte 1 100
byte 1 41
byte 1 32
byte 1 114
byte 1 101
byte 1 97
byte 1 99
byte 1 104
byte 1 101
byte 1 100
byte 1 10
byte 1 0
align 1
LABELV $733
byte 1 94
byte 1 49
byte 1 69
byte 1 82
byte 1 82
byte 1 79
byte 1 82
byte 1 58
byte 1 32
byte 1 37
byte 1 115
byte 1 58
byte 1 32
byte 1 102
byte 1 97
byte 1 105
byte 1 108
byte 1 101
byte 1 100
byte 1 32
byte 1 116
byte 1 111
byte 1 32
byte 1 112
byte 1 97
byte 1 114
byte 1 115
byte 1 101
byte 1 32
byte 1 112
byte 1 97
byte 1 114
byte 1 116
byte 1 105
byte 1 99
byte 1 108
byte 1 101
byte 1 32
byte 1 115
byte 1 121
byte 1 115
byte 1 116
byte 1 101
byte 1 109
byte 1 32
byte 1 37
byte 1 115
byte 1 10
byte 1 0
align 1
LABELV $730
byte 1 94
byte 1 49
byte 1 69
byte 1 82
byte 1 82
byte 1 79
byte 1 82
byte 1 58
byte 1 32
byte 1 97
byte 1 32
byte 1 112
byte 1 97
byte 1 114
byte 1 116
byte 1 105
byte 1 99
byte 1 108
byte 1 101
byte 1 32
byte 1 115
byte 1 121
byte 1 115
byte 1 116
byte 1 101
byte 1 109
byte 1 32
byte 1 105
byte 1 115
byte 1 32
byte 1 97
byte 1 108
byte 1 114
byte 1 101
byte 1 97
byte 1 100
byte 1 121
byte 1 32
byte 1 110
byte 1 97
byte 1 109
byte 1 101
byte 1 100
byte 1 32
byte 1 37
byte 1 115
byte 1 10
byte 1 0
align 1
LABELV $714
byte 1 94
byte 1 49
byte 1 69
byte 1 82
byte 1 82
byte 1 79
byte 1 82
byte 1 58
byte 1 32
byte 1 112
byte 1 97
byte 1 114
byte 1 116
byte 1 105
byte 1 99
byte 1 108
byte 1 101
byte 1 32
byte 1 102
byte 1 105
byte 1 108
byte 1 101
byte 1 32
byte 1 37
byte 1 115
byte 1 32
byte 1 116
byte 1 111
byte 1 111
byte 1 32
byte 1 108
byte 1 111
byte 1 110
byte 1 103
byte 1 10
byte 1 0
align 1
LABELV $708
byte 1 94
byte 1 49
byte 1 69
byte 1 82
byte 1 82
byte 1 79
byte 1 82
byte 1 58
byte 1 32
byte 1 117
byte 1 110
byte 1 107
byte 1 110
byte 1 111
byte 1 119
byte 1 110
byte 1 32
byte 1 116
byte 1 111
byte 1 107
byte 1 101
byte 1 110
byte 1 32
byte 1 39
byte 1 37
byte 1 115
byte 1 39
byte 1 32
byte 1 105
byte 1 110
byte 1 32
byte 1 112
byte 1 97
byte 1 114
byte 1 116
byte 1 105
byte 1 99
byte 1 108
byte 1 101
byte 1 32
byte 1 115
byte 1 121
byte 1 115
byte 1 116
byte 1 101
byte 1 109
byte 1 32
byte 1 37
byte 1 115
byte 1 10
byte 1 0
align 1
LABELV $707
byte 1 80
byte 1 97
byte 1 114
byte 1 115
byte 1 101
byte 1 100
byte 1 32
byte 1 112
byte 1 97
byte 1 114
byte 1 116
byte 1 105
byte 1 99
byte 1 108
byte 1 101
byte 1 32
byte 1 115
byte 1 121
byte 1 115
byte 1 116
byte 1 101
byte 1 109
byte 1 32
byte 1 37
byte 1 115
byte 1 10
byte 1 0
align 1
LABELV $701
byte 1 101
byte 1 106
byte 1 101
byte 1 99
byte 1 116
byte 1 111
byte 1 114
byte 1 0
align 1
LABELV $698
byte 1 116
byte 1 104
byte 1 105
byte 1 114
byte 1 100
byte 1 80
byte 1 101
byte 1 114
byte 1 115
byte 1 111
byte 1 110
byte 1 79
byte 1 110
byte 1 108
byte 1 121
byte 1 0
align 1
LABELV $695
byte 1 94
byte 1 49
byte 1 69
byte 1 82
byte 1 82
byte 1 79
byte 1 82
byte 1 58
byte 1 32
byte 1 109
byte 1 97
byte 1 120
byte 1 105
byte 1 109
byte 1 117
byte 1 109
byte 1 32
byte 1 110
byte 1 117
byte 1 109
byte 1 98
byte 1 101
byte 1 114
byte 1 32
byte 1 111
byte 1 102
byte 1 32
byte 1 112
byte 1 97
byte 1 114
byte 1 116
byte 1 105
byte 1 99
byte 1 108
byte 1 101
byte 1 32
byte 1 101
byte 1 106
byte 1 101
byte 1 99
byte 1 116
byte 1 111
byte 1 114
byte 1 115
byte 1 32
byte 1 40
byte 1 37
byte 1 100
byte 1 41
byte 1 32
byte 1 114
byte 1 101
byte 1 97
byte 1 99
byte 1 104
byte 1 101
byte 1 100
byte 1 10
byte 1 0
align 1
LABELV $692
byte 1 94
byte 1 49
byte 1 69
byte 1 82
byte 1 82
byte 1 79
byte 1 82
byte 1 58
byte 1 32
byte 1 112
byte 1 97
byte 1 114
byte 1 116
byte 1 105
byte 1 99
byte 1 108
byte 1 101
byte 1 32
byte 1 115
byte 1 121
byte 1 115
byte 1 116
byte 1 101
byte 1 109
byte 1 32
byte 1 104
byte 1 97
byte 1 115
byte 1 32
byte 1 62
byte 1 32
byte 1 37
byte 1 100
byte 1 32
byte 1 101
byte 1 106
byte 1 101
byte 1 99
byte 1 116
byte 1 111
byte 1 114
byte 1 115
byte 1 10
byte 1 0
align 1
LABELV $689
byte 1 94
byte 1 49
byte 1 69
byte 1 82
byte 1 82
byte 1 79
byte 1 82
byte 1 58
byte 1 32
byte 1 101
byte 1 106
byte 1 101
byte 1 99
byte 1 116
byte 1 111
byte 1 114
byte 1 32
byte 1 119
byte 1 105
byte 1 116
byte 1 104
byte 1 32
byte 1 39
byte 1 99
byte 1 111
byte 1 117
byte 1 110
byte 1 116
byte 1 32
byte 1 105
byte 1 110
byte 1 102
byte 1 105
byte 1 110
byte 1 105
byte 1 116
byte 1 101
byte 1 39
byte 1 32
byte 1 112
byte 1 111
byte 1 116
byte 1 101
byte 1 110
byte 1 116
byte 1 105
byte 1 97
byte 1 108
byte 1 108
byte 1 121
byte 1 32
byte 1 104
byte 1 97
byte 1 115
byte 1 32
byte 1 122
byte 1 101
byte 1 114
byte 1 111
byte 1 32
byte 1 112
byte 1 101
byte 1 114
byte 1 105
byte 1 111
byte 1 100
byte 1 10
byte 1 0
align 1
LABELV $685
byte 1 94
byte 1 49
byte 1 69
byte 1 82
byte 1 82
byte 1 79
byte 1 82
byte 1 58
byte 1 32
byte 1 102
byte 1 97
byte 1 105
byte 1 108
byte 1 101
byte 1 100
byte 1 32
byte 1 116
byte 1 111
byte 1 32
byte 1 112
byte 1 97
byte 1 114
byte 1 115
byte 1 101
byte 1 32
byte 1 112
byte 1 97
byte 1 114
byte 1 116
byte 1 105
byte 1 99
byte 1 108
byte 1 101
byte 1 32
byte 1 101
byte 1 106
byte 1 101
byte 1 99
byte 1 116
byte 1 111
byte 1 114
byte 1 10
byte 1 0
align 1
LABELV $672
byte 1 94
byte 1 49
byte 1 69
byte 1 82
byte 1 82
byte 1 79
byte 1 82
byte 1 58
byte 1 32
byte 1 117
byte 1 110
byte 1 107
byte 1 110
byte 1 111
byte 1 119
byte 1 110
byte 1 32
byte 1 116
byte 1 111
byte 1 107
byte 1 101
byte 1 110
byte 1 32
byte 1 39
byte 1 37
byte 1 115
byte 1 39
byte 1 32
byte 1 105
byte 1 110
byte 1 32
byte 1 112
byte 1 97
byte 1 114
byte 1 116
byte 1 105
byte 1 99
byte 1 108
byte 1 101
byte 1 32
byte 1 101
byte 1 106
byte 1 101
byte 1 99
byte 1 116
byte 1 111
byte 1 114
byte 1 10
byte 1 0
align 1
LABELV $669
byte 1 112
byte 1 97
byte 1 114
byte 1 116
byte 1 105
byte 1 99
byte 1 108
byte 1 101
byte 1 0
align 1
LABELV $666
byte 1 105
byte 1 110
byte 1 102
byte 1 105
byte 1 110
byte 1 105
byte 1 116
byte 1 101
byte 1 0
align 1
LABELV $661
byte 1 99
byte 1 111
byte 1 117
byte 1 110
byte 1 116
byte 1 0
align 1
LABELV $650
byte 1 112
byte 1 101
byte 1 114
byte 1 105
byte 1 111
byte 1 100
byte 1 0
align 1
LABELV $645
byte 1 100
byte 1 101
byte 1 108
byte 1 97
byte 1 121
byte 1 0
align 1
LABELV $642
byte 1 94
byte 1 49
byte 1 69
byte 1 82
byte 1 82
byte 1 79
byte 1 82
byte 1 58
byte 1 32
byte 1 109
byte 1 97
byte 1 120
byte 1 105
byte 1 109
byte 1 117
byte 1 109
byte 1 32
byte 1 110
byte 1 117
byte 1 109
byte 1 98
byte 1 101
byte 1 114
byte 1 32
byte 1 111
byte 1 102
byte 1 32
byte 1 112
byte 1 97
byte 1 114
byte 1 116
byte 1 105
byte 1 99
byte 1 108
byte 1 101
byte 1 115
byte 1 32
byte 1 40
byte 1 37
byte 1 100
byte 1 41
byte 1 32
byte 1 114
byte 1 101
byte 1 97
byte 1 99
byte 1 104
byte 1 101
byte 1 100
byte 1 10
byte 1 0
align 1
LABELV $639
byte 1 94
byte 1 49
byte 1 69
byte 1 82
byte 1 82
byte 1 79
byte 1 82
byte 1 58
byte 1 32
byte 1 101
byte 1 106
byte 1 101
byte 1 99
byte 1 116
byte 1 111
byte 1 114
byte 1 32
byte 1 104
byte 1 97
byte 1 115
byte 1 32
byte 1 62
byte 1 32
byte 1 37
byte 1 100
byte 1 32
byte 1 112
byte 1 97
byte 1 114
byte 1 116
byte 1 105
byte 1 99
byte 1 108
byte 1 101
byte 1 115
byte 1 10
byte 1 0
align 1
LABELV $636
byte 1 94
byte 1 49
byte 1 69
byte 1 82
byte 1 82
byte 1 79
byte 1 82
byte 1 58
byte 1 32
byte 1 102
byte 1 97
byte 1 105
byte 1 108
byte 1 101
byte 1 100
byte 1 32
byte 1 116
byte 1 111
byte 1 32
byte 1 112
byte 1 97
byte 1 114
byte 1 115
byte 1 101
byte 1 32
byte 1 112
byte 1 97
byte 1 114
byte 1 116
byte 1 105
byte 1 99
byte 1 108
byte 1 101
byte 1 10
byte 1 0
align 1
LABELV $622
byte 1 94
byte 1 49
byte 1 69
byte 1 82
byte 1 82
byte 1 79
byte 1 82
byte 1 58
byte 1 32
byte 1 117
byte 1 110
byte 1 107
byte 1 110
byte 1 111
byte 1 119
byte 1 110
byte 1 32
byte 1 116
byte 1 111
byte 1 107
byte 1 101
byte 1 110
byte 1 32
byte 1 39
byte 1 37
byte 1 115
byte 1 39
byte 1 32
byte 1 105
byte 1 110
byte 1 32
byte 1 112
byte 1 97
byte 1 114
byte 1 116
byte 1 105
byte 1 99
byte 1 108
byte 1 101
byte 1 10
byte 1 0
align 1
LABELV $617
byte 1 99
byte 1 104
byte 1 105
byte 1 108
byte 1 100
byte 1 84
byte 1 114
byte 1 97
byte 1 105
byte 1 108
byte 1 83
byte 1 121
byte 1 115
byte 1 116
byte 1 101
byte 1 109
byte 1 0
align 1
LABELV $612
byte 1 111
byte 1 110
byte 1 68
byte 1 101
byte 1 97
byte 1 116
byte 1 104
byte 1 83
byte 1 121
byte 1 115
byte 1 116
byte 1 101
byte 1 109
byte 1 0
align 1
LABELV $607
byte 1 99
byte 1 104
byte 1 105
byte 1 108
byte 1 100
byte 1 83
byte 1 121
byte 1 115
byte 1 116
byte 1 101
byte 1 109
byte 1 0
align 1
LABELV $602
byte 1 108
byte 1 105
byte 1 102
byte 1 101
byte 1 84
byte 1 105
byte 1 109
byte 1 101
byte 1 0
align 1
LABELV $591
byte 1 114
byte 1 111
byte 1 116
byte 1 97
byte 1 116
byte 1 105
byte 1 111
byte 1 110
byte 1 0
align 1
LABELV $588
byte 1 94
byte 1 49
byte 1 69
byte 1 82
byte 1 82
byte 1 79
byte 1 82
byte 1 58
byte 1 32
byte 1 109
byte 1 105
byte 1 115
byte 1 115
byte 1 105
byte 1 110
byte 1 103
byte 1 32
byte 1 39
byte 1 123
byte 1 39
byte 1 10
byte 1 0
align 1
LABELV $567
byte 1 99
byte 1 111
byte 1 108
byte 1 111
byte 1 114
byte 1 0
align 1
LABELV $556
byte 1 97
byte 1 108
byte 1 112
byte 1 104
byte 1 97
byte 1 0
align 1
LABELV $545
byte 1 114
byte 1 97
byte 1 100
byte 1 105
byte 1 117
byte 1 115
byte 1 0
align 1
LABELV $542
byte 1 99
byte 1 117
byte 1 108
byte 1 108
byte 1 79
byte 1 110
byte 1 83
byte 1 116
byte 1 97
byte 1 114
byte 1 116
byte 1 83
byte 1 111
byte 1 108
byte 1 105
byte 1 100
byte 1 0
align 1
LABELV $539
byte 1 94
byte 1 49
byte 1 69
byte 1 82
byte 1 82
byte 1 79
byte 1 82
byte 1 58
byte 1 32
byte 1 109
byte 1 105
byte 1 115
byte 1 115
byte 1 105
byte 1 110
byte 1 103
byte 1 32
byte 1 39
byte 1 125
byte 1 39
byte 1 10
byte 1 0
align 1
LABELV $538
byte 1 125
byte 1 0
align 1
LABELV $533
byte 1 123
byte 1 0
align 1
LABELV $528
byte 1 45
byte 1 0
align 1
LABELV $519
byte 1 100
byte 1 121
byte 1 110
byte 1 97
byte 1 109
byte 1 105
byte 1 99
byte 1 76
byte 1 105
byte 1 103
byte 1 104
byte 1 116
byte 1 0
align 1
LABELV $516
byte 1 114
byte 1 101
byte 1 97
byte 1 108
byte 1 76
byte 1 105
byte 1 103
byte 1 104
byte 1 116
byte 1 0
align 1
LABELV $513
byte 1 111
byte 1 118
byte 1 101
byte 1 114
byte 1 100
byte 1 114
byte 1 97
byte 1 119
byte 1 80
byte 1 114
byte 1 111
byte 1 116
byte 1 101
byte 1 99
byte 1 116
byte 1 105
byte 1 111
byte 1 110
byte 1 0
align 1
LABELV $508
byte 1 110
byte 1 111
byte 1 114
byte 1 109
byte 1 97
byte 1 108
byte 1 68
byte 1 105
byte 1 115
byte 1 112
byte 1 108
byte 1 97
byte 1 99
byte 1 101
byte 1 109
byte 1 101
byte 1 110
byte 1 116
byte 1 0
align 1
LABELV $497
byte 1 100
byte 1 105
byte 1 115
byte 1 112
byte 1 108
byte 1 97
byte 1 99
byte 1 101
byte 1 109
byte 1 101
byte 1 110
byte 1 116
byte 1 0
align 1
LABELV $486
byte 1 97
byte 1 99
byte 1 99
byte 1 101
byte 1 108
byte 1 101
byte 1 114
byte 1 97
byte 1 116
byte 1 105
byte 1 111
byte 1 110
byte 1 80
byte 1 111
byte 1 105
byte 1 110
byte 1 116
byte 1 0
align 1
LABELV $475
byte 1 97
byte 1 99
byte 1 99
byte 1 101
byte 1 108
byte 1 101
byte 1 114
byte 1 97
byte 1 116
byte 1 105
byte 1 111
byte 1 110
byte 1 0
align 1
LABELV $470
byte 1 97
byte 1 99
byte 1 99
byte 1 101
byte 1 108
byte 1 101
byte 1 114
byte 1 97
byte 1 116
byte 1 105
byte 1 111
byte 1 110
byte 1 77
byte 1 97
byte 1 103
byte 1 110
byte 1 105
byte 1 116
byte 1 117
byte 1 100
byte 1 101
byte 1 0
align 1
LABELV $461
byte 1 97
byte 1 99
byte 1 99
byte 1 101
byte 1 108
byte 1 101
byte 1 114
byte 1 97
byte 1 116
byte 1 105
byte 1 111
byte 1 110
byte 1 68
byte 1 105
byte 1 114
byte 1 0
align 1
LABELV $446
byte 1 97
byte 1 99
byte 1 99
byte 1 101
byte 1 108
byte 1 101
byte 1 114
byte 1 97
byte 1 116
byte 1 105
byte 1 111
byte 1 110
byte 1 84
byte 1 121
byte 1 112
byte 1 101
byte 1 0
align 1
LABELV $435
byte 1 118
byte 1 101
byte 1 108
byte 1 111
byte 1 99
byte 1 105
byte 1 116
byte 1 121
byte 1 80
byte 1 111
byte 1 105
byte 1 110
byte 1 116
byte 1 0
align 1
LABELV $424
byte 1 118
byte 1 101
byte 1 108
byte 1 111
byte 1 99
byte 1 105
byte 1 116
byte 1 121
byte 1 0
align 1
LABELV $419
byte 1 112
byte 1 97
byte 1 114
byte 1 101
byte 1 110
byte 1 116
byte 1 86
byte 1 101
byte 1 108
byte 1 111
byte 1 99
byte 1 105
byte 1 116
byte 1 121
byte 1 70
byte 1 114
byte 1 97
byte 1 99
byte 1 116
byte 1 105
byte 1 111
byte 1 110
byte 1 0
align 1
LABELV $414
byte 1 118
byte 1 101
byte 1 108
byte 1 111
byte 1 99
byte 1 105
byte 1 116
byte 1 121
byte 1 77
byte 1 97
byte 1 103
byte 1 110
byte 1 105
byte 1 116
byte 1 117
byte 1 100
byte 1 101
byte 1 0
align 1
LABELV $411
byte 1 112
byte 1 111
byte 1 105
byte 1 110
byte 1 116
byte 1 0
align 1
LABELV $408
byte 1 108
byte 1 105
byte 1 110
byte 1 101
byte 1 97
byte 1 114
byte 1 0
align 1
LABELV $403
byte 1 118
byte 1 101
byte 1 108
byte 1 111
byte 1 99
byte 1 105
byte 1 116
byte 1 121
byte 1 68
byte 1 105
byte 1 114
byte 1 0
align 1
LABELV $400
byte 1 110
byte 1 111
byte 1 114
byte 1 109
byte 1 97
byte 1 108
byte 1 0
align 1
LABELV $397
byte 1 99
byte 1 101
byte 1 110
byte 1 116
byte 1 0
align 1
LABELV $394
byte 1 116
byte 1 97
byte 1 103
byte 1 0
align 1
LABELV $391
byte 1 115
byte 1 116
byte 1 97
byte 1 116
byte 1 105
byte 1 99
byte 1 95
byte 1 116
byte 1 114
byte 1 97
byte 1 110
byte 1 115
byte 1 102
byte 1 111
byte 1 114
byte 1 109
byte 1 0
align 1
LABELV $388
byte 1 115
byte 1 116
byte 1 97
byte 1 116
byte 1 105
byte 1 99
byte 1 0
align 1
LABELV $383
byte 1 118
byte 1 101
byte 1 108
byte 1 111
byte 1 99
byte 1 105
byte 1 116
byte 1 121
byte 1 84
byte 1 121
byte 1 112
byte 1 101
byte 1 0
align 1
LABELV $366
byte 1 109
byte 1 111
byte 1 100
byte 1 101
byte 1 108
byte 1 65
byte 1 110
byte 1 105
byte 1 109
byte 1 97
byte 1 116
byte 1 105
byte 1 111
byte 1 110
byte 1 0
align 1
LABELV $357
byte 1 94
byte 1 49
byte 1 69
byte 1 82
byte 1 82
byte 1 79
byte 1 82
byte 1 58
byte 1 32
byte 1 39
byte 1 109
byte 1 111
byte 1 100
byte 1 101
byte 1 108
byte 1 39
byte 1 32
byte 1 110
byte 1 111
byte 1 116
byte 1 32
byte 1 97
byte 1 108
byte 1 108
byte 1 111
byte 1 119
byte 1 101
byte 1 100
byte 1 32
byte 1 105
byte 1 110
byte 1 32
byte 1 99
byte 1 111
byte 1 110
byte 1 106
byte 1 117
byte 1 110
byte 1 99
byte 1 116
byte 1 105
byte 1 111
byte 1 110
byte 1 32
byte 1 119
byte 1 105
byte 1 116
byte 1 104
byte 1 32
byte 1 39
byte 1 115
byte 1 104
byte 1 97
byte 1 100
byte 1 101
byte 1 114
byte 1 39
byte 1 10
byte 1 0
align 1
LABELV $354
byte 1 109
byte 1 111
byte 1 100
byte 1 101
byte 1 108
byte 1 0
align 1
LABELV $345
byte 1 115
byte 1 121
byte 1 110
byte 1 99
byte 1 0
align 1
LABELV $340
byte 1 94
byte 1 49
byte 1 69
byte 1 82
byte 1 82
byte 1 79
byte 1 82
byte 1 58
byte 1 32
byte 1 39
byte 1 115
byte 1 104
byte 1 97
byte 1 100
byte 1 101
byte 1 114
byte 1 39
byte 1 32
byte 1 110
byte 1 111
byte 1 116
byte 1 32
byte 1 97
byte 1 108
byte 1 108
byte 1 111
byte 1 119
byte 1 101
byte 1 100
byte 1 32
byte 1 105
byte 1 110
byte 1 32
byte 1 99
byte 1 111
byte 1 110
byte 1 106
byte 1 117
byte 1 110
byte 1 99
byte 1 116
byte 1 105
byte 1 111
byte 1 110
byte 1 32
byte 1 119
byte 1 105
byte 1 116
byte 1 104
byte 1 32
byte 1 39
byte 1 109
byte 1 111
byte 1 100
byte 1 101
byte 1 108
byte 1 39
byte 1 10
byte 1 0
align 1
LABELV $337
byte 1 115
byte 1 104
byte 1 97
byte 1 100
byte 1 101
byte 1 114
byte 1 0
align 1
LABELV $330
byte 1 98
byte 1 111
byte 1 117
byte 1 110
byte 1 99
byte 1 101
byte 1 83
byte 1 111
byte 1 117
byte 1 110
byte 1 100
byte 1 0
align 1
LABELV $321
byte 1 98
byte 1 111
byte 1 117
byte 1 110
byte 1 99
byte 1 101
byte 1 77
byte 1 97
byte 1 114
byte 1 107
byte 1 0
align 1
LABELV $318
byte 1 99
byte 1 117
byte 1 108
byte 1 108
byte 1 0
align 1
LABELV $313
byte 1 98
byte 1 111
byte 1 117
byte 1 110
byte 1 99
byte 1 101
byte 1 0
align 1
LABELV $302
byte 1 0
align 1
LABELV $283
byte 1 94
byte 1 49
byte 1 69
byte 1 82
byte 1 82
byte 1 79
byte 1 82
byte 1 58
byte 1 32
byte 1 102
byte 1 97
byte 1 105
byte 1 108
byte 1 101
byte 1 100
byte 1 32
byte 1 116
byte 1 111
byte 1 32
byte 1 114
byte 1 101
byte 1 103
byte 1 105
byte 1 115
byte 1 116
byte 1 101
byte 1 114
byte 1 32
byte 1 112
byte 1 97
byte 1 114
byte 1 116
byte 1 105
byte 1 99
byte 1 108
byte 1 101
byte 1 32
byte 1 115
byte 1 121
byte 1 115
byte 1 116
byte 1 101
byte 1 109
byte 1 32
byte 1 37
byte 1 115
byte 1 10
byte 1 0
align 1
LABELV $282
byte 1 82
byte 1 101
byte 1 103
byte 1 105
byte 1 115
byte 1 116
byte 1 101
byte 1 114
byte 1 101
byte 1 100
byte 1 32
byte 1 112
byte 1 97
byte 1 114
byte 1 116
byte 1 105
byte 1 99
byte 1 108
byte 1 101
byte 1 32
byte 1 115
byte 1 121
byte 1 115
byte 1 116
byte 1 101
byte 1 109
byte 1 32
byte 1 37
byte 1 115
byte 1 10
byte 1 0
align 1
LABELV $243
byte 1 80
byte 1 83
byte 1 32
byte 1 37
byte 1 115
byte 1 32
byte 1 99
byte 1 114
byte 1 101
byte 1 97
byte 1 116
byte 1 101
byte 1 100
byte 1 10
byte 1 0
align 1
LABELV $229
byte 1 94
byte 1 49
byte 1 69
byte 1 82
byte 1 82
byte 1 79
byte 1 82
byte 1 58
byte 1 32
byte 1 97
byte 1 32
byte 1 112
byte 1 97
byte 1 114
byte 1 116
byte 1 105
byte 1 99
byte 1 108
byte 1 101
byte 1 32
byte 1 115
byte 1 121
byte 1 115
byte 1 116
byte 1 101
byte 1 109
byte 1 32
byte 1 104
byte 1 97
byte 1 115
byte 1 32
byte 1 110
byte 1 111
byte 1 116
byte 1 32
byte 1 98
byte 1 101
byte 1 101
byte 1 110
byte 1 32
byte 1 114
byte 1 101
byte 1 103
byte 1 105
byte 1 115
byte 1 116
byte 1 101
byte 1 114
byte 1 101
byte 1 100
byte 1 32
byte 1 121
byte 1 101
byte 1 116
byte 1 10
byte 1 0
align 1
LABELV $224
byte 1 80
byte 1 69
byte 1 32
byte 1 37
byte 1 115
byte 1 32
byte 1 99
byte 1 114
byte 1 101
byte 1 97
byte 1 116
byte 1 101
byte 1 100
byte 1 10
byte 1 0
align 1
LABELV $164
byte 1 94
byte 1 49
byte 1 69
byte 1 82
byte 1 82
byte 1 79
byte 1 82
byte 1 58
byte 1 32
byte 1 97
byte 1 32
byte 1 112
byte 1 97
byte 1 114
byte 1 116
byte 1 105
byte 1 99
byte 1 108
byte 1 101
byte 1 32
byte 1 119
byte 1 105
byte 1 116
byte 1 104
byte 1 32
byte 1 118
byte 1 101
byte 1 108
byte 1 111
byte 1 99
byte 1 105
byte 1 116
byte 1 121
byte 1 84
byte 1 121
byte 1 112
byte 1 101
byte 1 32
byte 1 110
byte 1 111
byte 1 114
byte 1 109
byte 1 97
byte 1 108
byte 1 32
byte 1 104
byte 1 97
byte 1 115
byte 1 32
byte 1 110
byte 1 111
byte 1 32
byte 1 110
byte 1 111
byte 1 114
byte 1 109
byte 1 97
byte 1 108
byte 1 10
byte 1 0
